---
title: TypeScript
date: 2021/4/18
categories:
 - [前端,JavaScript]
---

- `TypeScript`可以编译出纯净、简洁的`JavaScript`代码，并且可以运行在任何浏览器上、`Node.js`环境中和任何支持`ECMAScript3`（或更高版本）的`JavaScript`引擎中
- 类型允许`JavaScript`开发者在开发`JavaScript`应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构
- `TypeScript`提供最新的和不断发展的`JavaScript`特性，包括那些来自2015年的`ECMAScript`和未来的提案中的特性

# 基本使用

`ts` 可以安装到全局，也可以在项目中安装

# 全局安装

- 首先运行 `npm install -g typescript` 全局安装`ts`
- 然后编写 `.ts` 后缀名的文件
- 在终端运行 `tsc` 文件名`.ts` 就可以自动生成编译好的`js`文件

# 局部安装

使用`yarn`

- `yarn init --yes` 创建项目
- `yarn add typescript --dev` 安装 `TypeScript` 模块
- `yarn tsc 文件名.ts` 运行编译
- 推荐使用`yarn` 运行`tsc`指令不需要修改`package.json`

使用`npm`

- 在项目目录运行 `npm i typescript -D`
- 在`package.json`文件的`script`中添加命令设置 `"tsc":"tsc"`
- 编写`.ts`后缀名的文件 在终端运行 `npm run tsc 文件名.ts`

# ts配置文件

运行 `yarn tsc --init` 创建`tsconfig.json` 配置文件。

我们来了解几个简单的配置项含义

- `"target": "ES5"` `ts`编译成`ECMAScript`对应版本的`js`
- `"module": "commonjs"` `ts`编译模块化导入的标准
- `"outDir": "dist"` 编译好的`js`文件输出到`dist`目录
- `"rootDir": "src"` 要编译的文件夹，会把文件夹内的`ts`文件都进行编译
- `"sourceMap": true` 开启源代码映射，方便调试
- `"strict": true` 严格检查模式

# 原始数据类型

`ts` 中的原始数据类型与`flow`类似 ，但是根据`strict`设置不同，也有一些差异。

这里我们需要解决一个标准库的问题，因为如果在编码中使用了非当前标准库的语法那么`ts`就会报错，我们可以通过修改`ts`配置文件中的`lib` 属性来添加标准库
标准库就是内置对象所对应的声明，我们在代码中使用内置对象就要使用对应的标准库，否则`typeScript`就找不到对应的类型，就会报错

# 不同文件的变量重名问题

在同一目录下的不同`ts`文件中，如果声明的变量重名了，会报错重名。这是作用域的问题，因为这些变量都是声明在全局上的，所以会提示错误。

- 方案一, 使用自调用函数提供封闭作用域
- 方案二, 在代码中提供 `export {}` 将其中所有成员作为模块成员

# `object` 类型

`object` 类型，并不是限制只能传入对象，而是指所有非原始数据类型之外的类型，可以是函数也可以使数组也可以是对象

# 数组类型

-  `const arr1: Array<number> = [2,3,4]`
-  `const arr2: number[] = [1, 2, 3]`

假设我们定义一个函数 接收不固定数量的参数，要求这些参数都是数字类型。如果是在`js`中我们可能需要添加参数类型的判断，而如果使用`ts` 就会简单很多

# 元组类型

元组就是明确元素数量以及每个元素类型的数组

# 枚举

- 枚举可以给几个数值取上容易理解的名字
- 一个枚举中只会存在几个固定的值，不会出现超出范围的可能性
- `js`中可以使用对象去模拟枚举，而ts中有专门的`enum`类型	

# 函数类型

- 函数声明，设置可选参数可以使用 `a?` 或者 函数默认值 `b: number=10`，不确定数量的可以用`ES6`的`…args`
- 函数表达式

# 任意类型

使用 `any` 接收任意类型参数，依然是动态类型。不会有类型检查，依然有类型安全问题

# 隐式类型推断

如果我们没有给一个变量添加类型注解，那么`ts`会根据这个变量的使用，去推断它的类型。建议还是给每一个都添加类型注解

# 类型断言

在某些情况下 `TS` 无法在编译过程中 知道一个运算的值是什么类型，从而导致后续的代码编译时报错
那么此时我们ts使用断言 `as` 来确定类型

# 接口 `interface`

接口可以用来约定一个对象的结构，我们使用一个接口，那么就要遵守这个接口全部的约定

- 可选成员 给属性后面添加 `?` 表示该属性可选
- 只读成员 给属性名前面添加 `readonly` 该属性在初始化之后就不能再被修改了
- 动态属性

# `TypeScript` 中类的基本使用

`ts` 中类的使用与`js`中`ES6`中新增的`class` 差不多，略有差异。 主要体现在类属性定义上，`ts`的`class`中的类属性在使用之前，必须要先声明。

# 访问修饰符

- `public` 公开的，在属性或者方法前进行修饰，表示可以被外部访问，这也是默认的修饰符
- `private` 私有的，只能在类的内部访问，实例无法在外部调用
- `protected` 保护的，可以理解为受限的，只能在类内部或者子类中进行访问

如果`constructor`添加了`private` 那么是不能直接在类外部`new`出实例的，可以在静态方法中来调用`new`创建实例，并`return`
添加只读属性，`class`中添加只读属性跟接口中类似都是通过`readonly`来实现，具体语法就是给在属性修饰符之后属性名之前 添加`readonly` `public` `readonly` `name: string`

# 类与接口

`ts`中提到的接口，跟我们前端开发中经常提到的接口请求的接口，有一定差别。

很多只接触过`JavaScript`的朋友对于接口的理解，可能是我请求这个接口地址就能获得对应的数据 ，而我们`ts`这里提到的接口，是强类型语言中的一个概念，主要是用来实现多态。

而多态在`js`中并不需要特地去实现，因为`js`本身就是弱类型的，它天生就有多态的能力。

`ts`中的接口是比类更加抽象的一种概念，可以理解为是多个类它们之间共性的一种约定，类实现(`implements`)了某个接口 那么它的内部就必须拥有这种接口的能力。

# 抽象类

抽象类更像是接口跟父类的结合，既可以在其中定义具体的方法，也可以定义抽象方法交给子类去自由实现
抽象类是用来继承的，不能被实例化。抽象类里可以有成员变量，接口中没有。
定义一个抽象类，使用`abstract` `class`两关键字定义

# 泛型

不确定函数的参数类型或者返回值类型可以使用泛型。

`T` 代表 `Type`，在定义泛型时通常用作第一个类型变量名称。但实际上 `T` 可以用任何有效名称代替。除了 `T` 之外，以下是常见泛型变量代表的意思：

`K`（`Key`）：表示对象中的键类型；
`V`（`Value`）：表示对象中的值类型；
`E`（`Element`）：表示元素类型

# 类型声明 

在开发过程中不可避免要引用其他第三方的 `JavaScript` 的库，虽然通过直接引用可以调用库的类和方法，但是却无法使用 `TypeScript` 诸如类型检查等特性功能。


一般的第三方`js`插件在`npm`上都有对应的声明文件，比如`lodash`的声明文件就可以在`npm`上下载 `npm i @types/lodash` 这样使用的时候导入.

以`.d.ts`结尾的就是声明文件，这样就不会再报找不到模块声明了

如果第三方插件没有对应的声明文件我们可以自己去为它的成员添加类型声明从而添加类型检查

