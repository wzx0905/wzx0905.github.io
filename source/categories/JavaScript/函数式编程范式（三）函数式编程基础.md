---
title: 函数式编程范式（三）函数式编程基础
date: 2021/3/17
categories:
 - [前端,JavaScript]
---

# `lodash`

一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法

# 纯函数

- **相同的输入永远会得到相同的输出**，而且没有任何可观察的副作用
  - 纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，`y = f(x)`
- 数组的 `slice` 和 `splice` 分别是：纯函数和不纯的函数
  - `slice` 返回数组中的指定部分，不会改变原数组
  - `splice` 对数组进行操作返回该数组，会改变原数组

```js
let numbers = [1, 2, 3, 4, 5]
// 纯函数
numbers.slice(0, 3)
// => [1, 2, 3]
numbers.slice(0, 3)
// => [1, 2, 3]
numbers.slice(0, 3)
// => [1, 2, 3]
// 不纯的函数
numbers.splice(0, 3)
// => [1, 2, 3]
numbers.splice(0, 3)
// => [4, 5]
numbers.splice(0, 3)
// => []
```

- 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）
- 我们可以把一个函数的执行结果交给另一个函数去处理

纯函数的好处

- 可缓存
  - 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来

``` js
const _ = require('lodash')
function getArea (r) {
	return Math.PI * r * r
}
let getAreaWithMemory = _.memoize(getArea)
console.log(getAreaWithMemory(4))
```

*`注：当第一次输入getAreaWithMemory(4)时，会执行函数并将结果进行缓存，当再次输入相同值时会直接从缓存中读取该数据`*

- 自己模拟一个 `memoize` 函数

```js
// memoize
function memoize (f) {
	let cache = {}
	return function () {
        let arg_str = JSON.stringify(arguments)
        cache[arg_str] = cache[arg_str] || f.apply(f, arguments)
        return cache[arg_str]
	}
}
```

*`注：以函数f的参数作为cache的键，以其对应的运行结果作为值进行缓存，当下次输入相同参数时会直接从缓存中取值`*

- 可测试
  - 纯函数让测试更方便
- 并行处理
  - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
  - 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 (Web Worker)

副作用

- 纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

``` js
// 不纯的
let mini = 18
function checkAge (age) {
    return age >= mini
}
// 纯的(有硬编码，可以通过柯里化解决)
function checkAge (age) {
    let mini = 18
    return age >= mini
}
```

*`注：对函数外部的变量有引用导致函数不纯`*

副作用让一个函数变的不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部 的状态就无法保证输出相同，就会带来副作用。

副作用来源：

- 配置文件
- 数据库
- 获取用户的输入

所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

# 柯里化

`Haskell Brooks Curry`

可以使用柯里化解决上一个案例中硬编码的问题

``` js
function checkAge (age) {
    let min = 18
    return age >= min
}
// 普通纯函数
function checkAge (min, age) {
	return age >= min
}
checkAge(18, 24)
checkAge(18, 20)
checkAge(20, 30)
// 柯里化
function checkAge (min) {
    return function (age) {
    	return age >= min
    }
}
// ES6 写法
let checkAge = min => (age => age >= min)
let checkAge18 = checkAge(18)
let checkAge20 = checkAge(20)
checkAge18(24)
checkAge18(20)
```

*`注：此处通过函数的柯里化，先传递部分参数（例：min=18），返回新的函数checkAge(18)，新生成的函数不需要传入min，只需要传入剩余参数age即可得到对应结果`*

- 柯里化 (`Currying`)
  - 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
  - 然后返回一个新的函数接收剩余的参数，返回结果
- `lodash` 中的柯里化函数
  - `_.curry(func)`
    - 功能：创建一个函数，该函数接收一个或多个 `func` 的参数，如果 `func` 所需要的参数都被提 供则执行 `func` 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。
    - 参数：需要柯里化的函数
    - 返回值：柯里化后的函数

```js
const _ = require('lodash')
// 要柯里化的函数
function getSum (a, b, c) {
	return a + b + c
}
// 柯里化后的函数
let curried = _.curry(getSum)
// 测试
curried(1, 2, 3)
curried(1)(2)(3)
curried(1, 2)(3)
```

- 案例

``` js
const _ = require('lodash')
const match = _.curry(function (reg, str) {
	return str.match(reg)
})
const haveSpace = match(/\s+/g)
const haveNumber = match(/\d+/g)
console.log(haveSpace('hello world'))
console.log(haveNumber('25$'))
const filter = _.curry(function (func, array) {
	return array.filter(func)
})
console.log(filter(haveSpace, ['John Connor', 'John_Donne']))
const findSpace = filter(haveSpace)
console.log(findSpace(['John Connor', 'John_Donne']))
```

- 模拟 `_.curry()` 的实现

```js
function curry (func) {
    return function curriedFn (...args) {
    	// 判断实参和形参的个数
        if (args.length < func.length) {
            return function () {
                return curriedFn(...args.concat(Array.from(arguments)))
            }
        }
        // 实参和形参个数相同，调用 func，返回结果
        return func(...args)
    }
}
```

- 总结
  - 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
  - 这是一种对函数参数的'缓存'
  - 让函数变的更灵活，让函数的粒度更小
  - 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能

# 函数组合

- 纯函数和柯里化很容易写出洋葱代码 `h(g(f(x)))`
  - 例：获取数组的最后一个元素再转换成大写字母 `_.toUpper(_.first(_.reverse(array)))`

*`注：洋葱代码可读性差，且不易于调试代码，要避免出现洋葱代码`*

- 函数组合可以让我们把细粒度的函数重新组合生成一个新的函数

- 管道

  - 下面这张图表示程序中使用函数处理数据的过程，给 `fn` 函数输入参数 `a`，返回结果 `b`。可以想想 `a` 数据 通过一个管道得到了 `b` 数据。

  ![](https://pic.imgdb.cn/item/60d30877844ef46bb23cc1a0.png)

  - 当 `fn` 函数比较复杂的时候，我们可以把函数 `fn` 拆分成多个小函数，此时多了中间运算过程产生的 `m` 和 `n`。
  - 下面这张图中可以想象成把 `fn` 这个管道拆分成了3个管道 `f1`, `f2`, `f3`，数据 `a` 通过管道 `f3` 得到结果 `m`，`m` 再通过管道 `f2` 得到结果 `n`，`n` 通过管道 `f1` 得到最终结果 `b`

  ![](https://pic.imgdb.cn/item/60d30889844ef46bb23d12a0.png)

```js
fn = compose(f1, f2, f3)
b = fn(a)
```

- 函数组合 (`compose`)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间 过程的函数合并成一个函数
  - 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终 结果
  - **函数组合默认是从右到左执行**

```js
// 组合函数
function compose (f, g) {
    return function (x) {
    	return f(g(x))
    }
}
function first (arr) {
	return arr[0]
}
function reverse (arr) {
	return arr.reverse()
}
// 从右到左运行
let last = compose(first, reverse)
console.log(last([1, 2, 3, 4]))
```

- `lodash` 中组合函数 `flow()` 或者 `flowRight()`，他们都可以组合多个函数
  - `flow()` 是从左到右运行
  - `flowRight()` 是从右到左运行

``` js
const _ = require('lodash')
const toUpper = s => s.toUpperCase()
const reverse = arr => arr.reverse()
const first = arr => arr[0]
const f = _.flowRight(toUpper, first, reverse)
console.log(f(['one', 'two', 'three']))
```

- 模拟实现 `lodash` 的 `flowRight` 方法

```js
// 多函数组合
function compose (...fns) {
    return function (value) {
        return fns.reverse().reduce(function (acc, fn) {
        	return fn(acc)
        }, value)
    }
}
// ES6
const compose = (...fns) => value => fns.reverse().reduce((acc, fn) => fn(acc), value)
```

- 函数的组合要满足**结合律** (`associativity`)：
  - 我们既可以把 `g` 和 `h` 组合，还可以把 `f` 和 `g` 组合，结果都是一样的

```js
// 结合律（associativity）
let f = compose(f, g, h)
let associative = compose(compose(f, g), h) == compose(f, compose(g, h))
// true
```

所以代码还可以像下面这样

``` js
const _ = require('lodash')
// const f = _.flowRight(_.toUpper, _.first, _.reverse)
// const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse)
const f = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse))
console.log(f(['one', 'two', 'three']))
// => THREE
```

- 如何调试组合函数

```js
const f = _.flowRight(_.toUpper, _.first, _.reverse)
console.log(f(['one', 'two', 'three']))
const _ = require('lodash')
const trace = _.curry((tag, v) => {
    console.log(tag, v)
    return v
})
const split = _.curry((sep, str) => _.split(str, sep))
const join = _.curry((sep, array) => _.join(array, sep))
const map = _.curry((fn, array) => _.map(array, fn))
const f = _.flowRight(join('-'), trace('map 之后'), map(_.toLower), trace('split 之后'), split(' '))
console.log(f('NEVER SAY DIE'))
```

- `lodash/fp`
  - `lodash` 的 `fp` 模块提供了实用的对**函数式编程友好**的方法
  - 提供了不可变 **`auto-curried iteratee-first data-last`** 的方法

```js
// lodash 模块
const _ = require('lodash')
_.map(['a', 'b', 'c'], _.toUpper)
// => ['A', 'B', 'C']
_.map(['a', 'b', 'c'])
// => ['a', 'b', 'c']
_.split('Hello World', ' ')
// lodash/fp 模块
const fp = require('lodash/fp')
fp.map(fp.toUpper, ['a', 'b', 'c'])
fp.map(fp.toUpper)(['a', 'b', 'c'])
fp.split(' ', 'Hello World')
fp.split(' ')('Hello World')
// NEVER SAY DIE => never-say-die
const fp = require('lodash/fp')
const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))
console.log(f('NEVER SAY DIE')) // never-say-die
```

*`注：lodash/fp中的方法都是函数优先，数据置后`*

# `Point Free`

我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参 数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

- 不需要指明处理的数据
- **只需要合成运算过程**
- 需要定义一些辅助的基本运算函数

``` js
const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))
```

案例演示

```js
// Hello World => hello_world
// 非 Point Free 模式
function f (word) {
	return word.toLowerCase().replace(/\s+/g, '_');
}
// Point Free
const fp = require('lodash/fp')
const f = fp.flowRight(fp.replace(/\s+/g, '_'), fp.toLower)
console.log(f('Hello World'))
```

```js
// 使用 Point Free 的模式，把单词中的首字母提取并转换成大写
const fp = require('lodash/fp')
const firstLetterToUpper = fp.flowRight(join('. '),
fp.map(fp.flowRight(fp.first, fp.toUpper)), split(' '))
console.log(firstLetterToUpper('world wild web'))
// => W. W. W
```
