---
title: 面试题
date: 2021/3/11
categories:
 - [前端,面试]
tags:
 - encrypt
---

- 执行下面代码会输出什么信息并简答出过程

``` js
function foo() {
    console.log(a)
}
function bar() {
    var a = 3;
    foo();
}
var a = 2;
bar();
```

> **考点：词法作用域**
>
> bar() 执行时，自身作用域的 a = 3 以及 foo () 执行而 foo 里 console.log(a) 为全局的 a 变量，而不是 bar 作用域里的 a 变量，因此结果为 2

- 执行下面代码会输出什么信息并简答出过程

``` js
setTimeout(() => {
    console.log(100);
}, 0);
console.log(200);
Promise.reject(function () {
    console.log(300);
});
```

> **200** 
>
> **Uncaught (in promise) ƒ () { console.log(300); }**
>    
> **100**
>
> **考点：EventLoop**
>
> - 宏任务主要包含：script(整体代码)、setTimeout、setInterval、 I/O、UI 交互事件、setlmmediate(Node.js 环境) 
>- 微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)
> 
> 1. setTimeout => 宏任务，发现任务源，带着回调函数去宏任务里排队
>
> 2. console.log(200) => 主线程任务 立刻执行 => 输出200
>
> 3. Promise.reject => 微任务, 去微任务里排队
>
> 4. 主线程完毕，执行完微任务
>
> 5. Promise.reject抛出异常 => 输出
>
>    Uncaught (in promise) ƒ () { console.log(300); }
>   
> 6. 微任务结束，执行宏任务
> 
> 7. setTimeout 回调函数 => console.log(100) => 输出100

- 执行下面代码会输出什么信息并简答出过程

``` js
// A
Promise.resolve().then(() => {
    console.log(0);
    return Promise.resolve(4);
}).then((res) => {
    console.log(res)
})
// B
Promise.resolve().then(() => {
    console.log(1);
}).then((res) => {
    console.log(2)
}).then((res) => {
    console.log(3)
}).then((res) => {
    console.log(5)
}).then((res) => {
    console.log(6)
})
```

> **0 1 2 3 4 5 6**
>
> 1. AB两段微任务会**交替执行**
>
> 2. 执行顺序
>
>    A段 微任务 **第1个then** 输出0 返回Promise.resolve(4)
>
>    B段 微任务 输出1
>
>    A段 微任务 **第1个then** 无输出，仅判断返回值是Promise对象，得到对象中的值4
>
>    B段 微任务 输出2
>
>    A段 微任务 **第1个then** 无输出，仅判断拿到的4不是Promise对象，执行resolve(4)作为A段**第2个then**的值
>
>    B段 微任务 输出3
>
>    A段 微任务 **第2个then** 接受值4，输出值4
>
>    B段 微任务 输出5
>
>    B段 微任务 输出6

- 请简述网页在浏览器中展示的全过程

> 1. **DNS解析，将域名解析为IP地址**	浏览器通过向DNS服务器发送域名 => DNS服务器查询到与域名相对应的IP地址返回给浏览器 => 浏览器将IP地址打在协议上，同时请求参数也会在协议上搭载，一并发送给对应的服务器
> 2. **TCP连接：TCP三次握手**	三次握手的目的是为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误
> 3. **发送HTTP请求**	请求报文由请求行（request line）、请求头（header）、请求体组成
> 4. **服务器处理请求并返回HTTP报文**
> 5. **浏览器解析渲染页面**	根据HTML解析出DOM树 => 根据CSS解析生成CSS规则树 => 结合DOM树和CSS规则树，生成渲染树 => 根据渲染树计算每一个节点的信息 => 根据计算好的信息绘制页面
> 6. **断开连接：TCP四次挥手**
>
> 参考文章地址：https://segmentfault.com/a/1190000017184701

- 简述 BFC 是什么，以及在工作中的应用场景

> **考点：**
>
> 了解 BFC 是什么，以及如何形成，如何解决生产环境里的实际问题，[参考文章](https://zhuanlan.zhihu.com/p/111106266?utm_source=wechat_session&utm_medium=social&utm_oi=984784516690464768&s_r=0)。
>
> **BFC：块级格式化上下文**
>
> - BFC 的作用：（这块其实就是在阐述在实际工作里的应用场景）
>   - 清除浮动
>   - 外边距折叠
>   - 左图右文布局
> - 如何产生 BFC （代码层面 BFC 是如何产生的）
>   - 根元素：html 根元素 html 元素本身就是一个 BFC 元素记住就好，body 元素不是- float：BFC 浮动元素元素的 float 属性不是 none
>   - position :常用绝对定位元素 position 属性为 absolute 或 fixed
>   - 常用行内块元素：display 属性为 inline-block
>   - 常用表格元素默认 display 属性
>   - 网格元素：display 属性为 grid 或 inline-grid 元素  等
> - BFC 原理
>   - 三种文档定位方式：普通流   浮动  绝对定位
>   - 具体产生原因：BFC 是上面三种布局方式中的普通流，BFC 会产生一个独立的容器，该容器内部的元素不会在布局上影响到外部的元素，在外部的普通流看来它和其他普通流元素无差别，文档最终会按照上面说的普通流计算布局