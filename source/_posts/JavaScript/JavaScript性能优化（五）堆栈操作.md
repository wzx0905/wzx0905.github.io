---
title: JavaScript性能优化（五）堆栈操作
date: 2021/5/3
categories:
 - [前端,JavaScript]
---

# 堆栈准备

- `JS`执行环境
- 执行环境栈（`ECStack`，`execution context stack`）
- 执行上下文
- `VO(G)`，全局变量对象

# 原始类型堆栈处理

![](https://pic.imgdb.cn/item/60e7b15f5132923bf813db95.png)

> - 基本数据类型是按值进行操作
> -  基本数据类型值是存放在栈区的
> -  无论我们当前看到的栈内存，还是后续引用数据类型会使用的堆内存都属于计算机内存
> - `GO`(全局对象)

# 引用类型堆栈处理

## 对象堆栈执行

![](https://pic.imgdb.cn/item/60e7b1605132923bf813df9b.png)

## 函数堆栈执行

![](https://pic.imgdb.cn/item/60e7b1615132923bf813e2c5.png)

> - 函数创建
>   - 可以将函数名称看做是变量，存放在 `VO` 当中 ，同时它的值就是当前函数对应的内存地址
>   - 函数本身也是一个对象，创建时会有一个内存地址，空间内存放的就是函数体代码（字符串形式的）
> - 函数执行
>   - 函数执行时会形成一个全新私有上下文，它里面有一个`AO` 用于管理这个上下文当中的变量
>   - 步骤：
>     - 作用域链 <当前执行上下文， 上级作用域所在的执行上下文>
>     - 确定 `this`
>     - 初始化 `arguments` （对象）
>     - 形参赋值：它就相当于是变量声明，然后将声明的变量放置于 `AO`
>     - 变量提升
>     - 代码执行

# 闭包堆栈执行

![](https://pic.imgdb.cn/item/60e7b1625132923bf813e6f9.png)

> - 闭包： 是一种机制：
>   - 保护：当前上下文当中的变量与其它的上下文中变量互不干扰
>   - 保存：当前上下文中的数据（堆内存）被当前上下文以外的上下文中的变量所引用，这个数据就保存下来了
> - 闭包：
>   - 函数调用形成了一个全新的私有上下文，在函数调用之后当前上下文不被释放就是闭包（临时不被释放）

# 闭包与垃圾回收

![](https://pic.imgdb.cn/item/60e7b1645132923bf813ed5c.png)

# 循环添加事件

![](https://pic.imgdb.cn/item/60e7b1655132923bf813ef8c.png)

