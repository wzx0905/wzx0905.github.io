---
title: 函数式编程范式（二）函数相关内容
date: 2021/3/15
categories:
 - [前端,JavaScript]
---

# 函数是一等公民

[`First-class Function`](https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function)

在 `JavaScript` 中**函数就是一个普通的对象** (可以通过 `new Function()` )，我们可以把函数存储到变量/ 数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过 `new Function('alert(1)')` 来构造一个新的函数。

- **函数存储在变量中**

```js
// 把函数赋值给变量
let fn = function () {
	console.log('Hello First-class Function')
}
fn()
```

```js
// 一个示例
const BlogController = {
    index (posts) { return Views.index(posts) },
    show (post) { return Views.show(post) },
    create (attrs) { return Db.create(attrs) },
    update (post, attrs) { return Db.update(post, attrs) },
    destroy (post) { return Db.destroy(post) }
}
// 优化
const BlogController = {
    index: Views.index,
    show: Views.show,
    create: Db.create,
    update: Db.update,
    destroy: Db.destroy
}
```

*`注：此处优化后将一个函数（方法）直接赋值给另一个函数（方法），可以明显优化代码，提高可读性`*

- **函数作为参数（高阶函数）**

```js
// forEach
function forEach (array, fn) {
	for (let i = 0; i < array.length; i++) {
		fn(array[i])
	}
}
// filter
function filter (array, fn) {
	let results = []
    for (let i = 0; i < array.length; i++) {
		if (fn(array[i])) {
			results.push(array[i])
		}
	}
	return results
}
```

- **函数作为返回值（高阶函数）**

```js
// once
function once (fn) {
	let done = false
	return function () {
		if (!done) {
			done = true
			return fn.apply(this, arguments)
		}
	}
}
```

# 高阶函数

什么是高阶函数

- 高阶函数 (`Higher-order function`)
  - 可以把函数作为参数传递给另一个函数
  - 可以把函数作为另一个函数的返回结果
- 函数作为参数

```js
// forEach
function forEach (array, fn) {
	for (let i = 0; i < array.length; i++) {
		fn(array[i])
	}
}
// filter
function filter (array, fn) {
	let results = []
    for (let i = 0; i < array.length; i++) {
		if (fn(array[i])) {
			results.push(array[i])
		}
	}
	return results
}
```

- 函数作为返回值

``` js
// 案例
function makeFn () {
    let msg = 'Hello function'
    return function () {
        console.log(msg)
    }
}
const fn = makeFn()
fn() // Hello function
// once
function once (fn) {
	let done = false
	return function () {
		if (!done) {
			done = true
			return fn.apply(this, arguments)
		}
	}
}
// 一次支付
let pay = once(function (money) {
	console.log(`支付：${money} RMB`)
})
// 只会支付一次
pay(5) // 支付：5 RMB
pay(5)
pay(5)
```

使用高阶函数的意义

- 抽象可以帮我们屏蔽细节，只需要关注于我们的目标
- 高阶函数是用来抽象通用的问题

``` js
// 面向过程的方式
let array = [1, 2, 3, 4]
    for (let i = 0; i < array.length; i++) {
    console.log(array[i])
}
// 高阶函数方式
let array = [1, 2, 3, 4]
forEach(array, item => {
	console.log(item)
})
let r = filter(array, item => {
	return item % 2 === 0
})
```

常用的高阶函数

- `forEach`

```js
const forEach = (array, fn) => {
	for (let i = 0; i < array.length; i++) {
		fn(array[i])
	}
}
```

- `map`

``` js
const map = (array, fn) => {
    let results = []
    for (const value of array) {
    	results.push(fn(value))
    }
    return results
}
```

- `filter`

``` js
const filter = (array, fn) => {
	let results = []
    for (let i = 0; i < array.length; i++) {
		if (fn(array[i])) {
			results.push(array[i])
		}
	}
	return results
}
```

- `every`

``` js
const every = (array, fn) => {
    let result = true
    for (const value of array) {
        result = fn(value)
    	if (!result) {
        	break
        }
    }
    return result
}
```

- `some`

``` js
const some = (array, fn) => {
    let result = false
    for (const value of array) {
        result = fn(value)
        if (result) {
        	break
    	}
    }
    return result
}
```

- `find`/`findIndex`

``` js
const find = (array, fn) => {
    for (let i = 0; i < array.length; i++) {
		if (fn(array[i])) {
            return array[i]
		}
	}
}
const findIndex = (array, fn) => {
    for (let i = 0; i < array.length; i++) {
		if (fn(array[i])) {
            return i
		}
	}
}
```

- `reduce`

- `sort`
- ......

# 闭包

- 闭包 (`Closure`)：函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包。
  - 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员

- 闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，**但是堆上的作用域成员因为被外部引用不能释放**，因此内部函数依然可以访问外部函数的成员
- 案例

``` js
// 生成计算数字的多少次幂的函数
function makePower (power) {
	return function (x) {
    	return Math.pow(x, power)
    }
}
let power2 = makePower(2)
let power3 = makePower(3)
console.log(power2(4)) // 16
console.log(power3(4)) // 64
// 第一个数是基本工资，第二个数是绩效工资
function makeSalary (x) {
    return function (y) {
    	return x + y
    }
}
let salaryLevel1 = makeSalary(1500)
let salaryLevel2 = makeSalary(2500)
console.log(salaryLevel1(2000)) // 3500
console.log(salaryLevel2(3000)) // 5500
```
