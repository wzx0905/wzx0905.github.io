<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BOM 浏览器对象模型</title>
    <url>/2021/09/8e4e199896e1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="BOM-的概念"><a href="#BOM-的概念" class="headerlink" title="BOM 的概念"></a><code>BOM</code> 的概念</h3><ul>
<li><code>BOM</code>(<code>Browser Object Model</code>) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。<code>BOM</code> 由多个对象组成，其中代表浏览器窗口的 <code>Window</code> 对象是 <code>BOM</code> 的顶层对象，其他对象都是该对象的子对象。</li>
<li>我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理，比如：刷新浏览器、后退、前 进、在浏览器中输入URL等。</li>
</ul>
<h3 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a><code>window</code> 对象</h3><ul>
<li><code>window</code> 是浏览器的顶级对象，当调用 <code>window</code> 下的属性和方法时，可以省略 <code>window</code></li>
<li>注意：<code>window</code>下两个特殊的属性 <code>window.name</code>、<code>window.top</code></li>
</ul>
<h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><ul>
<li><code>alert()</code></li>
<li><code>prompt()</code></li>
<li><code>confirm()</code></li>
</ul>
<h3 id="onload-事件"><a href="#onload-事件" class="headerlink" title="onload 事件"></a><code>onload</code> 事件</h3><ul>
<li>我们可以给 <code>window</code> 对象或者 <code>&lt;img&gt;</code> 等元素添加 <code>onload</code> 加载事件，表示只有绑定事件的元素加载完毕才能触发事件，才能执行事件函数。</li>
<li>其中 <code>window</code> 对象加载完毕：指的是所有<code>HTML</code>结构加载完，并且外部引入资源（<code>js</code>、<code>css</code>、<code>img</code>、 <code>视频</code>）也加载完毕。</li>
<li>应用<ul>
<li>利用 <code>window.onload</code> 事件，可以将 <code>js</code> 代码提前到 <code>html</code> 结构之前</li>
<li>注意：一个页面中只能有一个 <code>window.onload</code> 事件。</li>
</ul>
</li>
</ul>
<h3 id="延时器"><a href="#延时器" class="headerlink" title="延时器"></a>延时器</h3><ul>
<li>延时器是 <code>window</code> 对象的一个方法，类似于定时炸弹</li>
<li>语法：<code>window.setTimeout(func,time);</code></li>
<li>第一个参数：延时执行的函数，可以是匿名函数定义，或者是一个函数名的引用，注意不要加 <code>()</code> 。</li>
<li>第二个参数：延时的时间，以毫秒计数，<code>1000</code> 毫秒等于 <code>1</code> 秒。</li>
<li>功能：在指定的时间后，延迟执行一个函数。</li>
</ul>
<h3 id="清除延时器"><a href="#清除延时器" class="headerlink" title="清除延时器"></a>清除延时器</h3><ul>
<li><code>window</code> 对象的一个方法</li>
<li>语法：<code>window.clearTimeout(timeout);</code></li>
<li>参数：指定的延时器变量名引用。</li>
<li>功能：清除指定的延时器。</li>
<li>注意：清除的延时器需要存储到一个变量中，便于后期清除调用。</li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul>
<li><p>定时器是 <code>window</code> 对象的一个方法，相当于定时闹钟，每隔固定的时间响一次。</p>
</li>
<li><p>语法：<code>window.setInterval(func,interval);</code></p>
</li>
<li><p>第一个参数：每次执行的函数，可以是匿名函数定义，或者是一个函数名的引用，注意不要加 <code>()</code> 。</p>
</li>
<li><p>第二个参数：时间间隔，以毫秒计数，<code>1000</code> 毫秒等于 <code>1</code> 秒。</p>
</li>
<li><p>功能：每隔一个指定的时间，周期性的执行一个函数。</p>
</li>
</ul>
<h3 id="清除定时器"><a href="#清除定时器" class="headerlink" title="清除定时器"></a>清除定时器</h3><ul>
<li><code>window</code> 对象的一个方法</li>
<li>语法：<code>window.clearInterval(timer);</code></li>
<li>参数：指定的定时器变量名引用。</li>
<li>功能：清除指定的定时器。</li>
<li>注意：清除的定时器需要存储到一个变量中，便于后期清除调用。</li>
</ul>
<h3 id="简单运动"><a href="#简单运动" class="headerlink" title="简单运动"></a>简单运动</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>简单运动：是一种视觉暂留效果，只要元素变化过程时间够短，给人眼造成的效果就是一个运动的效果，人眼的视觉残留的时间 0.1-0.4 秒之间。</li>
<li>制作方法：通过定时器，实现每隔一个极短的时间（50-100 毫秒左右），执行函数，函数内部让运动的属性值发生变化。</li>
</ul>
<h4 id="提高运动速度的方法"><a href="#提高运动速度的方法" class="headerlink" title="提高运动速度的方法"></a>提高运动速度的方法</h4><ul>
<li>缩短时间间隔，增加了每秒移动的次数。</li>
<li>加大步长，让每一次走的步长增加。</li>
</ul>
<h3 id="清除定时器的问题"><a href="#清除定时器的问题" class="headerlink" title="清除定时器的问题"></a>清除定时器的问题</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h4><ul>
<li>将定时器的开始和停止过程书写在不同的事件函数内部，容易出现用户错误点击情况<ul>
<li>多次点击开始，会造成加速</li>
<li>多次点击开始，不能够再停止</li>
</ul>
</li>
<li>解决方法<ul>
<li>设表先关</li>
<li>每次开启新定时器之前，都清除一次前面的定时器</li>
</ul>
</li>
</ul>
<h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h4><ul>
<li>需求：要求元素走到指定位置停止，例如让元素停止在 <code>500px</code> 的位置。</li>
<li>问题：如果步长设置的不合理，停止的位置可能不是正好在 <code>500</code> 处。</li>
<li>解决方法<ul>
<li>拉终停表</li>
<li>在定时器内部每次都要判断是否走到了终点，要不要停止定时器</li>
<li>如果走到或超过了终点，强行拉到重点，并停止定时器</li>
</ul>
</li>
</ul>
<h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h4><ul>
<li>需求：在规定时间内让元素走到规定的结束位置，时间间隔可以更改</li>
<li>例如：让元素在 <code>2</code> 秒钟内，<code>left</code> 属性从 <code>0</code> 走到 <code>500px</code></li>
<li>解决方法<ul>
<li>步标整除</li>
<li>总距离 = 步长 * 次数；</li>
<li>时间间隔自定义，总时长固定</li>
<li>求出总次数 = 总时间 / 时间间隔</li>
<li>定义计数器变量，每执行一次定时器函数增加计数 1，直到执行达到总次数，停止定时器</li>
</ul>
</li>
</ul>
<h3 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a><code>location</code> 对象</h3><ul>
<li><code>location</code> 对象是 <code>window</code> 对象下的一个属性，使用的时候可以省略 <code>window</code> 对象</li>
<li><code>location</code> 可以获取或者设置浏览器地址栏的 <code>URL</code></li>
</ul>
<h4 id="location-对象的成员"><a href="#location-对象的成员" class="headerlink" title="location 对象的成员"></a><code>location</code> 对象的成员</h4><ul>
<li><p>使用 <code>chrome</code> 的控制台查看</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/">MDN</a></p>
</li>
<li><p>成员</p>
<ul>
<li><code>assign()</code>/<code>reload()</code>/<code>replace()</code></li>
<li><code>hash</code>/<code>host</code>/<code>hostname</code>/<code>search</code>/<code>href</code></li>
</ul>
</li>
</ul>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a><code>URL</code></h4><ul>
<li>统一资源定位符 (<code>Uniform Resource Locator</code>, <code>URL</code>)</li>
<li><code>URL</code>的组成：<code>scheme://host:port/path?query#fragment</code></li>
<li>例如：<code>http://www.lagou.com:80/a/b/index.html?name=zs&amp;age=18#bottom</code> </li>
<li><code>scheme</code>:通信协议，常用的<code>http</code>,<code>ftp</code>,<code>maito</code>等 </li>
<li><code>host</code>:主机，服务器(计算机)域名系统 (<code>DNS</code>) 主机名或 <code>IP</code> 地址。</li>
<li><code>port</code>:端口号，整数，可选，省略时使用方案的默认端口，如<code>http</code>的默认端口为<code>80</code>。</li>
<li><code>path</code>:路径，由零或多个<code>&#39;/&#39;</code>符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。</li>
<li><code>query</code>:查询，可选，用于给动态网页传递参数，可有多个参数，用<code>&#39;&amp;&#39;</code>符号隔开，每个参数的名和值用<code>&#39;=&#39;</code>符号隔开。例如：<code>name=zs</code></li>
<li><code>fragment</code>:信息片断，字符串，锚点。</li>
</ul>
<h3 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a><code>history</code> 对象</h3><ul>
<li><code>history</code> 对象是 <code>window</code> 对象下的一个属性，使用的时候可以省略 <code>window</code> 对象</li>
<li><code>history</code> 对象可以与浏览器历史记录进行交互，浏览器历史记录是对用户所访问的页面按时间顺序进行的记录和保存。</li>
<li><code>back()</code></li>
<li><code>forward()</code></li>
<li><code>go()</code></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM 特效</title>
    <url>/2021/09/9129bf424132/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p><code>DOM</code> 提供了一套与元素自身有关的位置和大小的属性。</p>
</blockquote>
<h3 id="偏移量属性"><a href="#偏移量属性" class="headerlink" title="偏移量属性"></a>偏移量属性</h3><ul>
<li><code>offsetParent</code> 偏移参考父级，距离自己最近的有定位的父级，如果都没有定位参考<code>body(html)</code></li>
<li><code>offsetLeft</code>/<code>offsetTop</code> 偏移位置</li>
<li><code>offsetWidth</code>/<code>offsetHeight</code> 偏移大</li>
</ul>
<h3 id="偏移量属性-1"><a href="#偏移量属性-1" class="headerlink" title="偏移量属性"></a>偏移量属性</h3><p><img src="https://pic.imgdb.cn/item/61b067352ab3f51d912bb9c3.png"></p>
<h3 id="客户端大小"><a href="#客户端大小" class="headerlink" title="客户端大小"></a>客户端大小</h3><ul>
<li><code>client</code> 系列没有参考父级元素。</li>
<li><code>clientLeft</code>/<code>clientTop</code> 边框区域尺寸，不常用。</li>
<li><code>clientWidth</code>/<code>clientHeight</code> 边框内部大小。</li>
</ul>
<h3 id="客户端大小-1"><a href="#客户端大小-1" class="headerlink" title="客户端大小"></a>客户端大小</h3><p><img src="https://pic.imgdb.cn/item/61b067c32ab3f51d912bf41d.png"></p>
<h3 id="滚动偏移属性"><a href="#滚动偏移属性" class="headerlink" title="滚动偏移属性"></a>滚动偏移属性</h3><ul>
<li><code>scrollLeft</code>/<code>scrollTop</code> 盒子内部滚动出去的尺寸</li>
<li><code>scrollWidth</code>/<code>scrollHeight</code> 盒子内容的宽度和高度</li>
</ul>
<h3 id="滚动偏移属性-1"><a href="#滚动偏移属性-1" class="headerlink" title="滚动偏移属性"></a>滚动偏移属性</h3><p><img src="https://pic.imgdb.cn/item/61b068082ab3f51d912c1126.png"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM 事件详解</title>
    <url>/2021/09/7866e4eba81b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="注册事件的其他方法1"><a href="#注册事件的其他方法1" class="headerlink" title="注册事件的其他方法1"></a>注册事件的其他方法1</h3><ul>
<li><p><code>element.addEventListener()</code> 方法</p>
</li>
<li><p>参数：</p>
<ul>
<li>第一个参数：事件类型的字符串（直接书写<code>&quot;click&quot;</code> ，不需要加 <code>on</code>）</li>
<li>第二个参数：事件函数</li>
</ul>
</li>
<li><p>同一个元素可以多次绑定事件监听，同一个事件类型可以注册多个事件函数</p>
</li>
<li><p>兼容性问题：不支持 <code>IE9</code> 以下的浏览器</p>
</li>
</ul>
<h3 id="注册事件的其他方法2"><a href="#注册事件的其他方法2" class="headerlink" title="注册事件的其他方法2"></a>注册事件的其他方法2</h3><ul>
<li><code>element.attachEvent()</code> 方法。</li>
<li>参数：<ul>
<li>第一个参数：事件类型的字符串（需要加 <code>on</code>）</li>
<li>第二个参数：事件函数</li>
</ul>
</li>
<li>同一个元素可以多次绑定事件监听，同一个事件类型可以注册多个事件函数</li>
<li>兼容性问题：只支持 <code>IE10</code> 及以下的浏览</li>
</ul>
<h3 id="注册事件的兼容写法"><a href="#注册事件的兼容写法" class="headerlink" title="注册事件的兼容写法"></a>注册事件的兼容写法</h3><ul>
<li>自定义一个注册事件函数</li>
<li>参数：事件源，事件类型（不加 <code>on</code>），事件函数</li>
<li><code>IE9</code> 及以上的浏览器，使用 <code>addEventListener</code> 方法</li>
<li><code>IE9</code> 以下的浏览器，使用 <code>attachEvent</code> 方法</li>
<li>判断浏览器时，不需要判断它的版本，可以检测浏览器能力</li>
<li>浏览器能力检测：将某个方法的调用作为 <code>if</code> 语句的判断条件，如果浏览器认识该方法返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
<h3 id="移除事件的其他方法1"><a href="#移除事件的其他方法1" class="headerlink" title="移除事件的其他方法1"></a>移除事件的其他方法1</h3><ul>
<li><code>element.removeEventListener()</code> 方法。</li>
<li>参数：<ul>
<li>第一个参数：事件类型的字符串（直接书写<code>&quot;click&quot;</code>，不需要加 <code>on</code>）</li>
<li>第二个参数：事件函数引用名</li>
</ul>
</li>
<li>注意：没有办法移除一个匿名函数，所以在注册事件时需要单独声明一个有函数名的事件函数。 </li>
<li>兼容性问题：不支持 <code>IE9</code> 以下的浏览</li>
</ul>
<h3 id="移除事件的其他方法2"><a href="#移除事件的其他方法2" class="headerlink" title="移除事件的其他方法2"></a>移除事件的其他方法2</h3><ul>
<li><code>element.detachEvent()</code> 方法</li>
<li>参数：<ul>
<li>第一个参数：事件类型的字符串（需要加 <code>on</code>）</li>
<li>第二个参数：事件函数</li>
</ul>
</li>
<li>注意：没有办法移除一个匿名函数，所以在注册事件时需要单独声明一个有函数名的事件函数。 </li>
<li>兼容性问题：只支持 <code>IE10</code></li>
</ul>
<h3 id="移除事件的兼容写法"><a href="#移除事件的兼容写法" class="headerlink" title="移除事件的兼容写法"></a>移除事件的兼容写法</h3><ul>
<li>自定义一个移除事件函数</li>
<li>参数：事件源，事件类型（不加 <code>on</code>），事件函数</li>
<li><code>IE9</code> 及以上的浏览器，使用 <code>removeEventListener</code> 方法</li>
<li><code>IE9</code> 以下的浏览器，使用 <code>detachEvent</code> 方法</li>
<li>建议：将自己封装的一些常用函数和方法，放到一个单独的 <code>.js</code> 文件中。</li>
</ul>
<h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a><code>DOM</code> 事件流</h3><p><img src="https://pic.imgdb.cn/item/61b064942ab3f51d912a77b1.png"></p>
<h3 id="事件流的三个阶段"><a href="#事件流的三个阶段" class="headerlink" title="事件流的三个阶段"></a>事件流的三个阶段</h3><ul>
<li>第一个阶段：事件捕获</li>
<li>第二个阶段：事件执行过程</li>
<li>第三个阶段：事件冒泡</li>
<li><code>addEventListener()</code> 第三个参数为 <code>false</code> 时，事件冒泡</li>
<li><code>addEventListener()</code> 第三个参数为 <code>true</code> 时，事件捕获</li>
<li><code>onclick</code> 类型：只能进行事件冒泡过程，没有捕获阶段</li>
<li><code>attachEvent()</code> 方法：只能进行事件冒泡过程，没有捕获阶段</li>
</ul>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><ul>
<li>利用事件冒泡，将子级的事件委托给父级加载</li>
<li>同时，需要利用事件函数的一个 <code>e</code> 参数，内部存储的是事件对象</li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ul>
<li>只要触发事件，就会有一个对象，内部存储了与事件相关的数据。</li>
<li><code>e</code> 在低版本浏览器中有兼容问题，低版本浏览器使用的是 <code>window.even</code></li>
<li>事件对象常用的属性：<ul>
<li><code>e.eventPhase</code> 查看事件触发时所处的阶段</li>
<li><code>e.target</code> 用于获取触发事件的元素</li>
<li><code>e.srcElement</code> 用于获取触发事件的元素，低版本浏览器使用</li>
<li><code>e.currentTarget</code> 用于获取绑定事件的事件源元素</li>
<li><code>e.type</code> 获取事件类型</li>
<li><code>e.clientX</code>/<code>e.clientY</code> 所有浏览器都支持，鼠标距离浏览器窗口左上角的距离 </li>
<li><code>e.pageX</code>/<code>e.pageY</code> <code>IE8</code> 以前不支持，鼠标距离整个<code>HTML</code>页面左上顶点的距离</li>
</ul>
</li>
</ul>
<h3 id="取消默认行为和阻止事件传播的方式"><a href="#取消默认行为和阻止事件传播的方式" class="headerlink" title="取消默认行为和阻止事件传播的方式"></a>取消默认行为和阻止事件传播的方式</h3><ul>
<li><code>e.preventDefault()</code> 取消默认行为</li>
<li><code>e.returnValue</code> 取消默认行为，低版本浏览器使用</li>
<li><code>e.stopPropagation()</code> 阻止冒泡，标准方式</li>
<li><code>e.cancelBubble = true</code> 阻止冒泡，<code>IE</code> 低版本，标准中已废弃</li>
</ul>
<h3 id="其他事件类型"><a href="#其他事件类型" class="headerlink" title="其他事件类型"></a>其他事件类型</h3><p> <a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">MDN web 事件参考</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM 节点操作</title>
    <url>/2021/09/f21bba7488f4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a><code>DOM</code> 树</h3><p><img src="https://pic.imgdb.cn/item/61b029542ab3f51d910d66fa.png"></p>
<h3 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h3><ul>
<li><code>nodeType</code> 节点的类型，属性值为数字，表示不同的节点类型，共 12 种，只读<ul>
<li>元素节点</li>
<li>属性节点</li>
<li>文本节点</li>
</ul>
</li>
<li><code>nodeName</code> 节点的名称(标签名称)，只读</li>
<li><code>nodeValue</code> 节点值，返回或设置当前节点的值<ul>
<li>元素节点的 <code>nodeValue</code> 始终是 <code>null</code></li>
</ul>
</li>
</ul>
<h3 id="父子节点常用属性"><a href="#父子节点常用属性" class="headerlink" title="父子节点常用属性"></a>父子节点常用属性</h3><ul>
<li><code>childNodes</code> 只读属性，获取一个节点所有子节点的实时的集合，集合是动态变化的。</li>
<li><code>children</code> 只读属性，返回一个节点所有的子元素节点集合，是一个动态更新的 <code>HTML</code> 元素集合。</li>
<li><code>firstChild</code> 只读属性，返回该节点的第一个子节点，如果该节点没有子节点则返回 <code>null</code></li>
<li><code>lastChild</code> 只读属性，返回该节点的最后一个子节点，如果该节点没有子节点则返回 <code>null</code>。</li>
<li><code>parentNode</code> 返回一个当前节点的父节点，如果没有这样的节点，比如说像这个节点是树结构 的顶端或者没有插入一棵树中，这个属性返回 <code>null</code></li>
<li><code>parentElement</code> 返回当前节点的父元素节点，如果该元素没有父节点，或者父节点不是一个 <code>DOM</code> 元素，则返回 <code>null</code></li>
</ul>
<h3 id="兄弟节点常用属性"><a href="#兄弟节点常用属性" class="headerlink" title="兄弟节点常用属性"></a>兄弟节点常用属性</h3><ul>
<li><code>nextSibling</code> 只读属性，返回与该节点同级的下一个节点，如果没有返回<code>null</code>。 </li>
<li><code>previousSibling</code> 只读属性，返回与该节点同级的上一个节点，如果没有返回<code>null</code>。</li>
<li><code>nextElementSibling</code> 只读属性，返回与该节点同级的下一个元素节点，如果没有返回<code>null</code>。</li>
<li><code>previousElementSibling</code> 只读属性，返回与该节点同级的上一个元素节点，如果没有返回<code>null</code>。</li>
<li>注意：<code>nextElementSibling</code> 和 <code>previousElementSibling</code> 有兼容性问题，<code>IE9</code>以后才支持。</li>
</ul>
<h3 id="创建新节点的方法"><a href="#创建新节点的方法" class="headerlink" title="创建新节点的方法"></a>创建新节点的方法</h3><ul>
<li><code>document.createElement(&quot;div&quot;)</code> 创建元素节点</li>
<li><code>document.createAttribute(&quot;id&quot;)</code> 创建属性节点</li>
<li><code>document.createTextNode(&quot;hello&quot;)</code> 创建文本节点</li>
<li>一般将创建的新节点存在变量中，方便使用。</li>
</ul>
<h3 id="节点常用操作方法-1"><a href="#节点常用操作方法-1" class="headerlink" title="节点常用操作方法 1"></a>节点常用操作方法 1</h3><ul>
<li><code>parentNode.appendChild(child)</code>将一个节点添加到指定父节点的子节点列表末尾。</li>
<li><code>parentNode.replaceChild(newChild, oldChild)：</code>用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。</li>
<li><code>parentNode.insertBefore(newNode, referenceNode)：</code>在参考节点之前插入一个拥有指定父节点的子节点，<code>referenceNode</code> 必须设置，如果 <code>referenceElement</code> 为 <code>null</code> 则 <code>newNode</code> 将被插入到子节点的末尾。</li>
<li><code>parentNode.removeChild(child)：</code>移除当前节点的一个子节点。这个子节点必须存在于当前节点中。</li>
</ul>
<h3 id="节点常用操作方法-2"><a href="#节点常用操作方法-2" class="headerlink" title="节点常用操作方法 2"></a>节点常用操作方法 2</h3><ul>
<li><code>Node.cloneNode()</code>克隆一个节点，并且可以选择是否克隆这个节点下的所有内容。参数为 <code>Boolean</code> 布尔值，表示是否采用深度克隆,如果为 <code>true</code>,则该节点的所有后代节点也都会被克隆,如果为 <code>false</code>,则只克隆该节点本身，默认值为 <code>true</code>，节点下的内容会被克隆。</li>
<li>注意：克隆时，标签上的属性和属性值也会被复制，写在标签行内的绑定事件可以被复制，但是通过 <code>JavaScript</code> 动态绑定的事件不会被复制</li>
</ul>
<h3 id="节点常用操作方法-3"><a href="#节点常用操作方法-3" class="headerlink" title="节点常用操作方法 3"></a>节点常用操作方法 3</h3><ul>
<li><code>Node.hasChildNodes()</code>没有参数，返回一个 <code>Boolean</code> 布尔值，来表示该元素是否包含有子节点。</li>
<li><code>Node.contains(child)</code>返回一个 <code>Boolean</code> 布尔值，来表示传入的节点是否为该节点的后代节点。</li>
</ul>
<h3 id="判断方法总结"><a href="#判断方法总结" class="headerlink" title="判断方法总结"></a>判断方法总结</h3><ul>
<li><p>有三种方法可以判断当前节点是否有子节点。</p>
<ul>
<li><p><code>node.firstChild !== null</code></p>
</li>
<li><p><code>node.childNodes.length &gt; 0</code></p>
</li>
<li><p><code>node.hasChildNodes()</code></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM 元素属性操作</title>
    <url>/2021/09/013fb0154133/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="非表单元素的属性"><a href="#非表单元素的属性" class="headerlink" title="非表单元素的属性"></a>非表单元素的属性</h3><ul>
<li>例如：<code>href</code>、<code>title</code>、<code>id</code>、<code>src</code> 等。</li>
<li>调用方式：元素对象打点调用属性名，例如 <code>obj.href</code>。</li>
<li>注意：部分的属性名跟关键字和保留字冲突，会更换写法。<ul>
<li><code>class</code> → <code>className</code></li>
<li><code>for</code> → <code>htmlFor</code></li>
<li><code>rowspan</code> → <code>rowSpan</code></li>
</ul>
</li>
<li>属性赋值：给元素属性赋值,等号右侧的赋值都是字符串格式。</li>
</ul>
<h3 id="获取标签内部内容的属性"><a href="#获取标签内部内容的属性" class="headerlink" title="获取标签内部内容的属性"></a>获取标签内部内容的属性</h3><ul>
<li>获取标签内部内容的属性有两个：<code>innerHTML</code> 和 <code>innerText</code></li>
<li><code>innerHTML</code>属性，在获取标签内部内容时，如果包含标签，获取的内容会包含标签，获取的内容包括空白换行等。</li>
<li><code>innerText</code>属性，在获取标签内部内容时，如果包含标签，获取的内容会过滤标签，获取的内容会去掉换行和缩进等空白。</li>
</ul>
<h3 id="更改标签内容"><a href="#更改标签内容" class="headerlink" title="更改标签内容"></a>更改标签内容</h3><ul>
<li>还可以通过两个属性给双标签内部去更改内容：<ul>
<li><code>innerHTML</code> 设置属性值，有标签的字符串，会按照 <code>HTML</code> 语法中的标签加载。</li>
<li><code>innerText</code> 设置属性值，有标签的字符串，会按照普通的字符加载。</li>
</ul>
</li>
<li>对比使用场景<ul>
<li><code>innerText</code>：在设置纯字符串时使用。</li>
<li><code>innerHTML</code>：在设置有内部子标签结构时使用。</li>
</ul>
</li>
</ul>
<h3 id="表单元素属性"><a href="#表单元素属性" class="headerlink" title="表单元素属性"></a>表单元素属性</h3><ul>
<li><code>value</code> 用于大部分表单元素的内容获取(<code>option</code>除外)</li>
<li><code>type</code> 可以获取<code>input</code>标签的类型(输入框或复选框等)</li>
<li><code>disabled</code> 禁用属性</li>
<li><code>checked</code> 复选框选中属性</li>
<li><code>selected</code> 下拉菜单选中属性</li>
<li>注意：在 <code>DOM</code> 中元素对象的属性值只有一个时，会被转成布尔值显示。<ul>
<li>例如：<code>txt.disabled = true</code></li>
</ul>
</li>
</ul>
<h3 id="自定义属性操作"><a href="#自定义属性操作" class="headerlink" title="自定义属性操作"></a>自定义属性操作</h3><ul>
<li><code>getAttribute(name)</code> 获取标签行内属性</li>
<li><code>setAttribute(name，value)</code> 设置标签行内属性</li>
<li><code>removeAttribute(name)</code> 移除标签行内属性</li>
<li>与<code>element.属性</code>的区别: 上述三个方法用于获取任意的行内属性，包括自定义的属性。</li>
</ul>
<h3 id="style-样式属性操作"><a href="#style-样式属性操作" class="headerlink" title="style 样式属性操作"></a><code>style</code> 样式属性操作</h3><ul>
<li>使用 <code>style</code> 属性方式设置的样式显示在标签行内。</li>
<li><code>element.style</code> 属性的值，是所有行内样式组成的一个样式对象。</li>
<li>样式对象可以继续点语法调用或更改 <code>css</code> 的行内样式属性，例如 <code>width</code>、<code>height</code> 等属性。</li>
<li>注意1：类似 <code>background-color</code> 这种复合属性的单一属性写法，是由多个单词组成的，要修改为驼峰命名方式书写 <code>backgroundColor</code>。</li>
<li>注意2：通过样式属性设置宽高、位置的属性类型是字符串，需要加上 <code>px</code> 等单位。</li>
</ul>
<h3 id="className-类名属性操作"><a href="#className-类名属性操作" class="headerlink" title="className 类名属性操作"></a><code>className</code> 类名属性操作</h3><ul>
<li>修改元素的 <code>className</code> 属性相当于直接修改标签的类名。</li>
<li>如果需要修改多条 <code>css</code> 样式，可以提前将修改后的样式设置到一个类选择器中，后续通过修改类名的方式，批量修改 <code>css</code> 样式。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM 事件基本应用</title>
    <url>/2021/09/681e4ff6d9ba/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul>
<li>事件：在什么时候做什么事</li>
<li>执行机制：触发–响应机制</li>
<li>绑定事件(注册事件)三要素：<ul>
<li>事件源：给谁绑定事件</li>
<li>事件类型：绑定什么类型的事件 <code>click</code> 单击</li>
<li>事件函数：事件发生后执行什么内容，写在函数内部</li>
</ul>
</li>
</ul>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><ul>
<li><code>JavaScript</code> 解析器会给有绑定事件的元素添加一个监听，解析器会一直监测这个元素，只要触发对应的绑定事件，会立刻执行事件函数。</li>
</ul>
<h3 id="常用事件监听方法"><a href="#常用事件监听方法" class="headerlink" title="常用事件监听方法"></a>常用事件监听方法</h3><ul>
<li>方法1：绑定 <code>HTML</code> 元素属性。</li>
<li>方法2：绑定 <code>DOM</code> 对象属性</li>
</ul>
<h3 id="常用的鼠标事件类型"><a href="#常用的鼠标事件类型" class="headerlink" title="常用的鼠标事件类型"></a>常用的鼠标事件类型</h3><ul>
<li><code>onclick</code> 鼠标左键单击触发</li>
<li><code>ondbclick</code> 鼠标左键双击触发</li>
<li><code>onmousedown</code> 鼠标按键按下触发</li>
<li><code>onmouseup</code> 鼠标按键放开时触发</li>
<li><code>onmousemove</code> 鼠标在元素上移动触发</li>
<li><code>onmouseover</code> 鼠标移动到元素上触发</li>
<li><code>onmouseout</code> 鼠标移出元素边界触发</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM 获取页面元素</title>
    <url>/2021/08/47801cb926fc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="根据-id-获取元素"><a href="#根据-id-获取元素" class="headerlink" title="根据 id 获取元素"></a>根据 <code>id</code> 获取元素</h3><ul>
<li>方法：调用 <code>document</code> 对象的 <code>getElementById</code> 方法。</li>
<li>参数：字符串类型的 <code>id</code> 的属性值。</li>
<li>返回值：对应 <code>id</code> 名的元素对象。</li>
<li>注意1：由于 <code>id</code> 名具有唯一性，部分浏览器支持直接使用 <code>id</code> 名访问元素，但不是标准方式，不推荐使用。</li>
<li>注意2：代码执行顺序，如果 <code>js</code> 在 <code>html</code> 结构之前，会导致结构未加载，不能获取对应<code>id</code>的元素。</li>
</ul>
<h3 id="根据标签名获取元素"><a href="#根据标签名获取元素" class="headerlink" title="根据标签名获取元素"></a>根据标签名获取元素</h3><ul>
<li>方法：调用 <code>document</code> 对象的 <code>getElementsByTagName</code> 方法。</li>
<li>参数：字符串类型的标签名。</li>
<li>返回值：同名的元素对象组成的数组。</li>
<li>注意1：操作数据时需要按照操作数组的方法进行。</li>
<li>注意2：<code>getElementsByTagName</code> 方法内部获取的元素是动态增加的。</li>
</ul>
<h3 id="元素对象内部获取标签元素"><a href="#元素对象内部获取标签元素" class="headerlink" title="元素对象内部获取标签元素"></a>元素对象内部获取标签元素</h3><ul>
<li>获取的元素对象内部，本身也可以调用根据标签获取元素方法，例如 <code>div</code> 元素对象也可以调用 <code>getElementsByTagName</code> 方法。</li>
<li>目的：缩小选择元素的范围，类似 <code>css</code> 中的后代选择器。</li>
</ul>
<h3 id="根据-name-获取元素"><a href="#根据-name-获取元素" class="headerlink" title="根据 name 获取元素"></a>根据 <code>name</code> 获取元素</h3><ul>
<li>方法：调用 <code>document</code> 对象的 <code>getElementsByName</code> 方法。</li>
<li>参数：字符串类型的 <code>name</code> 属性值。</li>
<li>返回值：<code>name</code> 属性值相同的元素对象组成的数组。</li>
<li>不建议使用：在 <code>IE</code> 和 <code>Opera</code> 中有兼容问题，会多选中 <code>id</code> 属性值相同的元素。</li>
</ul>
<h3 id="根据类名获取元素"><a href="#根据类名获取元素" class="headerlink" title="根据类名获取元素"></a>根据类名获取元素</h3><ul>
<li>方法：调用 <code>document</code> 对象的 <code>getElementsByClassName</code> 方法。</li>
<li>参数：字符串类型的 <code>class</code> 属性值。</li>
<li>返回值：<code>class</code> 属性值相同的元素对象组成的数组。</li>
<li>浏览器兼容问题：不支持 <code>IE8</code></li>
</ul>
<h3 id="根据选择器获取元素"><a href="#根据选择器获取元素" class="headerlink" title="根据选择器获取元素"></a>根据选择器获取元素</h3><ul>
<li>方法1：调用 <code>document</code> 对象的 <code>querySelector</code> 方法，通过 <code>css</code> 中的选择器去选取第一个符合条件的标签元素。</li>
<li>方法2：调用 <code>document</code> 对象的 <code>querySelectorAll</code> 方法，通过 <code>css</code> 中的选择器去选取所有符合条件的标签元素。</li>
<li>参数：字符串类型的 <code>css</code> 中的选择器。</li>
<li>浏览器兼容问题：不支持 <code>IE8</code> 以下的浏览器</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>DOM 简介</title>
    <url>/2021/08/60f642112ad4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="DOM-的概念"><a href="#DOM-的概念" class="headerlink" title="DOM 的概念"></a><code>DOM</code> 的概念</h3><ul>
<li>文档对象模型（<code>Document Object Model</code>，简称 <code>DOM</code>），是 <code>W3C</code> 组织推荐的处理可扩展标记语言的标准编程接口。它是一种与平台和语言无关的应用程序接口(<code>API</code>),它可以动态地访问程序和脚本，更新其内容、结构和 <code>www</code> 文档的风格(目前，<code>HTML</code> 和 <code>XML</code> 文档是通过说明部分定义的)。文档可以进一步被处理，处理的结果可以加入到当前的页面。<code>DOM</code> 是一种基于树的 <code>API</code> 文档，它要求在处理过程中整个文档都表示在存储器中。</li>
</ul>
<h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a><code>DOM</code> 树</h3><ul>
<li><code>DOM</code> 又称为文档树模型<ul>
<li>文档：一个网页可以称为文档</li>
<li>节点：网页中的所有内容都是节点 （标签、属性、文本、注释等）</li>
<li>元素：网页中的标签</li>
<li>属性：标签的属性</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/61b029542ab3f51d910d66fa.png"></p>
<h3 id="DOM-经常进行的操作"><a href="#DOM-经常进行的操作" class="headerlink" title="DOM 经常进行的操作"></a><code>DOM</code> 经常进行的操作</h3><ul>
<li>获取元素</li>
<li>对元素进行操作(设置其属性或调用其方法)</li>
<li>动态创建元素</li>
<li>事件(什么时机做相应的操作)</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Web API</title>
    <url>/2021/08/038998309473/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="API的概念"><a href="#API的概念" class="headerlink" title="API的概念"></a><code>API</code>的概念</h3><ul>
<li><code>API</code>（<code>Application Programming Interface</code>,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。</li>
<li>任何开发语言都有自己的 <code>API</code></li>
<li><code>API</code> 的特征输入和输出(<code>I/O</code>) 例如：<code>var max = Math.max(2,3,4);</code></li>
<li><code>API</code> 的使用方法<code>console.log(&quot;abc&quot;)</code></li>
</ul>
<h3 id="Web-API-的概念"><a href="#Web-API-的概念" class="headerlink" title="Web API 的概念"></a><code>Web API</code> 的概念</h3><ul>
<li>浏览器提供了一套操作浏览器功能和页面元素的 <code>API</code>(<code>BOM</code> 和 <code>DOM</code>)。</li>
<li>此处的 <code>Web API</code> 特指浏览器提供的 <code>API</code>(一组方法)，<code>Web API</code> 在后面的课程中有其它含义。</li>
<li>学习目标：掌握常见浏览器提供的 <code>API</code> 的调用方式。</li>
<li>学习辅助 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API">MDN</a></li>
</ul>
<h3 id="JavaScript-的组成"><a href="#JavaScript-的组成" class="headerlink" title="JavaScript 的组成"></a><code>JavaScript</code> 的组成</h3><p><img src="https://pic.imgdb.cn/item/61b0161b2ab3f51d91fe1a03.png"></p>
<h4 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a><code>ECMAScript</code></h4><ul>
<li><code>JavaScript</code> 的核心</li>
<li>定义了 <code>JavaScript</code> 的语法规范</li>
<li><code>JavaScript</code> 的核心，描述了语言的基本语法和数据类型，<code>ECMAScript</code> 是一套标准，定义了一种语言的标准与具体实现无关。</li>
</ul>
<h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a><code>BOM</code></h4><ul>
<li>浏览器对象模型</li>
<li><code>browser object model</code>，一套操作浏览器功能的 <code>API</code>。</li>
<li>通过 <code>BOM</code> 可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 。</li>
</ul>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a><code>DOM</code></h4><ul>
<li>文档对象模型</li>
<li><code>document object model</code>，一套操作页面元素的 <code>API</code>。</li>
<li><code>DOM</code> 可以把 <code>HTML</code> 看做是文档树，通过 <code>DOM</code> 提供的 <code>API</code> 可以对树上的节点进行操作</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>内置对象</title>
    <url>/2021/08/be3a3fabfcc7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a><code>MDN</code></h3><ul>
<li><code>Mozilla</code>开发者网络（ <code>MDN</code> ）提供有关开放网络技术 （<code>Open Web</code>）的信息，包括 <code>HTML</code> 、<code>CSS</code>和万维网及 <code>HTML5</code> 应用的 <code>API</code> 。<ul>
<li><a href="https://developer.mozilla.org/zh-CN/">MDN</a> </li>
<li>比如：通过查询 <code>MDN</code> 学习 <code>Math</code> 对象的 <code>random()</code> 方法的使用</li>
</ul>
</li>
</ul>
<h3 id="如何学习一个方法？"><a href="#如何学习一个方法？" class="headerlink" title="如何学习一个方法？"></a>如何学习一个方法？</h3><ul>
<li>方法的功能 </li>
<li>参数的意义和类型 </li>
<li>返回值意义和类型 </li>
<li><code>demo</code> 进行测试</li>
</ul>
<h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a><code>Math</code>对象</h3><ul>
<li><p><code>Math</code> 对象它具有数学常数和函数的属性和方法，我们可以直接进行使用</p>
</li>
<li><p>根据数学相关的运算来找 <code>Math</code> 中的成员（求绝对值，取整）</p>
</li>
<li><p><code>Math.PI</code> 圆周率</p>
</li>
<li><p><code>Math.random()</code> 生成随机数</p>
</li>
<li><p><code>Math.floor()</code>/<code>Math.ceil()</code> 向下取整/向上取整</p>
</li>
<li><p><code>Math.round()</code> 取整，四舍五入</p>
</li>
<li><p><code>Math.abs()</code> 绝对值</p>
</li>
<li><p><code>Math.max()</code>/<code>Math.min()</code> 求最大和最小值</p>
</li>
<li><p><code>Math.sin()</code>/<code>Math.cos()</code> 正弦/余弦</p>
</li>
<li><p><code>Math.power()</code>/<code>Math.sqrt()</code> 求指数次幂/求平方根</p>
</li>
</ul>
<h3 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a><code>Array</code>对象</h3><h4 id="创建数组对象的两种方式"><a href="#创建数组对象的两种方式" class="headerlink" title="创建数组对象的两种方式"></a>创建数组对象的两种方式</h4><ul>
<li>字面量方式</li>
<li><code>new Array()</code> 构造函数方法</li>
</ul>
<h4 id="检测数组类型"><a href="#检测数组类型" class="headerlink" title="检测数组类型"></a>检测数组类型</h4><ul>
<li><code>instanceof</code> 检测某个实例是否是某个对象类型</li>
</ul>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a><code>toString</code></h4><ul>
<li><code>toString()</code> 把数组转换成字符串，逗号分隔每一项</li>
</ul>
<h4 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h4><ul>
<li><p>首尾数据操作</p>
<ul>
<li><code>push()</code> 在数组末尾添加一个或多个元素，并返回数组操作后的长度</li>
<li><code>pop()</code> 删除数组最后一项，返回删除项</li>
<li><code>shift()</code> 删除数组第一项，返回删除项</li>
<li><code>unshift()</code> 在数组开头添加一个或多个元素，并返回数组的新长度</li>
</ul>
</li>
<li><p>合并和拆分</p>
<ul>
<li><code>concat()</code> <ul>
<li>将两个数组合并成一个新的数组，原数组不受影响。参数位置可以是一个数组字面量、数 组变量、零散的值。</li>
</ul>
</li>
<li><code>slice(start,end)</code><ul>
<li>从当前数组中截取一个新的数组，不影响原来的数组，返回一个新的数组，包含从 <code>start</code> 到 <code>end</code> （不包括该元素）的元素。</li>
<li>参数区分正负，正值表示下标位置，负值表示从后面往前数第几个位置，参数可以只传递一个，表示从开始位置截取到字符串结尾。</li>
</ul>
</li>
</ul>
</li>
<li><p>删除、插入、替换</p>
<ul>
<li><code>splice(index,howmany,element1,element2,……)</code> 用于插入、删除或替换数组的元素<ul>
<li><code>index</code>：删除元素的开始位置</li>
<li><code>howmany</code>：删除元素的个数，可以是0 </li>
<li><code>element1</code>,<code>element2</code>：要替换的新的数据</li>
</ul>
</li>
</ul>
</li>
<li><p>位置方法</p>
<ul>
<li><code>indexOf()</code> 查找数据在数组中最先出现的下标</li>
<li><code>lastIndexOf()</code> 查找数据在数组中最后一次出现的下标</li>
<li>注意：如果没找到返回-1</li>
</ul>
</li>
<li><p>倒序</p>
<ul>
<li><code>reverse()</code> 将数组完全颠倒，第一项变成最后一项，最后一项变成第一项。</li>
</ul>
</li>
<li><p>排序</p>
<ul>
<li><code>sort()</code> 默认根据字符编码顺序，从小到大排序<ul>
<li>如果想要根据数值大小进行排序，必须添加<code>sort</code>的比较函数参数。</li>
<li>该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具 有两个参数 <code>a</code> 和 <code>b</code>，根据<code>a</code>和<code>b</code>的关系作为判断条件，返回值根据条件分为三个分支，<code>正数</code>、 <code>负数</code>、<code>0</code><ul>
<li>返回值是<code>负数-1</code>：<code>a</code>排在<code>b</code>前面。</li>
<li>返回值是<code>正数1</code>：<code>a</code>排在<code>b</code>后面。</li>
<li>返回值是<code>0</code>：<code>a</code>和<code>b</code>的顺序保持不变。</li>
</ul>
</li>
<li>人为能控制的是判断条件。</li>
</ul>
</li>
</ul>
</li>
<li><p>转字符串方法</p>
<ul>
<li><code>join()</code> 通过参数作为连字符将数组中的每一项用连字符连成一个完整的字符串</li>
</ul>
</li>
</ul>
<h4 id="清空数组"><a href="#清空数组" class="headerlink" title="清空数组"></a>清空数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1 推荐</span></span><br><span class="line">arr = [];</span><br><span class="line"><span class="comment">// 方式2 </span></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>, arr.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>

<h3 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a><code>String</code>对象</h3><h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><ul>
<li>为了方便操作简单数据类型，<code>JavaScript</code> 还提供了特殊的简单类型对象：<code>String</code></li>
<li>基本类型是没有方法的。</li>
<li>当调用 <code>str.substring()</code> 等方法的时候，先把 <code>str</code> 包装成 <code>String</code> 类型的临时对象，再调用<code>substring</code>  方法，最后销毁临时对象。</li>
<li>可以使用 <code>new String()</code> 构造函数方法创建字符串对象。</li>
</ul>
<h4 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h4><ul>
<li>字符串是不可变的。</li>
<li>由于字符串的不可变，在大量拼接字符串的时候会有效率问题。</li>
</ul>
<h4 id="字符串对象的常用方法"><a href="#字符串对象的常用方法" class="headerlink" title="字符串对象的常用方法"></a>字符串对象的常用方法</h4><ul>
<li>字符串所有的方法，都不会修改字符串本身（字符串是不可变的），操作完成会返回一个新的字符串。</li>
</ul>
<h4 id="字符串属性"><a href="#字符串属性" class="headerlink" title="字符串属性"></a>字符串属性</h4><ul>
<li>长度属性：<code>str.length</code></li>
<li>字符串长度指的是一个字符串中所有的字符总数。</li>
</ul>
<h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><ul>
<li><code>charAt()</code> 方法可返回指定位置的字符。<ul>
<li><code>char</code>：<code>charator</code>，字符</li>
<li><code>at</code>：在哪儿</li>
<li>参数是 <code>index</code> 字符串的下标。也是从 0 开始。</li>
<li>表示返回指定的下标位置的字符。</li>
</ul>
</li>
<li><code>indexOf()</code> 方法可返回某个指定的字符串值在字符串中首次出现的位置。<ul>
<li>找到指定的子字符串在原字符串中第一次出现的位置的下标。如果子字符串在原字符串中没有，返回值是 <code>-1</code></li>
</ul>
</li>
<li><code>concat()</code> 方法用于连接两个或多个字符串。<ul>
<li>参数比较灵活，可以是字符串、或者字符串变量、多个字符串。</li>
<li>生成的是一个新的字符串，原字符串不发生变化。</li>
</ul>
</li>
<li><code>split()</code> 方法用于把一个字符串分割成字符串数组。<ul>
<li>参数部分是分割符，利用分割符将字符串分割成多个部分，多个部分作为数组的每一项组成数组。</li>
<li>如果分割符是空字符串，相当于将每个字符拆分成数组中的每一项。</li>
</ul>
</li>
<li><code>toLowerCase()</code> 把字符串转换为小写。 <code>toUpperCase()</code> 把字符串转换为大写。<ul>
<li>将所有的英文字符转为大写或者小写。</li>
<li>生成的是新的字符串，原字符串不发生变化。</li>
</ul>
</li>
<li><code>slice()</code> 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。<ul>
<li>语法：<code>slice(start，end)</code></li>
<li>从开始位置截取到结束位置（不包括结束位置）的字符串。</li>
<li>参数区分正负，正值表示下标位置，负值表示从后面往前数第几个位置，参数可以只传递一个，表示从开始位置截取到字符串结尾。</li>
</ul>
</li>
<li><code>substr()</code> 方法可在字符串中抽取从 <code>start</code> 下标开始的指定数目的字符<ul>
<li>语法：<code>substr(start,howmany)</code></li>
<li>从开始位置截取到指定长度的字符串。</li>
<li><code>start</code> 参数区分正负。正值表示下标位置，负值表示从后往前数第几个位置。</li>
<li><code>howmany</code> 参数必须为正数，也可以不写，不写表示从 <code>start</code> 截取到最后。</li>
</ul>
</li>
<li><code>substring()</code> 方法用于提取字符串中介于两个指定下标之间的字符。<ul>
<li>语法：<code>substring(start,end)</code></li>
<li>参数只能为正数。</li>
<li>两个参数都是指代下标，两个数字大小不限制，执行方法之前会比较一下两个参数的大小，会用小当做开始位置，大的当做结束位置，从开始位置截取到结束位置但是不包含结束位置。</li>
<li>如果不写第二个参数，从开始截取到字符串结尾。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>简单类型和复杂类型</title>
    <url>/2021/08/cf5cca4359c0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="简单类型和复杂类型的区别"><a href="#简单类型和复杂类型的区别" class="headerlink" title="简单类型和复杂类型的区别"></a>简单类型和复杂类型的区别</h3><ul>
<li>基本类型又叫做值类型，复杂类型又叫做引用类型。</li>
<li>值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。</li>
<li>引用类型：复杂数据类型，在存储时，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。</li>
</ul>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><ul>
<li><p><code>JavaScript</code> 中没有堆和栈的概念，此处我们用堆和栈来讲解，目的是方便理解。</p>
</li>
<li><p>堆栈空间分配区别：</p>
<ul>
<li><p>栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。</p>
</li>
<li><p>堆（操作系统）：存储复杂类型 (对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p>
</li>
</ul>
</li>
</ul>
<h3 id="基本类型在内存中的存储"><a href="#基本类型在内存中的存储" class="headerlink" title="基本类型在内存中的存储"></a>基本类型在内存中的存储</h3><ul>
<li>变量中如果存储的是简单类型的数据，那么变量中存储的是值本身，如果将变量赋值给另一个变量，是将内部的值复制一份给了另一个变量，两个变量之间没有联系，一个变化，另一个不会同时变化。</li>
</ul>
<h3 id="复杂类型在内存中的存储"><a href="#复杂类型在内存中的存储" class="headerlink" title="复杂类型在内存中的存储"></a>复杂类型在内存中的存储</h3><ul>
<li>如果将复杂类型的数据赋值给一个变量，复杂类型的数据会在内存中创建一个原型，而变量中存储的是指向对象的一个地址，如果将变量赋值给另一个变量，相当于将地址复制一份给了新的变量，两个变量的地址相同，指向的是同一个原型，不论通过哪个地址更改了原型，都是在原型上发生的更改，两个变量下次访问时，都会发生变化。</li>
</ul>
<h3 id="基本类型作为函数的参数"><a href="#基本类型作为函数的参数" class="headerlink" title="基本类型作为函数的参数"></a>基本类型作为函数的参数</h3><ul>
<li>基本类型的数据作为函数的参数，符合基本类型的数据特点。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>对象</title>
    <url>/2021/08/f7a30b30f53e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="为什么要有对象？"><a href="#为什么要有对象？" class="headerlink" title="为什么要有对象？"></a>为什么要有对象？</h3><ul>
<li>如果有一组相关的数据，松散的存储不利于使用，存入数组中受下标限制又必须有固定的顺序，而对象可以自定义名称存储一系列无序的相关数据。</li>
</ul>
<h3 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h3><ul>
<li>现实生活中的对象：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。</li>
<li><code>JavaScript</code> 中的对象：<ul>
<li><code>JavaScript</code> 中的对象其实就是生活中对象的一个抽象。</li>
<li><code>JavaScript</code> 的对象是无序属性的集合。</li>
</ul>
</li>
<li>其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把 <code>JavaScript</code> 中的对象 想象成键值对，其中值可以是数据和函数。</li>
<li>对象的行为和特征：<ul>
<li>特征—在对象中用属性表示</li>
<li>行为—在对象中用方法表示</li>
</ul>
</li>
</ul>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><ul>
<li>创建一个对象最简单的方式是使用对象字面量赋值给变量。类似数组。</li>
<li>对象字面量语法：<code>&#123;&#125;</code></li>
<li>内部可以存放多条数据，数据与数据之间用逗号分隔，最后一个后面不要加逗号。</li>
<li>每条数据都是有属性名和属性值组成，键值对写法：<code>k: v</code></li>
<li><code>k</code>: 属性名</li>
<li><code>v</code>：属性值，可以是任意类型的数据，比如简单类型数据、函数、对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">k</span>: v,</span><br><span class="line">    <span class="attr">k</span>: v,</span><br><span class="line">    <span class="attr">k</span>: v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区分属性和方法"><a href="#区分属性和方法" class="headerlink" title="区分属性和方法"></a>区分属性和方法</h3><ul>
<li>属性：对象的描述性特征，一般是名词，相当于定义在对象内部的变量。</li>
<li>方法：对象的行为和功能，一般是动词，定义在对象中的函数。</li>
</ul>
<h3 id="调用对象内部属性和方法的语法"><a href="#调用对象内部属性和方法的语法" class="headerlink" title="调用对象内部属性和方法的语法"></a>调用对象内部属性和方法的语法</h3><ul>
<li>用对象的变量名打点调用某个属性名，得到属性值。</li>
<li>在对象内部用 <code>this</code> 打点调用属性名。<code>this</code> 替代对象。</li>
<li>用对象的变量名后面加 <code>[]</code> 调用，<code>[]</code> 内部是字符串格式的属性名。</li>
<li>调用方法时，需要在方法名后加 <code>()</code> 执行。</li>
</ul>
<h3 id="更改对象内部属性和方法的语法"><a href="#更改对象内部属性和方法的语法" class="headerlink" title="更改对象内部属性和方法的语法"></a>更改对象内部属性和方法的语法</h3><ul>
<li>更改属性的属性值方法：先调用属性，再等号赋值。</li>
<li>增加新的属性和属性值：使用点语法或者<code>[]</code>方法直接定义新属性，等号赋值。</li>
<li>删除一条属性：使用一个 <code>delete</code> 关键字，空格后面加属性调用。</li>
</ul>
<h3 id="new-Object-创建对象"><a href="#new-Object-创建对象" class="headerlink" title="new Object() 创建对象"></a><code>new Object()</code> 创建对象</h3><ul>
<li><code>Object()</code> 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与 <code>new</code> 运算符一起使用在创建对象的语句中。<ul>
<li>构造函数用于创建一类对象，首字母要大写。</li>
<li>构造函数要和 <code>new</code> 一起使用才有意义。</li>
</ul>
</li>
</ul>
<h3 id="new-在执行时会做四件事情"><a href="#new-在执行时会做四件事情" class="headerlink" title="new 在执行时会做四件事情"></a><code>new</code> 在执行时会做四件事情</h3><ul>
<li><code>new</code> 会在内存中创建一个新的空对象</li>
<li><code>new</code> 会让 <code>this</code> 指向这个新的对象</li>
<li>执行构造函数 目的：给这个新对象加属性和方法</li>
<li><code>new</code> 会返回这个新对象</li>
</ul>
<h3 id="工厂函数创建对象"><a href="#工厂函数创建对象" class="headerlink" title="工厂函数创建对象"></a>工厂函数创建对象</h3><ul>
<li>如果要创建多个类似的对象，可以将 <code>new Object()</code> 过程封装到一个函数中，将来调用函数就能创建一个对象，相当于一个生产对象的函数工厂，用来简化代码。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    person.<span class="property">name</span> = name;</span><br><span class="line">    person.<span class="property">age</span> = age;</span><br><span class="line">    person.<span class="property">job</span> = job;</span><br><span class="line">    person.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,everyBody&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="title function_">createPerson</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;actor&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h3><ul>
<li>比工厂方法更加简单。</li>
<li>自定义一个创建具体对象的构造函数，函数内部不需要 <code>new</code> 一个构造函数的过程，直接使用 <code>this</code> 代替对象进行属性和方法的书写，也不需要 <code>return</code> 一个返回值。</li>
<li>使用时，利用 <code>new</code> 关键字调用自定义的构造函数即可。</li>
<li>注意：构造函数的函数名首字母需要大写，区别于其他普通函数名。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello,everyBody&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;actor&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="对象遍历"><a href="#对象遍历" class="headerlink" title="对象遍历"></a>对象遍历</h3><ul>
<li><code>for in</code> 循环也是循环的一种，专门用来遍历对象，内部会定义一个 <code>k</code> 变量， <code>k</code> 变量在每次循环时会从第一个开始接收属性名，一直接收到最后一条属性名，执行完后跳出循环。</li>
<li>简单的循环遍历：输出每一项的属性名和属性值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环遍历输出每一项</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k + <span class="string">&quot;项的属性值是&quot;</span> + obj[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>函数</title>
    <url>/2021/08/e86b4b4e0a72/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h3><ul>
<li>函数（<code>function</code>），也叫作功能、方法，函数可以将一段代码一起封装起来，被封装起来的函数具备某一项特殊的功能，内部封装的一段代码作为一个完整的结构体，要执行就都执行，要不执行就都不执行。</li>
<li>函数的作用就是封装一段代码，将来可以重复使用。</li>
</ul>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><ul>
<li>函数声明又叫函数定义，函数必须先定义然后才能使用。</li>
<li>如果没有定义函数直接使用，会出现一个引用错误。</li>
<li>函数声明语法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数)&#123;</span><br><span class="line">	封装的结构体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特点：函数声明的时候，函数体并不会执行，只有当函数被调用的时候才会执行。</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ul>
<li>调用方法：<code>函数名();</code></li>
<li>函数调用也叫作函数执行，调用时会将函数内部封装的所有的结构体的代码立即执行。</li>
<li>函数内部语句执行的位置，与函数定义的位置无关，与函数调用位置有关。</li>
<li>函数可以一次定义，多次执行。</li>
</ul>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><ul>
<li><p>我们希望函数执行结果不是一成不变的，可以根据自定义的内容发生一些变化。</p>
</li>
<li><p>函数预留了一个接口，专门用于让用户自定义内容，使函数发生一些执行效果变化。</p>
</li>
<li><p>接口：就是函数的参数，函数参数的本质就是变量，可以接收任意类型的数据，导致函数执行结果根据参数不同，结果也不同。</p>
</li>
<li><p>一个函数可以设置 0 个或者多个参数，参数之间用逗号分隔。</p>
</li>
<li><p>函数的参数根据书写位置不同，名称也不同：</p>
<ul>
<li>形式参数：定义的 () 内部的参数，叫做形式参数，本质是变量，可以接收实际参数传递过来的数据。简称形参。</li>
<li>实际参数：调用的 () 内部的参数，叫做实际参数，本质就是传递的各种类型的数据，传递给每个形参，简称实参。</li>
</ul>
</li>
<li><p>函数执行过程，伴随着传参的过程：</p>
<p><img src="https://pic.imgdb.cn/item/619cc3962ab3f51d911e25f0.png"></p>
</li>
</ul>
<h3 id="函数的参数优点"><a href="#函数的参数优点" class="headerlink" title="函数的参数优点"></a>函数的参数优点</h3><ul>
<li>不论使用自己封装的函数，还是其他人封装的函数，只需要知道传递什么参数，执行什么功能，没必要知道内部的结构什么。</li>
<li>一般自己封装的函数或者其他人封装的函数需要有一个 API 接口说明，告诉用户参数需要传递什么类型的数据，实现什么功能。</li>
</ul>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><ul>
<li>函数能够通过参数接收数据，也能够将函数执行结果返回一个值。</li>
<li>利用函数内部的一个 <code>return</code> 的关键字设置函数的返回值。</li>
<li>作用 <code>①</code>：函数内部如果结构体执行到一个 <code>return</code> 的关键字，会立即停止后面代码的执行。</li>
<li>作用 <code>②</code>：可以在 <code>return</code> 关键字后面添加空格，空格后面任意定义一个数据字面量或者表达式，函数在执行完自身功能之后，整体会被 <code>return</code> 矮化成一个表达式，表达式必须求出一个值继续可以参与程序，表达式的值就是 <code>return</code> 后面的数据。</li>
</ul>
<h3 id="函数的返回值应用"><a href="#函数的返回值应用" class="headerlink" title="函数的返回值应用"></a>函数的返回值应用</h3><ul>
<li>函数如果有返回值，执行结果可以当成普通数据参与程序。</li>
<li>函数如果有返回值，可以作为一个普通数据赋值给一个变量，甚至赋值给其他函数的实际参数。</li>
<li>注意：如果函数没有设置 <code>return</code> 语句 ，那么函数有默认的返回值 <code>undefined</code>；如果函数使用 <code>return</code> 语句，但是 <code>return</code> 后面没有任何值，那么函数的返回值也是 <code>undefined</code>。</li>
</ul>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><ul>
<li>函数表达式是函数定义的另外一种方式。</li>
<li>定义方法：就是将函数的定义、匿名函数赋值给一个变量。</li>
<li>函数定义赋值给一个变量，相当于将函数整体矮化成了一个表达式。</li>
<li>匿名函数：函数没有函数名。</li>
<li>调用函数表达式，方法是给变量名加()执行，不能使用函数名加()执行。</li>
</ul>
<h3 id="函数的数据类型"><a href="#函数的数据类型" class="headerlink" title="函数的数据类型"></a>函数的数据类型</h3><ul>
<li>函数是一种单独的数据类型 <code>Function</code>。</li>
<li>由于函数是一种数据类型，可以参与其他程序。</li>
<li>例如，可以把函数作为另一个函数的参数，在另一个函数中调用。</li>
<li>或者，可以把函数可以作为返回值从函数内部返回。</li>
</ul>
<h3 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a><code>arguments</code> 对象</h3><ul>
<li><code>JavaScript</code> 中，<code>arguments</code> 对象是比较特别的一个对象，实际上是当前函数的一个内置属性。也就是说所有函数都内置了一个 <code>arguments</code> 对象，<code>arguments</code> 对象中存储了传递的所有的实参。<code>arguments</code> 是一个伪数组，因此及可以进行遍历。 </li>
<li>函数的实参个数和形参个数可以不一致，所有的实参都会存储在函数内部的 <code>arguments</code> 类数组对象中。</li>
</ul>
<h3 id="函数递归"><a href="#函数递归" class="headerlink" title="函数递归"></a>函数递归</h3><ul>
<li>函数内部可以通过函数名调用函数自身的方式，就是函数递归现象。 </li>
<li>递归的次数太多容易出现错误：超出计算机的计算最大能力。 </li>
<li>更多时候，使用递归去解决一些数学中的现象。 </li>
<li>例如可以输出斐波那契数列的某一项的值。</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><p>作用域：变量可以起作用的范围。</p>
</li>
<li><p>如果变量定义在一个函数内部，只能在函数内部被访问到，在函数外部不能使用这个变量，函数就是变量定义的作用域。</p>
</li>
<li><p>任何一对花括号 <code>&#123;&#125;</code> 中的结构体都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。</p>
</li>
<li><p>在<code>es5</code>之前没有块级作用域的的概念,只有函数作用域，现阶段可以认为 <code>JavaScript</code> 没有块级作用域。</p>
</li>
</ul>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul>
<li>局部变量：定义在函数内部的变量，只能在函数作用域内部被访问到，在外面没有定义的。</li>
<li>全局变量：从广义上来说，也是一种局部变量，定义在全局的变量，作用域范围是全局，在整个 <code>js</code> 程序任意位置都能够被访问到。</li>
<li>变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁。</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul>
<li>只有函数可以制造作用域结构，那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</li>
<li>将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。</li>
</ul>
<h3 id="遮蔽效应"><a href="#遮蔽效应" class="headerlink" title="遮蔽效应"></a>遮蔽效应</h3><ul>
<li>程序在遇到一个变量时，使用时作用域查找顺序，不同层次的函数内都有可能定义相同名字的变量，一个变量在使用时，会优先从自己所在层作用域查找变量，如果当前层没有变量定义会按照顺序从本层往外依次查找，直到找到第一个变量定义。整个过程中会发生内层变量遮蔽外层变量的效果，叫做“遮蔽效应” 。</li>
</ul>
<h3 id="参数也是局部变量"><a href="#参数也是局部变量" class="headerlink" title="参数也是局部变量"></a>参数也是局部变量</h3><ul>
<li>函数的参数本质是一个变量，也有自己的作用域，函数的参数也是属于函数自己内部的局部变量，只能在函数内部被使用，在函数外面没有定义。</li>
</ul>
<h3 id="不写-var-关键字的影响"><a href="#不写-var-关键字的影响" class="headerlink" title="不写 var 关键字的影响"></a>不写 <code>var</code> 关键字的影响</h3><ul>
<li>在函数内部想要定义新的变量，如果不加关键字 <code>var</code>，相当于定义的全局变量。如果全局也有相同的标识符，会被函数内部的变量影响，局部变量污染全局变量。</li>
<li>注意：每次定义变量时都必须写 <code>var</code> 关键字，否则就会定义在全局，可能污染全局。</li>
</ul>
<h3 id="函数的作用域"><a href="#函数的作用域" class="headerlink" title="函数的作用域"></a>函数的作用域</h3><ul>
<li>函数也有自己的作用域，定义在哪个作用域内部，只能在这个作用域范围内被访问，出了作用域不能被访问的。</li>
<li>函数定义在另一个函数内部，如果外部函数没有执行时，相当于内部代码没写。</li>
</ul>
<h3 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h3><ul>
<li><code>JavaScript</code> 代码的执行是由浏览器中的 <code>JavaScript</code> 解析器来执行的。<code>JavaScript</code> 解析器执行 <code>JavaScript</code> 代码的时候，分为两个过程：预解析过程和代码执行过程。</li>
<li>预解析过程：<ul>
<li>把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。</li>
<li>把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。</li>
<li>先提升 <code>var</code> ，再提升<code>function</code>。</li>
</ul>
</li>
<li><code>JavaScript</code> 的执行过程：在预解析之后，根据新的代码顺序，从上往下按照既定规律执行 <code>js</code> 代码。</li>
</ul>
<h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><ul>
<li>在预解析过程中，所有定义的变量，都会将声明的过程提升到所在的作用域最上面，在将来的代码执行过程中，按照先后顺序会先执行被提升的声明变量过程。</li>
<li>提升过程中，只提升声明过程，不提升变量赋值，相当于变量定义未赋值，变量内存储 <code>undefined</code> 值。</li>
<li>因此，在 <code>js</code> 中会出现一种现象，在前面调用后定义的变量，不会报错，只会使用 <code>undefined</code> 值。</li>
</ul>
<h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><ul>
<li>在预解析过程中，所有定义的函数，都会将声明的过程提升到所在的作用域最上面，在将来的代码执行过程中，按照先后顺序会先执行被提升的函数声明过程。</li>
<li>在预解析之后的代码执行过程中，函数定义过程已经在最开始就会执行，一旦函数定义成功，后续就可以直接调用函数。</li>
<li>因此，在 <code>js</code> 中会出现一种现象，在前面调用后定义的函数，不会报错，而且能正常执行函数内部的代码。</li>
</ul>
<h3 id="提升顺序"><a href="#提升顺序" class="headerlink" title="提升顺序"></a>提升顺序</h3><ul>
<li>预解析过程中，先提升 <code>var</code> 变量声明，再提升 <code>function</code> 函数声明。</li>
<li>假设出现变量名和函数名相同，那么后提升的函数名标识符会覆盖先提升的变量名，那么在后续代码中出现调用标识符时，内部是函数的定义过程，而不是 undefined。</li>
<li>如果调用标识符的过程在源代码函数和变量定义后面，相当于函数名覆盖了一次变量名，结果在执行到变量赋值时，又被新值覆盖了函数的值，那么在后面再次调用标识符，用的就是变量存的新值。</li>
<li>建议：不要书写相同的标识符给变量名或函数名，避免出现覆盖。</li>
</ul>
<h3 id="函数表达式的提升"><a href="#函数表达式的提升" class="headerlink" title="函数表达式的提升"></a>函数表达式的提升</h3><ul>
<li>在预解析过程中，函数表达式进行的是<strong>变量声明提升</strong>，而不是函数声明提升。提升后变 量内部存的是一个 <code>undefined</code>。在前面进行函数方法调用，数据类型会提示错误。</li>
<li>建议：定义函数时，最好使用 <code>function</code> 关键字定义方式，这样函数声明提升可以永远生效。</li>
</ul>
<h3 id="函数声明提升的应用"><a href="#函数声明提升的应用" class="headerlink" title="函数声明提升的应用"></a>函数声明提升的应用</h3><ul>
<li>函数声明提升可以用于调整代码的顺序，将大段的定义过程放到代码最后，但是不影响 代码执行效果。</li>
</ul>
<h3 id="IIFE-自调用函数"><a href="#IIFE-自调用函数" class="headerlink" title="IIFE 自调用函数"></a><code>IIFE</code> 自调用函数</h3><ul>
<li><code>IIFE</code>：<code>immediately-invoked function expression</code>，叫做即时调用的函数表达式，也叫做自调用函数，表示函数在定义时就立即调用。</li>
<li>函数调用方式：函数名或函数表达式的变量名后面加 <code>()</code> 运算符。</li>
<li>函数名定义的形式不能实现立即执行自调用，函数使用函数表达式形式可以实现立即执行，原因是因为函数表达式定义过程中，将一个函数矮化成了一个表达式，后面加<code>()</code>运算符就可以立即执行。</li>
<li>启发：如果想实现 <code>IIFE</code>，可以想办法将函数矮化成表达式。</li>
<li>函数矮化成表达式，就可以实现自调用。</li>
<li>函数矮化成表达式的方法，可以让函数参与一些运算，也就是说给函数前面加一些运算符。 <ul>
<li>数学运算符：<code>+</code> <code>-</code> <code>()</code> </li>
<li>逻辑运算符：<code>！</code>非运算</li>
</ul>
</li>
<li><code>IIFE</code> 结构可以关住函数的作用域，在结构外面是不能调用函数的。</li>
<li><code>IIFE</code> 最常用的是 <code>()</code> 运算符，而且函数可以不写函数名，使用匿名函数。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/08/0204406b3a5a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="数组的概念"><a href="#数组的概念" class="headerlink" title="数组的概念"></a>数组的概念</h3><ul>
<li>所谓数组（<code>Array</code>），就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。</li>
</ul>
<h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><ul>
<li>数组是一组有序的数据集合。数组内部可以存放多个数据，不限制数据类型，并且数组的 长度可以动态的调整。</li>
<li>创建数组最简单的方式就是数组字面量方式。</li>
<li>数组的字面量：<code>[]</code></li>
<li>一般将数组字面量赋值给一个变量，方便后期对数组进行操作。</li>
<li>如果存放多个数据，每个数据之间用逗号分隔，最后一个后面不需要加逗号。</li>
</ul>
<h3 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h3><ul>
<li>数组可以通过一个 <code>index</code>（索引值、下标）去获取对应的某一项的数据，进行下一步操作。</li>
<li><code>index</code>：从 0 开始，按照整数排序往后顺序排序，例如 0,1,2,3……</li>
<li>可以通过 <code>index</code> 获取某一项值之后，使用或者更改数组项的值。</li>
<li>调用数据：利用数组变量名后面直接加 <code>[index]</code> 方式。</li>
<li>注意：如果索引值超过了数组最大项，相当于这一项没有赋值，内部存储的就是 <code>undefined</code>。</li>
<li>更改数据：<code>arr[index]</code> 调用这一项数据，后面等号赋值更改数据。</li>
</ul>
<h3 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h3><ul>
<li>数组有一个 <code>length</code> 的属性，记录的是数组的数据的总长度。</li>
<li>使用方法：<code>变量名.length</code></li>
<li>数组的长度与数组最后一项的下标存在关系，最后一项的下标等于数组的 <code>length-1</code>。</li>
<li>获取最后一项的数据时，可以这样书写：<code>console.log(arr[arr.length-1]);</code></li>
<li>数组的长度不是固定不变的，可以发生更改。</li>
<li>增加数组长度：直接给数组 <code>length</code> 属性赋一个大于原来长度的值。赋值方式使用等号赋值。</li>
<li>或者，可以给一个大于最大下标的项直接赋值，也可以强制拉长数组。</li>
<li>缩短数组长度：强制给 <code>length</code> 属性赋值，后面数据被会直接删除，删除是不可逆的。</li>
</ul>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><ul>
<li>遍历：遍及所有，对数组的每一个元素都访问一次就叫遍历。利用 <code>for</code> 循环，将数组中的每 一项单独拿出来，进行一些操作。</li>
<li>根据下标在 <code>0</code> 到 <code>arr.length-1</code> 之间，进行 <code>for</code> 循环遍历。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>流程控制语句</title>
    <url>/2021/08/e954a18be628/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><ul>
<li>一个表达式可以产生一个值，有可能是运算、函数调用、有可能是字面量。表达式可以放在任何需要值的地方。</li>
<li>特点：表达式会先执行出一个结果，然后再参与其他程序。</li>
</ul>
<h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><ul>
<li>语句可以理解为一个行为，循环语句和判断语句就是典型的语句。一个程序有很多个语句组成，一般情况下分号 <code>;</code> 分割一个一个的语句。</li>
<li>语句可以认为是给计算机的一个指令，执行这段代码。</li>
<li>一般语句以分号结束，特殊的结构除外。</li>
</ul>
<h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><ul>
<li>流程控制语句：通过一些特殊结构可以让 <code>js</code> 代码加载时，要么可以跳过一部分不加载，或者可以循环加载一段代码。</li>
<li>包括：条件分支语句、循环语句。</li>
</ul>
<h3 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h4><ul>
<li><code>if</code> 语句是最常用的条件分支语句，作用就是通过某个指定的判断条件，决定走哪个分支的代码。</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition expression) &#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>condition expression</code>：条件表达式，可以是任意的代码或者表达式，参与程序过程都会强制得到一个布尔值执行结果。表达式，<code>js</code> 中遇到任何表达式都会先计算出一个结果然后才能继续参与程序。</p>
</li>
<li><p><code>statement</code>：结构体，<code>js</code> 中可以用 <code>&#123;&#125;</code> 包括一行到多行语句，这些语句整体组成了一个结构体，结构体中的语句要执行就都执行，要不执行就都不执行。</p>
</li>
<li><p><code>if</code>：如果</p>
</li>
<li><p><code>else</code>：否则</p>
</li>
<li><p>总结：如果条件表达式为真 <code>true</code>，执行<code>结构体 1</code>，否则执行<code>结构体 2</code>。</p>
</li>
<li><p>注意事项</p>
<ul>
<li><code>if</code> 语句可以实现选择的功能，两个分支可以选择一个执行，不会都执行。</li>
<li><code>if</code> 语句可以不写 <code>else</code> 分支，表示条件成立就执行后面的结构体，如果条件不成立，直接跳出 <code>if</code> 语句不执行。</li>
<li><code>if</code> 语句后面的机构体如果是单行语句组成，可以省略 <code>&#123;&#125;</code> 不写。不建议省略大括号，容易出现程序错误。</li>
<li><code>if</code> 语句能够控制自己内部的流程，但是不论走哪个分支，结束后都要继续执行 <code>if</code> 语句后面的其他语句，叫做殊途同归现象。</li>
</ul>
</li>
</ul>
<h4 id="多分支-if-语句"><a href="#多分支-if-语句" class="headerlink" title="多分支 if 语句"></a>多分支 <code>if</code> 语句</h4><ul>
<li><p>包含多个判断条件，对应多个分支。</p>
</li>
<li><p>语法：<code>if……else if……else if……else……</code></p>
</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    满足条件<span class="number">1</span>，执行的结构体</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    不满足条件<span class="number">1</span>，满足条件<span class="number">2</span>，执行的结构体</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">3</span>) &#123;</span><br><span class="line">    不满足条件<span class="number">1</span>/<span class="number">2</span>，满足条件<span class="number">3</span>，执行的结构体</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    不满足前面所有条件，执行的结构体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意事项</p>
<ul>
<li>多分支 <code>if</code> 语句中可以有多个 <code>else if</code> 的分支，但是 <code>else</code> 分支只能有一个，必须出现在最后，作为备用的选项，而且 <code>else</code> 也可以省略不写，表示前面条件如果都不满足，直接跳出不走任何分支</li>
<li>多分支 <code>if</code> 语句有跳楼现象：条件从上往下依次验证，如果满足了某个条件，会立即执行后面的结构体，执行完之后，不会再往后验证其他的条件了，而是从这一层直接跳楼跳出<code>if</code>语句，这就是跳楼现象</li>
</ul>
</li>
</ul>
<h4 id="if-语句嵌套"><a href="#if-语句嵌套" class="headerlink" title="if 语句嵌套"></a><code>if</code> 语句嵌套</h4><ul>
<li><p><code>if</code> 语句的结构体部分，代码可以是任意的代码，甚至是另外一组 <code>if</code> 语句。</p>
</li>
<li><p>也就是 <code>if</code> 语句内部嵌套了 <code>if</code> 语句。</p>
</li>
<li><p>如果想执行内部 <code>if</code> 语句的某个分支，必须满足外部 <code>if</code> 语句的条件，同时还要满足内部 <code>if</code> 语句的某个条件。</p>
</li>
<li><p>优点：可以简化多分支 <code>if</code> 语句</p>
</li>
</ul>
<h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><ul>
<li><p>又叫三元运算符，必须有三个操作数参与的运算。</p>
</li>
<li><p>操作符号：<code>? :</code></p>
</li>
<li><p>表达式：在参与 <code>js</code> 程序时，都必须先计算出表达式结果，才能参与后续程序。</p>
</li>
<li><p>由于三元表达式具备了一些选择的效果，所以也是一种条件分支语句</p>
</li>
<li><p>语法</p>
<ul>
<li><code>boolean_expression ? true_value : false_value;</code></li>
<li><code>boolean_expression</code>:布尔表达式，表达式在参与三元运算中必须求得一个布尔类型的值，要么是 <code>true</code>，要么是 <code>false</code>，结果作为判断依据，判断到底去：前面的值还是后面的值。</li>
<li><code>true_value</code>：布尔表达式的值为真时，三元表达式的结果。</li>
<li><code>false_value</code>：布尔表达式的值为假时，三元表达式的结果。</li>
<li>作用：根据布尔表达式的结果，如果为真，三元表达式结果就是真值，如果为假，三元表达式结果就是假值。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>虽然<code>if</code>语句可以模拟三元表达式，但是三元表达式有自己的优点：</p>
<ul>
<li><p>二选一的情况下，三元表达式结构更加简单。</p>
</li>
<li><p>三元表达式作为一个表达式参与程序时必须运算出结果才能参与，可以利用这个特点，将二选一结果赋值给一个变量。</p>
</li>
</ul>
</li>
<li><p>遇到给一个变量根据条件二选一赋值的情况，可以使用三元表达式</p>
</li>
</ul>
</li>
</ul>
<h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a><code>switch</code> 语句</h4><ul>
<li>开关语句允许一个程序求一个表达式的值，并且尝试去匹配表达式的值到一个 case 标签。如果匹配成功，这个程序执行相关的语句。</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        结构体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        结构体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>: </span><br><span class="line">        结构体n；</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>switch</code> 语句结构解析</p>
<ul>
<li><code>switch</code>：关键字表示开始进入一个开关语句。</li>
<li>表达式：会求出一个具体的值，将这个值去与 <code>&#123;&#125;</code> 内部的 <code>case</code> 后面的值进行对比、匹配，如果值相等表示匹配成功。匹配相等时，方式是进行全等于匹配，不止值要相等，数据类型也要相等。</li>
<li><code>case</code>：示例的意思，作为关键字后面必须跟一个空格，书写匹配的值。</li>
<li><code>case</code> 后面的结构体：每个 <code>case</code> 匹配成功之后要执行的语句。</li>
<li><code>break</code>：用于打断结构体，直接跳出程序，模拟跳楼现象。</li>
<li><code>default</code>：相当于<code>if</code>语句中的 <code>else</code>，否则的情况，如果前面的 <code>case</code> 都不匹配，执行 <code>default</code> 后面的语句。</li>
</ul>
</li>
<li><p><code>switch</code> 语句运行机制</p>
<ul>
<li><code>switch</code> 语句首先会将小括号内的表达式计算出一个结果，用结果去匹配结构体内部的 <code>case</code>；</li>
<li>从上往下进行匹配，如果匹配成功，会立即执行这个 <code>case</code> 后面的语句，直到遇到一个 <code>break</code> 跳出整个 <code>switch</code> 语句；</li>
<li>如果前面的 <code>case</code> 没有匹配成功，会跳过 <code>case</code> 之间的语句，去匹配下一个 <code>case</code>，直到匹配成功，如果都不成功就执行 <code>default</code> 后面的语句。</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li><code>default</code> 可以不写，相当于 <code>if</code> 语句没有 <code>else</code>。</li>
<li><code>break</code> 关键字：根据结构需要有时必须在每个 <code>case</code> 后面都要写，为了模拟跳楼现象，如果不写 <code>break</code>，对应的 <code>case</code> 后面的语句执行之后，不会跳出结构体，会继续想下执行其他 <code>case</code> 的后面的语句，直到遇到一个 <code>break</code>。</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>实际工作中使用三种语句的情景</p>
<ul>
<li><code>if</code> 语句：最常用的语句，所有的判断情况都能够书写。</li>
<li>三元表达式：多用于给变量赋值根据条件二选一的情况。</li>
<li><code>switch</code> 语句：多用于给一个表达式去匹配多种固定值可能性的情况。</li>
</ul>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><ul>
<li><p><code>for</code> 循环是一种前测试循环语句，在反复执行一段代码之前，都要先测试入口条件，如果条件为真，可以继续循环，如果条件为假，必须跳出循环不再执行。</p>
</li>
<li><p><code>for</code> 循环是一种反复执行一段代码直到测试条件为假时停止。</p>
</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 呆板的语法：</span></span><br><span class="line"><span class="keyword">for</span>(定义循环变量;变量的最大值或最小值;步长)&#123;</span><br><span class="line">    循环体；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这种解释只能涵盖 for 循环的一部分特殊结构，不能表示所有的 for 循环实现的情况。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>for</code>循环执行过程</p>
<ul>
<li>应该掌握 <code>for</code> 循环运行的一个轨迹、路径，自己去推导 <code>for</code> 循环运行的过程</li>
<li><img src="https://pic.imgdb.cn/item/619c54ee2ab3f51d91e42e57.png"></li>
<li>遇到 <code>for</code> 循环，立即执行 <code>①</code> 位置的语句，执行完毕后立即执行 <code>②</code> 位置的语句，<code>②</code> 位置会强制得到一个 <code>true</code> 或 <code>false</code>的结果，如果为 <code>true</code> 表示入口条件为真，下一步执行 <code>③</code> 位置的语句，如果为 <code>false</code> 表示入口条件为假，不再往下执行，直接跳出循环执行后面的 <code>⑤</code> 位置的语句。</li>
<li>如果能够执行到 <code>③</code> 位置，<code>③</code> 是一个结构体必须执行完毕，再执行 <code>④</code> 位置的语句，执行完毕后再执行 <code>②</code> 位置的语句，回到了判断真假，如果为 <code>true</code>，继续执行 <code>③</code>，再执行 <code>④</code>……直到 <code>②</code> 位置得到一个 <code>false</code> 的结果，循环结束跳出执行 <code>⑤</code>。</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li>小括号内部必须有两个分号。</li>
<li><code>for</code> 循环 <code>&#123;&#125;</code> 后面不需要加分号。</li>
<li>如果 <code>②</code> 位置语句不写，相当于没有设置入口条件，或者条件永远为真，没法限制什么时候停止循环了，出现死循环。</li>
<li><code>③</code> 位置是循环的结构体，每次进入循环都要执行完后，才能执行语句 <code>④</code>，<code>③</code> 位置的语句是可以人为自定义的，甚至可以书写 <code>if</code> 语句。</li>
<li><code>for</code> 循环嵌套 <code>if</code> 语句：表示既要能够执行循环，还要满足 <code>if</code> 语句的条件。</li>
<li><code>for</code> 循环嵌套 <code>for</code> 循环：外层循环执行一次，内层循环作为外层 <code>③</code> 位置的结构体，必须执行完所有的内层循环，才能进入外层循环下一次的 <code>④</code>。</li>
<li>循环内的变量是全局变量，必须避免循环嵌套时起相同的变量名，内层和外层变量名必须不同，常用的变量名 <code>i</code>，<code>j</code>，<code>k</code>。</li>
</ul>
</li>
</ul>
<h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do while循环"></a><code>do while</code>循环</h4><ul>
<li><code>do while</code> 循环是一种后测试循环语句，会先执行一次结构体，执行完后才会去判断入口条件，如果条件为真能够继续下一次循环，如果条件为假跳出循环。</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    结构体；</span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>do</code>：做什么。后面是每次循环的循环体。</p>
</li>
<li><p><code>while</code>：当……时候。</p>
</li>
<li><p>先执行一次循环体，然后当条件表达式为真时可以继续循环。</p>
</li>
<li><p>注意事项</p>
<ul>
<li>如果循环中需要循环变量参与，循环变量必须定义在循环外面，否则会被重置。</li>
<li>循环变量自加的过程需要写在 <code>&#123;&#125;</code> 循环体内部。</li>
<li>如果将循环变量写在结构体内，<code>i</code>的初始值每次都会被重置，容易出现死循环。</li>
<li>变量自加过程写在输出语句前面和后面，结果是不同的。</li>
<li><code>do while</code> 循环即便条件第一次测试就为假，也会执行一次结构体。</li>
<li>至少会执行一次循环体。</li>
</ul>
</li>
</ul>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h4><ul>
<li><code>while</code> 循环是一种前测试循环语句，在执行循环体之前都要测试入口条件，条件为真继续执行，条件为假直接跳出循环。</li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)&#123;</span><br><span class="line">    循环体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当条件表达式为真时，执行循环体，如果为假，跳出循环</p>
</li>
<li><p>注意事项</p>
<ul>
<li>如果需要循环变量参与，必须定义在循环外部，避免被重置。</li>
<li>循环变量自加的过程写在循环体内部。</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>遇到必须先执行一次结构体的循环，使用 <code>do while</code> 循环。</li>
<li>先测试入口条件的循环，可以选择 <code>for</code> 循环或 <code>while</code> 循环。</li>
</ul>
</li>
</ul>
<h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a><code>break</code>语句</h4><ul>
<li>我已经找到我要的答案了，我不需要进行更多的循环了！</li>
<li><code>break</code> 语句的作用可以立即停止当前的 <code>for</code>、<code>do while</code>、<code>while</code> 循环。 </li>
<li>根据一些条件设置 <code>break</code> 位置，直到循环能够执行到 <code>break</code> 语句立即停止执行，跳出循环。</li>
<li>注意事项<ul>
<li><code>break</code> 如果没有特殊指示，只能停止自己所在的那一层循环，并不能终止外部循环。</li>
<li>如果想停止外层循环，可以给外层循环添加一个标签名 <code>label</code>，在内层循环的 <code>break</code> 关键字后面空格加一个 <code>label</code> 名。</li>
</ul>
</li>
</ul>
<h4 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a><code>continue</code>语句</h4><ul>
<li><p>这个答案不是我想要的，赶紧试试下一个吧！</p>
</li>
<li><p>遇到 <code>continue</code> 表示当前的一次循环数据不是我们想要的，会立即停止当前次的循环，立即进入下一次循环。 </p>
</li>
<li><p>注意事项</p>
<ul>
<li><p>要根据特殊条件设置 <code>continue</code> 的位置。</p>
</li>
<li><p><code>continue</code> 如果没有特殊指示只能进入自己的下一次循环，不能立即停止外层循环的这一次进入下一次。</p>
</li>
<li><p>控制外层循环的方式与 <code>break</code> 一样，都是添加外层的标签名。</p>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><code>break</code> 和 <code>continue</code> 这两个语句的出现可以帮助我们大量的优化代码，减少了计算机的计算次数。</li>
</ul>
</li>
</ul>
<h4 id="穷举思想"><a href="#穷举思想" class="headerlink" title="穷举思想"></a>穷举思想</h4><ul>
<li><p>实际案例中，可能需要找到一些有规律的数据，但是计算机没办法自动智能筛选所要的数据，只能程序员自己书写一段代码，让计算机根据代码去进行筛选。</p>
</li>
<li><p>穷举思想：是一种解决问题的方法，将所有的需要数据所在的范围内所有的数据都一一列举出来，再根据规律的条件对所有这些数据进行筛选，这种方式就是穷举法。</p>
</li>
<li><p>穷：穷尽，举：列举</p>
</li>
<li><p>制作方法</p>
<ul>
<li><code>for</code> 循环：外层使用 <code>for</code> 循环进行一一列举。</li>
<li><code>if</code> 语句：内层用 <code>if</code> 语句进行判断，筛选需要的数据，如果满足条件就操作数据，如果不满足条件跳过看下一次循环的数据。</li>
</ul>
</li>
</ul>
<h4 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h4><ul>
<li><p>有时候需要的不是每个数据是什么，需要得到所有数据的加和，必须想办法将所有的数据的和存起来，就用到了累加器。</p>
</li>
<li><p>累加器本质就是变量。</p>
</li>
<li><p>实现累加的效果，就是利用循环，每次循环就将新的数据加到原始的变量中去，赋值过程是一个加等于赋值。</p>
</li>
<li><p>注意事项</p>
<ul>
<li>累加器必须定义在循环外面的前面，如果定义在循环内部，每次循环都会将累加器重置，不能实现累加功能。</li>
<li>累加器的初始值必须设置，而且必须设置为 0，不会影响累加结果。</li>
<li>使用最终累加结果时，必须在 <code>for</code> 循环结束后的外面，如果写在循环内部，循环没结束，并不是最终需要的值。</li>
</ul>
</li>
</ul>
<h4 id="累乘器"><a href="#累乘器" class="headerlink" title="累乘器"></a>累乘器</h4><ul>
<li>累积一些数据的乘积。与累加器非常类似。</li>
<li>注意事项<ul>
<li>累乘器必须定义在循环外部前面。</li>
<li>累乘器的初始值必须是 1，1 乘以任何数都等于本身。</li>
<li>累乘器最终结果必须在 <code>for</code> 循环结束后使用。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>操作符</title>
    <url>/2021/08/f0b79071b9ae/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><ul>
<li><p><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>()</code></p>
</li>
<li><p><code>%</code>:取余，取模。 <code>a / b = c 余 d</code>，就说<code>a % b = d</code>。</p>
</li>
<li><p>运算顺序：先算乘除取余、再算加减，有小括号先算小括号。</p>
</li>
<li><p>正常情况</p>
<ul>
<li>数字与数字之间的运算。</li>
</ul>
</li>
<li><p>非正常情况 1</p>
<ul>
<li>有特殊值字面量参与的运算。</li>
<li><code>NaN</code>参与的运算：得到的结果都是<code>NaN</code></li>
<li><code>Infinity</code>参与的运算，视情况而定</li>
<li>工作中并不会使用特殊值运算，没有实际应用的意义，但是要了解。</li>
</ul>
</li>
<li><p>非正常情况 2</p>
<ul>
<li>其他类型的数据参与数学运算。</li>
<li>有字符串参与的 <code>+</code> 运算：<code>+</code> 号变为连字符将前后连接成整体字符串。</li>
<li><strong>隐式转换</strong>：除了字符串参与的 <code>+</code> 运算，其他情况下，所有其他数据类型参与数学运算时，计算机暗中将其他数据类型先自动转换成数字类型，再参与运算，这个过程中不需要使用<code>parseInt()</code>、<code>Number()</code> 等方法，过程是暗中进行，这就是一个隐式转换的过程。<ul>
<li>其他的数据类型会隐式转换为数字类型：<ul>
<li>对应数字：纯数字字符串会转为对应的数字<code>&quot;123&quot;→123</code></li>
<li>转换为<code>1</code>： <code>true</code></li>
<li>转换为<code>0</code>：<code>false</code>、<code>null</code>、 <code>&quot;&quot;空字符串</code>、<code>空白字符串</code></li>
<li>转换为<code>NaN</code>：<code>undefined</code>、<code>非空非纯数字字符串</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li><p>也叫作关系运算符。一个比较运算符 <code>comparison operator</code> 比较它的操作数并返回一个布尔类型值。运算结果要么是<code>true</code>，要么是<code>false</code>。</p>
<ul>
<li><code>&gt;</code> 大于</li>
<li><code>&lt;</code> 小于 </li>
<li><code>&gt;=</code> 大于等于</li>
<li><code>&lt;=</code> 小于等于</li>
<li><code>==</code> 相等，只判断值大小是否相等，不判断数据类型</li>
<li><code>!=</code> 不等，与相等完全相反</li>
<li><code>===</code> 全等，不光判断值相等，还要判断数据类型相等</li>
<li><code>!==</code> 不全等，与全等于完全相反</li>
</ul>
</li>
<li><p>正常情况</p>
<ul>
<li>数字与数字比较。</li>
</ul>
</li>
<li><p>非正常情况 1</p>
<ul>
<li>特殊值参与比较运算。</li>
<li><code>NaN</code>参与：不等于和不全等于结果是 <code>true</code>，其他的都得到 <code>false</code>。</li>
<li><code>Infinity</code>参与的运算，视情况而定</li>
</ul>
</li>
<li><p>非正常情况 2</p>
<ul>
<li>其他数据类型参与比较运算（排除字符串与字符串的比较）。</li>
<li> 其他数据类型也会隐式转换为数字参与比较。 <code>“123”→123</code> <code>true→1</code> <code>false→0</code> <code>null→0</code> <code>undefined→NaN</code> <code>“”→0</code> <code>“abc”→NaN</code></li>
<li><code>null</code> 的判断比较特殊：<code>null</code> 与 <code>0</code> 判断时，相等判断为 <code>false</code>，<code>&gt;=</code> 和 <code>&lt;=</code> 判断为 <code>true</code></li>
<li><code>null</code> == <code>undefined</code></li>
</ul>
</li>
<li><p>非正常情况 3</p>
<ul>
<li>字符串与字符串比较。</li>
<li>不会发生隐式转换为数字，而是比较两个字符串的 <code>Unicode</code> 编码顺序。</li>
<li>字符编码顺序：从前往后 <code>0-9</code>，<code>A-Z</code>，<code>a-z</code>，前面的小于后面的。</li>
<li>比较时，不关心两个字符串的长度，从第一个字符开始比较，依次往后顺延比较，直到比较出大小，就不再往后比较。</li>
</ul>
</li>
<li><p>比较运算符运算顺序</p>
<ul>
<li>从前往后比较，前面的结果与后面的进行比较。</li>
<li>3 &gt; 2 &gt; 1</li>
</ul>
</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li>逻辑运算符常用于布尔类型值之间; 当操作数都是布尔值时，返回值也是布尔值。<ul>
<li><code>&amp;&amp;</code> 逻辑与运算符</li>
<li><code>||</code> 逻辑或运算符</li>
<li><code>!</code> 逻辑非运算符</li>
</ul>
</li>
<li>正常情况<ul>
<li>布尔类型的值参与运算，返回值为布尔值。</li>
</ul>
</li>
<li>非正常情况<ul>
<li>除了布尔类型的值之外，其他数据类型的值也可以参与逻辑运算。运算过程中需要将操作数隐式转换为布尔类型的值，参与判断计算，最终运算结果还是原来的某个位置的数据。</li>
<li>并不是所有逻辑运算返回结果都是布尔值，其他数据参与得到的就是数据本身。</li>
</ul>
</li>
<li>隐式转换为布尔值的规律<ul>
<li>转为<code>false</code>：<code>NaN</code>、<code>0</code>、 <code>“”空字符串</code>、<code>null</code>、<code>undefined</code></li>
<li>转为<code>true</code>：<code>非0 非NaN数字</code>、<code>非空字符串</code></li>
<li>当它们用于非布尔值的时候，返回值就可能是非布尔值。其实这种运算非常简单，就两句话<ul>
<li>(<strong>逻辑与 <code>a&amp;&amp;b</code></strong> ) 如果<code>a</code>能被转换为<code>false</code>，那么返回<code>a</code>；否则，返回<code>b</code>。</li>
<li>(<strong>逻辑或 <code>a||b</code></strong> ) 如果<code>a</code>能被转换为<code>true</code>，那么返回<code>a</code>；否则，返回<code>b</code>。</li>
</ul>
</li>
</ul>
</li>
<li>逻辑运算符运算顺序<ul>
<li>同种运算符从前往后运算。</li>
<li>综合运算顺序：非、与、或。</li>
</ul>
</li>
</ul>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ul>
<li>赋值运算符必须有变量参与运算，赋值运算符会做两件事情：<ul>
<li>第一，将变量中原始值参与对应数学运算，与右侧的数据。</li>
<li>第二，将运算结果再重新赋值给变量。</li>
</ul>
</li>
<li>变量位于操作符的左侧。</li>
<li>赋值运算符符号<ul>
<li><code>=</code> 等于 </li>
<li><code>+=</code> 加等于 </li>
<li><code>-=</code> 减等于 </li>
<li><code>*=</code> 乘等于 </li>
<li><code>/=</code> 除等于 </li>
<li><code>%=</code> 取余等于 </li>
<li><code>++</code> 递加 </li>
<li><code>--</code> 递减</li>
</ul>
</li>
</ul>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul>
<li><code>++</code> 和 <code>--</code> 也叫一元运算符，只有一个操作数。</li>
<li><code>++</code> 或 <code>--</code> 符号可以写在变量前和变量后面，位置不同可能导致程序运行结果不同。</li>
<li>以 <code>++</code> 为例：<ul>
<li><code>a++</code>: <code>++</code> 符号在变量之后，<code>a++</code> 在参与程序过程中使用的原始没有加 <code>1</code> 的值，使用完后第二次用 <code>a</code> 变量时，<code>a</code> 用的就是加 <code>1</code> 后的新值。先参与，后自加。</li>
<li><code>++a</code>：<code>++</code> 符号在变量之前，<code>++a</code> 在参与过程中整体就使用 <code>a</code> 加 <code>1</code> 之后的新值，使用完后第二次用 <code>a</code> 变量时，<code>a</code> 用的也是加 <code>1</code> 的新值。先自加，后参与。</li>
</ul>
</li>
</ul>
<h3 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h3><ul>
<li>运算优先级也可以叫综合运算顺序。</li>
<li>优先级从高到底<ol>
<li><code>()</code> 优先级最高 </li>
<li>一元运算符 <code>++</code> <code>--</code> <code>!</code> </li>
<li>算数运算符 先<code>*</code> <code>/</code> <code>%</code> 后 <code>+</code> <code>-</code> </li>
<li>关系运算符 <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code> </li>
<li>相等运算符 <code>==</code> <code>!=</code> <code>===</code> <code>!==</code> </li>
<li>逻辑运算符 先<code>&amp;&amp;</code> 后<code>||</code> </li>
<li>赋值运算符</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2021/08/518c5d3e65b8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><ul>
<li>字面量（<code>literal</code>）是用于表达一个固定值的表示法，又叫常量。</li>
<li>通俗的理解，字面就是所见即所得，<code>js</code> 程序执行到代码中的字面量，会立即知道它是什么类型的数据，值是多少。</li>
<li>可以用于表示固定值，比如：数字、字符串、<code>undefined</code>、布尔类型的字面值等。</li>
<li>数值字面量：8, 9, 10</li>
<li>字符串字面量： “大前端”</li>
<li>布尔字面量：<code>true</code>，<code>false</code></li>
</ul>
<h3 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h3><ul>
<li>这里的数字就是数学意义上的数字。</li>
<li>数字字面量区分：整数字面量、浮点数字面量（小数）、特殊值。</li>
<li>书写时直接书写字面量，不需要添加任何辅助符号。</li>
</ul>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><ul>
<li><p>整数字面量写法区分进制。</p>
</li>
<li><p>整数可以被表示成十进制（基数为10）、八进制（基数为8）以及十六进制（基数为16）。</p>
</li>
<li><p><strong>十进制</strong>是最基本的数值字面量格式，可以直接在代码中输入。</p>
</li>
<li><p><strong>八进制</strong>字面值必须带前导<code>0</code>、<code>0O</code>、<code>0o</code> 。八进制整数只能包括数字0-7。</p>
</li>
<li><p><strong>十六进制</strong>的前缀是<code>0x</code>或<code>0X</code>。后面可以包含数字（0-9）和字母a<del>f或A</del>F。</p>
</li>
<li><p>在进行算术计算时或者参与程序，<strong>所有八进制和十六进制的数字都会被转换成十进制</strong>。</p>
</li>
<li><p>进制</p>
<ul>
<li><p>十进制：逢十进一，每个位数只能是0-9之间的数字。</p>
</li>
<li><p>八进制：逢八进一，每个位数上只能是0-7之间的数字，而且必须添加前缀，<code>0</code>、<code>0O</code>、<code>0o</code>。</p>
</li>
<li><p>十六进制：逢十六进一，每个位数上必须是0-9、a-f之间的符号，必须写前缀，<code>0x</code>、<code>0X</code>开头。</p>
</li>
</ul>
</li>
<li><p>特殊的：八进制中，如果以0开头，每个位数上有超过0-7之间的数字出现，也就是8/9，强制忽视前面的0，直接将后面数字当做十进制。</p>
</li>
</ul>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><ul>
<li>就是数学概念中的小数。</li>
<li>包含：整数、小数点、小数部分。</li>
<li>浮点数不区分进制，所有的浮点数都是十进制下的数字。</li>
<li>注意：如果浮点数是大于0小于1的，可以省略小数点前面的0不写。</li>
<li>精度问题<ul>
<li>浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数</li>
<li>例如：0.1 + 0.2; 结果不是 0.3，而是：0.30000000000000004</li>
</ul>
</li>
</ul>
<h4 id="Infinity-无穷"><a href="#Infinity-无穷" class="headerlink" title="Infinity 无穷"></a><code>Infinity</code> 无穷</h4><ul>
<li><code>Infinity</code>：无穷的意思。</li>
<li>由于计算机计算能力有限，如果高于最大计算值直接显示为正无穷 <code>Infinity</code>，如果低于最小计算值直接显示为 <code>-Infinity</code>。</li>
<li><code>Infinity</code> 本身就是一个数字。<ul>
<li>最小值：<code>Number.MIN_VALUE</code>，这个值为： <code>5e-324</code></li>
<li>最大值：<code>Number.MAX_VALUE</code>，这个值为： <code>1.7976931348623157e+308</code></li>
<li>无穷大：<code>Infinity</code></li>
<li>无穷小：<code>-Infinity</code></li>
</ul>
</li>
</ul>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a><code>NaN</code></h4><ul>
<li><code>NaN</code>：<code>not a number</code>表示不是一个正常的数，但是还是一个 <code>Number</code> 类型的数字。这个数字没办法用前面的表示方法表示。</li>
<li><code>NaN</code> 与任何值都不相等，包括他本身。</li>
<li><code>isNaN()</code>: 判断一个数据是不是一个<code>NaN</code>。</li>
</ul>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><ul>
<li>字符串是由任意个数的有序或无序的字符组成的串，类似人类的语言，在 <code>JS</code> 中有自己特殊的写法。</li>
<li>组成：字母、汉字、特殊符号、空白等。</li>
<li>字符串字面量写法：是用一对单引号<code>（&#39; &#39;）</code>或双引号<code>（&quot; &quot;）</code>及引号内的字符构成，引号中间 的字符可以有任意多个，也可以是没有字符的空字符串。</li>
<li>注意：字符串中如果字符包含了双引号，则其外部应该由单引号标示，反之相同。</li>
<li>转义符号 <code>\</code><ul>
<li>字符串中，有一些特殊功能的字符不能直接书写，还有一些特殊效果不能直接书写。</li>
<li>这时，可以使用转义符 <code>\</code> 对这些字符进行转义。</li>
<li>在字符串中可以使用转义符 <code>\</code> 加普通字母，替代一些特殊字符<ul>
<li><code>\n</code> 换行</li>
<li><code>\t</code> <code>Tab</code>制表</li>
</ul>
</li>
<li>字符串中可以使用转义符 <code>\</code> 将特殊功能字符变为普通字符。<ul>
<li><code>\&#39;</code> 单引号</li>
<li><code>\&quot;</code> 双引号</li>
<li><code>\\</code> 反斜杠</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h4><ul>
<li>变量（<code>variables</code>） 是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据。</li>
<li>变量相当于一个容器，内部可以存储任意类型的数据，使用变量时，用的是内部存储的数据。</li>
</ul>
<h4 id="为什么要使用变量"><a href="#为什么要使用变量" class="headerlink" title="为什么要使用变量"></a>为什么要使用变量</h4><ul>
<li>使用变量可以方便的获取或者修改内存中的数据。</li>
</ul>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><ul>
<li>变量声明又叫做定义变量、创建变量。</li>
<li>变量在使用前，必须先有定义，如果没有定义，会出现引用错误。</li>
<li> 定义方法：使用一个 <code>var</code> 的关键字进行定义，后面必须加一个空格，空格后面自定义变量名。</li>
</ul>
<h4 id="变量的命名规则和规范"><a href="#变量的命名规则和规范" class="headerlink" title="变量的命名规则和规范"></a>变量的命名规则和规范</h4><ul>
<li>规则 - 必须遵守的，不遵守会报错<ul>
<li>由<code>字母</code>、<code>数字</code>、<code>下划线</code>、<code>$</code> 符号组成，不能以数字开头。</li>
<li>字母区分大小写，<code>A</code> 和 <code>a</code> 表示不同。</li>
<li>不能是关键字和保留字，关键字指的是<code>js</code>中有特殊功能的小词语，比如 <code>var</code>、<code>for</code> 等；</li>
<li>保留字指的是现在没有特殊功能，但是将来新语法中有可能作为关键字使用。</li>
</ul>
</li>
<li>规范 - 建议遵守的，不遵守不会报错<ul>
<li>变量名必须有意义</li>
<li>遵守驼峰命名法。多个单词组合而成的，第一个单词首字母小写，后面单词的首字母需要大写。例如：<code>userName</code>、<code>userPassword</code></li>
</ul>
</li>
</ul>
<h4 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h4><ul>
<li>变量定义之后，初始时没有进行赋值，内部有一个默认存储的值叫 <code>undefined</code>（未定义），表示变量内部未赋值，可以存储数据了。</li>
<li>变量赋值的方式：通过<code>等号 = 赋值</code>，等号右边的值赋值给左边的变量。</li>
<li>注意：书写时，等号 = 两侧习惯书写一个空格。</li>
</ul>
<h4 id="变量赋值的几种情况"><a href="#变量赋值的几种情况" class="headerlink" title="变量赋值的几种情况"></a>变量赋值的几种情况</h4><ul>
<li>变量赋值时：内部可以存储任意类型的数据，甚至是一个变量。赋值过程中，等号右侧的变量使用的是存储的数据。</li>
<li>注意：变量参与赋值过程时，<code>等号左变右不变</code>。等号左侧会被赋值，将来值发生变化，等号右侧的变量使用内部的值参与运算，自身不会发生变化。</li>
<li>变量的赋初值过程可以与声明过程写在一起。</li>
<li>变量内部的值，可以通过多次赋值的方法，进行更改。</li>
<li>变量一次定义，可以多次等号赋值。</li>
<li>一个关键字 <code>var</code> 可以同时定义多个变量，并且都赋初值。多个变量之间用逗号进行分隔，最后一个变量后面使用分号进行结尾。</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript 中的值，无论是字面量还是变量，都有明确的类型。</p>
<h4 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h4><ul>
<li><code>Number</code> 数字类型</li>
<li><code>String</code> 字符串类型</li>
<li><code>undefined</code> <code>undefined</code> 类型</li>
<li><code>Boolean</code> 布尔类型</li>
<li><code>null</code> <code>null</code> 类型</li>
</ul>
<p>另外，还有复杂数据类型</p>
<ul>
<li><code>Object</code> 对象类型</li>
</ul>
<h5 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a><code>Number</code> 类型</h5><ul>
<li>数字类型，不区分整数、浮点数、特殊值，都是 <code>Number</code> 类型。</li>
</ul>
<h5 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a><code>String</code> 类型</h5><ul>
<li>字符串类型，所有的字符串都是 <code>String</code> 类型。</li>
</ul>
<h5 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a><code>Boolean</code> 类型</h5><ul>
<li><code>Boolean</code> 字面量： 只有 <code>true</code> 和 <code>false</code> 两个字面量的值，必须是小写字母。</li>
<li>计算机内部存储：<code>true</code>为<code>1</code>，<code>false</code>为<code>0</code></li>
</ul>
<h5 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a><code>Undefined</code> 类型</h5><ul>
<li><code>undefined</code> 本身是一个数据，表示未定义。</li>
<li>变量只声明的时候值默认是 <code>undefined</code>。</li>
</ul>
<h5 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a><code>Null</code> 类型</h5><ul>
<li><code>null</code> 本身是一个数据。</li>
<li>从逻辑角度，<code>null</code> 值表示一个空对象指针。</li>
<li>如果定义的变量准备在将来用于保存对象，最好将该变量初始化为 <code>null</code>。</li>
</ul>
<h4 id="检测数据类型"><a href="#检测数据类型" class="headerlink" title="检测数据类型"></a>检测数据类型</h4><ul>
<li>使用 <code>typeof</code> 的方法进行数据检测。</li>
<li>检测方式：在 <code>typeof</code>后面加小括号 <code>()</code> 执行，将要检测的数据放在小括号内部。</li>
<li>也可以将 <code>typeof</code> 作为关键字，后面加空格，空格后添加数据的方式，检测数据。</li>
</ul>
<h5 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h5><ul>
<li><code>JavaScript</code> 语言是一门动态类型的语言，变量并没有一个单独的数据类型，而是会随着内部 存储数据的变化，数据类型也会发生变化。</li>
<li>变量的数据类型，与内部存储数据有关。</li>
<li>将来使用变量时，需要知道内部存储的数据是什么类型，避免程序出错。</li>
</ul>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>不同的数据类型之间，可以进行互相转换。</p>
<h5 id="转换成字符串类型"><a href="#转换成字符串类型" class="headerlink" title="转换成字符串类型"></a>转换成字符串类型</h5><ul>
<li><code>数据.toString()</code> 方法</li>
<li><code>String(数据)</code> 方法，有些值没有<code>toString()</code>，这个时候可以使用<code>String()</code>。比如：<code>undefined</code>和<code>null</code></li>
<li><code>+</code> 号拼接字符串方式<ul>
<li><code>num + &quot;&quot;</code>，当 <code>+</code> 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串。</li>
<li><code>+</code> 号的特殊性<ul>
<li>两边只要有一个是字符串，那么 <code>+</code> 就是字符串拼接功能</li>
<li>两边如果都是数字，那么就是算术功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="转换成数值类型"><a href="#转换成数值类型" class="headerlink" title="转换成数值类型"></a>转换成数值类型</h5><ul>
<li><p><code>Number(数据)</code> 方法</p>
<ul>
<li>转型函数<code>Number()</code>可以用于任何数据类型，将其他数据类型转为数字。</li>
<li>字符串：纯数字字符串转为对应数字，空字符串和空白字符串转为 <code>0</code> ，非空非纯数字字符串转为 <code>NaN</code>。</li>
<li>布尔值：<code>true</code> 转为 <code>1</code>，<code>false</code> 转为 <code>0</code>。</li>
<li><code>undefined</code>：转为 <code>NaN</code>。</li>
<li><code>null</code>：转为 <code>0</code>。</li>
</ul>
</li>
<li><p><code>parseInt()</code> 方法：字符串转整数方法</p>
<ul>
<li>作用：第一，对浮点数进行取整操作；第二，将字符串转为整数数字。<ul>
<li>对数字取整功能，直接舍弃小数部分，只保留整数。</li>
<li>将字符串转为整数数字，也包含取整功能。</li>
</ul>
</li>
<li>字符串中，必须是纯数字字符串或者数字字符开头的字符串，才能转换为正常数字,且只取整数部分，如果不是数字打头的字符串，会转换为 <code>NaN</code>。</li>
</ul>
</li>
<li><p><code>parseFloat()</code> 方法：字符串转浮点数方法</p>
<ul>
<li>作用：将字符串转为浮点数数字。</li>
<li>要求：满足浮点数数字字符必须在字符串开始，如果不在开始返回值都是<code>NaN</code>。</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>工作中，利用变量接收 prompt() 语句返回的用户输入的数据，检测数据类型后，得到的字符串类型。</li>
<li>如果想要获取的是数字类型的数据，则需要先将得到的字符串转数字，避免出现字符串参与数学加法运算等。</li>
</ul>
</li>
</ul>
<h5 id="转换成布尔类型"><a href="#转换成布尔类型" class="headerlink" title="转换成布尔类型"></a>转换成布尔类型</h5><ul>
<li><code>Boolean(数据)</code> 方法<ul>
<li>转型函数 <code>Boolean()</code> 可以用于任何数据类型，将其他数据类型转为布尔类型的值。</li>
<li>转为 <code>false</code>：<code>NaN</code>、<code>0</code>、<code>&quot;&quot;空字符串</code>、<code>null</code>、<code>undefined</code></li>
<li>转为 <code>true</code> ：<code>非0非NaN数字</code>、<code>非空字符串</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript书写语法</title>
    <url>/2021/08/229dc9d88f44/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="JavaScript-的书写位置"><a href="#JavaScript-的书写位置" class="headerlink" title="JavaScript 的书写位置"></a><code>JavaScript </code>的书写位置</h3><ul>
<li><p>写在行内</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>写在 <code>html</code> 中的 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="title function_">alert</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>写在外部 <code>js</code> 文件中，在页面引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：引用外部 <code>js</code> 文件的 <code>&lt;script&gt;</code> 标签中不可以写 <code>JavaScript</code> 的代码，自定义的<code>JavaScript</code> 代码，需要书写在另一个新的 <code>&lt;script&gt;</code> 标签中。</li>
</ul>
</li>
</ul>
<h3 id="JavaScript-的注释"><a href="#JavaScript-的注释" class="headerlink" title="JavaScript 的注释"></a><code>JavaScript</code> 的注释</h3><ul>
<li><p><code>js</code> 注释分为两种：块级注释和单行注释。</p>
</li>
<li><p>块级注释：又叫做多行注释，作用范围是选中的多行，写作 <code>/**/</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="comment">/*这是一个多行注释</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        多行内容再浏览器中都不可见</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        注释范围是多行*/</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>单行注释：作用范围只有符号后面的一行，写作 <code>//</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="comment">//这是单行注释</span></span></span><br><span class="line"><span class="language-javascript">    	<span class="comment">//换行后就不能发生作用了</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>VSCode</code>快捷键</p>
<ul>
<li>单行注释：注释和解开注释都是 <code>ctrl+/</code></li>
<li>多行注释：<code>ctrl+shift+/</code></li>
</ul>
</li>
</ul>
<h3 id="alert-语句"><a href="#alert-语句" class="headerlink" title="alert 语句"></a><code>alert</code> 语句</h3><ul>
<li><code>alert</code>：警示、警告。</li>
<li>作用：在浏览器中弹出一个警示框，警示框的警示内容可以人为自定义。</li>
<li><code>alert</code> 语句是一个 <code>js</code> 内置好的功能（函数、方法），要想实现功能必须在 <code>alert</code> 关键字后面加小括号执行，自定义的内容需要传递给小括号内的参数，输出时参数位置的内容会出现 在弹框位置。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="title function_">alert</span>(<span class="string">&#x27;这是一个警示框&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>语法<ul>
<li><code>alert</code> 语句作为一个函数，如果要执行，必须在后面紧跟着添加小括号。</li>
<li><code>alert</code> 语句作为一个函数，小括号内部可以传递参数，根据数据类型不同，有不同的语法要求，例如文字内容（字符串）必须写在一对引号内部。</li>
<li>如果需要添加一对引号，要么是单引号，要么是双引号，不能一单一双。</li>
<li>所有的有特殊功能的符号必须是英文字符。</li>
<li>语句后面的分号必要性。</li>
<li><code>js</code> 对换行、缩进、空格也不敏感。<ul>
<li>如果 <code>js</code> 中没有特殊控制结构，代码都是从上往下、从左往右进行加载。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="prompt-语句"><a href="#prompt-语句" class="headerlink" title="prompt 语句"></a><code>prompt</code> 语句</h3><ul>
<li><p><code>prompt</code>：提示。</p>
</li>
<li><p>作用：弹出一个对话框，内部有一个提示语句以及一个输入框，可以在输入框中根据提示任意输入内容。</p>
</li>
<li><p><code>prompt</code> 语句也是 <code>js</code> 内置的一个功能，必须加小括号执行，有两个参数可以进行传递，每个参数一般都是字符串类型，必须加引号，两个参数中间用逗号分隔，引号和逗号都必须是英文输入法状态。</p>
</li>
<li><p><code>prompt(&quot;请输入您的年龄&quot;,&quot;18&quot;);</code></p>
<p><img src="https://pic.imgdb.cn/item/618a37c72ab3f51d9166b568.png"></p>
</li>
<li><p>第二个参数位置的值，可以删除并重新输入新的内容，甚至代码中可以不写第二个参数。</p>
</li>
<li><p><code>prompt(&quot;请输入您的年龄&quot;);</code></p>
<p><img src="https://pic.imgdb.cn/item/618a387b2ab3f51d9167cc2f.png"></p>
</li>
</ul>
<h3 id="console-控制台"><a href="#console-控制台" class="headerlink" title="console 控制台"></a><code>console</code> 控制台</h3><ul>
<li>在大部分浏览器中，都有一个控制台，内部可以查看 <code>HTML</code>、<code>css</code> 代码，甚至调试代码错误 。</li>
<li>浏览器中右键点击审查元素（检查），都可以打开控制台。</li>
<li>快捷键： <code>F12</code></li>
<li>控制台中有一个 <code>console</code>（控制台） 的选项面板，在 <code>js</code> 中有非常重要的作用。</li>
</ul>
<h3 id="浏览器的控制台"><a href="#浏览器的控制台" class="headerlink" title="浏览器的控制台"></a>浏览器的控制台</h3><ul>
<li>作用一：帮助程序员调试程序中出现的 <code>bug</code>。可以提示错误的个数、错误所在的行数、错误类型。</li>
<li>作用二：可以在控制台中直接书写一些语句，进行执行。</li>
<li>作用三：<code>js</code> 有一个内置对象 <code>console</code>，内部封装了大量的属性和方法（函数），可以通过给<code>console</code> 对象打点调用方法名()、属性名方式去执行。有一个叫做 <code>log</code>（日志）方法，可以 实现参数位置自定义内容在控制台输出。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2021/08/b1870e7b909c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="网页、网站和应用程序"><a href="#网页、网站和应用程序" class="headerlink" title="网页、网站和应用程序"></a>网页、网站和应用程序</h4><ul>
<li>网页：单独的一个页面</li>
<li>网站：一系列相关的页面组合到一起。</li>
<li>应用程序：可以和用户产生交互，并实现某种功能。</li>
</ul>
<h4 id="前端三层"><a href="#前端三层" class="headerlink" title="前端三层"></a>前端三层</h4><ul>
<li><code>HTML</code> 结构层 从语义的角度描述页面结构</li>
<li><code>css</code> 样式层 从美观的角度描述页面样式</li>
<li><code>JavaScript</code> 行为层 从交互的角度描述页面行为</li>
</ul>
<h4 id="JavaScript的应用场景"><a href="#JavaScript的应用场景" class="headerlink" title="JavaScript的应用场景"></a><code>JavaScript</code>的应用场景</h4><p><code>JavaScript</code>发展到现在几乎无所不能，常见的应用场景有</p>
<ul>
<li>网页特效</li>
<li>服务端开发(<code>Node.js</code>)</li>
<li>命令行工具(<code>Node.js</code>)</li>
<li>桌面程序(<code>Electron</code>)</li>
<li><code>App</code>(<code>Cordova</code>)</li>
<li>控制硬件-物联网(<code>Ruff</code>)</li>
<li>游戏开发(<code>cocos2d-js</code>)</li>
</ul>
<h3 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a><code>JavaScript</code>介绍</h3><h4 id="JavaScript是什么"><a href="#JavaScript是什么" class="headerlink" title="JavaScript是什么"></a><code>JavaScript</code>是什么</h4><ul>
<li><code>JavaScript</code> 是一种运行在客户端 的脚本语言 ，最早是在 <code>HTML</code>（标准通用标记语言下的一个应用）网页上使用，用来给 HTML 网页增加动态功能。</li>
<li>浏览器就是一种运行 <code>JavaScript</code> 脚本语言的客户端，<code>JavaScript</code> 的解释器被称为 <code>JavaScript</code> 引擎，为浏览器的一部分。</li>
</ul>
<h4 id="JavaScript-简史"><a href="#JavaScript-简史" class="headerlink" title="JavaScript 简史"></a><code>JavaScript</code> 简史</h4><ul>
<li>在 <code>WEB</code> 日益发展的同时，网页的大小和复杂性不断增加，受制于网速的限制，为完成简单的表单验证而频繁地与服务器交换数据只会加重用户的负担，当时走在技术革新最前沿的 <code>Netscape</code> （网景）公司，决定着手开发一种客户端语言，用来处理这种简单的验证。</li>
<li>1995 年，就职于 <code>Netscape</code> 公司的 <code>Brendan Eich</code>，开始着手为即将于 1996 年 2 月发布的 <code>Netscape Navigator 2</code> 浏览器开发一种名为 <code>LiveScript</code> 的脚本语言。为了尽快完成 <code>LiveScript</code> 的开发，<code>Netscape</code> 与 <code>Sun</code> 公司建立了一个开发联盟。在 <code>Netscape Navigator 2</code> 正式发布前夕，<code>Netscape</code> 为了搭上媒体热炒 <code>Java</code> 的顺风车，临时把 <code>LiveScript</code> 改名为 <code>JavaScript</code>。</li>
<li>由于 <code>JavaScript 1.0</code> 获得的关注度越来越高，1996 年，微软就在其 <code>Internet Explorer 3</code> 中加入了名为 <code>JScript</code> 的 <code>JavaScript</code> 实现，这意味着有了两个不同的 <code>JavaScript</code> 版本，导致 <code>JavaScript</code> 没有一个标准化的语法和特性。</li>
<li>1997 年，以 <code>JavaScript 1.1</code> 为蓝本的建议被提交给了欧洲计算机制造商协会（<code>ECMA</code>，<code>European Computer Manufacturers Association</code>）。该协会指定 39 号技术委员会（<code>TC39</code>，<code>Technical Committee #39</code>）负责“ 标准化一种通用、跨平台、供应商中立的脚本语言的语法和语义”。<code>TC39</code> 由来自 <code>Netscape</code>、<code>Sun</code>、微软、<code>Borland</code> 及其他关注脚本语言发展的公司的程序员组成，他们经过数月的努力完成了 <code>ECMA-262</code> 标准，定义一种名为 <code>ECMAScript</code> 的新脚本语言。</li>
</ul>
<h4 id="ECMAScript-发展过程"><a href="#ECMAScript-发展过程" class="headerlink" title="ECMAScript 发展过程"></a><code>ECMAScript</code> 发展过程</h4><p><img src="https://pic.imgdb.cn/item/618a10e62ab3f51d91378a85.png"></p>
<h4 id="ECMAScript-的应用"><a href="#ECMAScript-的应用" class="headerlink" title="ECMAScript 的应用"></a><code>ECMAScript</code> 的应用</h4><ul>
<li><code>Javscript</code>，<code>JScript</code>，<code>ActionScript</code> 等脚本语言都是基于 <code>ECMAScript</code> 标准实现的。</li>
<li>在 <code>JavaScript</code>，<code>JScript</code> 和 <code>ActionScript</code> 中声明变量，操作数组等语法完全一样，因为它们都是<code>ECMAScript</code>。但是在操作浏览器对象等方面又有各自独特的方法，这些都是各自语言的扩展。</li>
</ul>
<h4 id="JavaScript-的组成"><a href="#JavaScript-的组成" class="headerlink" title="JavaScript 的组成"></a><code>JavaScript</code> 的组成</h4><p><code>JavaScript</code> 是由 <code>ECMAScript</code>，<code>DOM</code> 和 <code>BOM</code> 三者组成的。</p>
<p><img src="https://pic.imgdb.cn/item/618a120b2ab3f51d913a0910.png"></p>
<h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><ul>
<li>软件<ul>
<li>应用软件：浏览器(<code>Chrome</code>/<code>IE</code>/<code>Firefox</code>)、<code>QQ</code>、<code>Sublime</code>、<code>Word</code></li>
<li>系统软件：<code>Windows</code>、<code>Linux</code>、<code>mac OS</code></li>
</ul>
</li>
<li>硬件<ul>
<li>三大件：<code>CPU</code>、内存、硬盘 – 主板</li>
<li>输入设备：鼠标、键盘、手写板、摄像头等</li>
<li>输出设备：显示器、打印机、投影仪等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Bootstrap</title>
    <url>/2021/08/8695d9c67314/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="Bootstrap简介"><a href="#Bootstrap简介" class="headerlink" title="Bootstrap简介"></a><code>Bootstrap</code>简介</h3><p><code>Bootstrap</code>来自<code>Twitter</code>（推特），是目前最受欢迎的前端框架。<code>Bootstrap</code>是基于<code>HTML</code>、<code>CSS</code>和<code>JavaScript</code>的，它简洁灵活，使得<code>Web</code>开发更加快捷。</p>
<ul>
<li><a href="http://www.bootcss.com/">中文官网</a></li>
<li><a href="http://getbootstrap.com/">官网</a></li>
</ul>
<p>框架：顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。</p>
<h3 id="Bootstrap优点"><a href="#Bootstrap优点" class="headerlink" title="Bootstrap优点"></a><code>Bootstrap</code>优点</h3><ul>
<li>标准化的<code>html</code>+<code>css</code>编码规范</li>
<li>提供了一套简洁、直观、强悍的组件</li>
<li>有自己的生态圈，不断的更新迭代</li>
<li>让开发更简单，提高了开发的效率</li>
</ul>
<h3 id="Bootstrap版本"><a href="#Bootstrap版本" class="headerlink" title="Bootstrap版本"></a><code>Bootstrap</code>版本</h3><ul>
<li><code>2.x.x</code>：停止维护，兼容性好，代码不够简洁，功能不够完善。</li>
<li><code>3.x.x</code>：目前使用最多，稳定，但是放弃了<code>IE6</code>-<code>IE7</code>。对<code>IE8</code>支持但是界面效果不好，偏向用于开发响应式布局、移动设备优先的<code>WEB</code>项目。</li>
<li><code>4.x.x</code>：最新版，目前还不是很流行</li>
</ul>
<h3 id="Bootstrap使用"><a href="#Bootstrap使用" class="headerlink" title="Bootstrap使用"></a><code>Bootstrap</code>使用</h3><ul>
<li><p>创建文件夹结构</p>
<p><img src="https://pic.imgdb.cn/item/617fb7022ab3f51d918e3f9f.png"></p>
</li>
<li><p>创建<code>html</code>骨架结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--要求当前网页使用IE浏览器最高版本的内核来渲染--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--视口的设置：视口的宽度和设备一致,默认的缩放比例和PC端一致,用户不能自行缩放--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,user-scalable=0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if It IE 9]&gt;</span></span><br><span class="line"><span class="comment">	&lt;!--解决ie9以下浏览器对html5新增标签的不识别,并导致CSS不起作用的问题--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--解决ie9以下浏览器对css3 Media Query的不识别--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://oss.maxcdn.com/respond/1.4.2/respond.minjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>引入相关样式文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Bootstrap核心样式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylrsheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;bootstrap/css/bootstrap.min.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>书写内容</p>
<ul>
<li>直接拿<code>Bootstrap</code>预先定义好的样式来使用</li>
<li>修改<code>Bootstrap</code>原来的样式，注意权重问题</li>
<li>学好<code>Bootstrap</code>的关键在于知道它定义了哪些样式，以及这些样式能实现什么样的效果</li>
</ul>
</li>
</ul>
<h3 id="Bootstrap布局容器"><a href="#Bootstrap布局容器" class="headerlink" title="Bootstrap布局容器"></a><code>Bootstrap</code>布局容器</h3><ul>
<li><code>Bootstrap</code>需要为页面内容和栅格系统包裹一个<code>.container</code>容器，它提供了两个作此用处的类。<ul>
<li><code>container</code>类<ul>
<li>响应式布局的容器</li>
<li>大屏（<code>&gt;=1200px</code>）宽度定为<code>1170px</code></li>
<li>中屏（<code>&gt;=992px</code>）宽度定为<code>970px</code></li>
<li>小屏（<code>&gt;=768px</code>）宽度定为<code>750px</code></li>
<li>超小屏（<code>100%</code>）</li>
</ul>
</li>
<li><code>container-fluid</code>类<ul>
<li>流式布局容器 百分百宽度</li>
<li>占据全部视口（<code>viewport</code>）的容器</li>
<li>适合于制作移动端页面开发</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Bootstrap栅格系统"><a href="#Bootstrap栅格系统" class="headerlink" title="Bootstrap栅格系统"></a><code>Bootstrap</code>栅格系统</h3><ul>
<li><p>简介</p>
<ul>
<li>栅格系统英文为”<code>grid systems</code>“，也有人翻译为“网格系统”，它是指将页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局。</li>
<li><code>Bootstrap</code>提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（<code>viewport</code>）尺寸的增加，系统会自动分为最多12列。</li>
</ul>
</li>
<li><p>栅格选项参数</p>
<ul>
<li>栅格系统用于通过一系列的行（<code>row</code>）与列（<code>column</code>）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>超小屏幕(手机)<br><code>&lt;768px</code></th>
<th>小屏设备(平板)<br/><code>&gt;=768px</code></th>
<th>中等屏幕(桌面显示器)<br/><code>&gt;=992px</code></th>
<th>宽屏设备(大桌面显示器)<br/><code>&gt;=1200px</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>.container</code>最大宽度</td>
<td>自动(<code>100%</code>)</td>
<td><code>750px</code></td>
<td><code>970px</code></td>
<td><code>1170px</code></td>
</tr>
<tr>
<td>类前缀</td>
<td><code>.col-xs-</code></td>
<td><code>.col-sm-</code></td>
<td><code>.col-md-</code></td>
<td><code>.col-lg-</code></td>
</tr>
<tr>
<td>列(<code>column</code>)</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
</tr>
</tbody></table>
<ul>
<li>按照不同屏幕换分为1~12等份</li>
<li>行（<code>row</code>）可以去除父容器作用<code>15px</code>的边距</li>
<li><code>xs</code>-<code>extra small</code>：超小；<code>sm</code>-<code>small</code>：小；<code>md</code>-<code>medium</code>：中等；<code>lg</code>-<code>large</code>：大；</li>
<li>列（<code>column</code>）大于12，多余的“列（<code>column</code>）”所在的元素将被视为一个整体另起一行排列</li>
<li>每一列默认有左右15像素的<code>padding</code></li>
<li>可以同时为一列指定多个设备的类名，以便划分不同份数，例如：<code>class=&quot;col-md-4 col-sm-6&quot;</code></li>
</ul>
</li>
<li><p>列嵌套</p>
<ul>
<li>栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再分成若干份小列。我们可以通过添加一个新的<code>.row</code>元素和一系列<code>.col-sm-*</code>元素到已经存在的<code>.col-sm-*</code>元素内。</li>
</ul>
</li>
<li><p>列偏移</p>
<ul>
<li>使用<code>.col-md-offset-*</code>类可以将列向右侧偏移。这些类实际是通过<code>*</code>选择器为当前元素增加了左侧的边距（<code>margin</code>）。</li>
</ul>
</li>
<li><p>列排序</p>
<ul>
<li>通过使用<code>.col-md-push-*</code>往右推和<code>.col-md-pull-*</code>往左拉两个类就可以很容易的改变列（<code>column</code>）的顺序。</li>
</ul>
</li>
</ul>
<h3 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h3><p>为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>超小屏</th>
<th>小屏</th>
<th>中屏</th>
<th>大屏</th>
</tr>
</thead>
<tbody><tr>
<td><code>.hidden-xs</code></td>
<td>隐藏</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td><code>.hidden-sm</code></td>
<td>可见</td>
<td>隐藏</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td><code>.hidden-md</code></td>
<td>可见</td>
<td>可见</td>
<td>隐藏</td>
<td>可见</td>
</tr>
<tr>
<td><code>.hidden-lg</code></td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>隐藏</td>
</tr>
</tbody></table>
<p>与之相反的，<code>visibe-xs</code>、<code>visibe-sm</code>、<code>visibe-md</code>、<code>visibe-lg</code>是针对不同设备显示某个内容。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>Less</title>
    <url>/2021/08/e72d4b15dd47/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="维护css的弊端"><a href="#维护css的弊端" class="headerlink" title="维护css的弊端"></a>维护<code>css</code>的弊端</h3><p><code>css</code>是一门非程序式语言，没有变量、函数、<code>SCOPE</code>（作用域）等概念</p>
<ul>
<li><code>CSS</code>需要书写大量看似没有逻辑的代码，<code>CSS</code>冗余度是比较高的。</li>
<li>不方便维护及拓展，不利于复用。</li>
<li><code>CSS</code>没有很好的计算能力</li>
<li>非前端开发工程师来讲，往往会因为缺少<code>CSS</code>编写经验而很难写出组织良好且易于维护的<code>CSS</code>代码项目</li>
</ul>
<h3 id="Less介绍"><a href="#Less介绍" class="headerlink" title="Less介绍"></a><code>Less</code>介绍</h3><ul>
<li><code>Less</code>（<code>Leaner Style Sheets</code>的缩写）是一门<code>CSS</code>扩展语言，也成为<code>CSS</code>预处理器</li>
<li>作为<code>CSS</code>的一种形式的扩展，它并没有减少<code>CSS</code>的功能，而是在现有的<code>CSS</code>语法上，为<code>CSS</code>假如程序式语言的特性</li>
<li>它在<code>CSS</code>的语法基础之上，引入了变量，<code>Minin</code>（混入），运算以及函数等功能，大大简化了<code>CSS</code>的编写，并且降低了<code>CSS</code>的维护成本，就像它的名称所说的那样，<code>Less</code>可以让我们用更少的代码做更多的事。</li>
<li><a href="http://lesscss.cn/"><code>Less</code>中文网址</a></li>
<li>常见的<code>CSS</code>预处理器：<code>Sass</code>、<code>Less</code>、<code>Stylus</code></li>
<li><code>Less</code>是一门<code>CSS</code>预处理语言，它扩展了<code>CSS</code>的动态特性</li>
</ul>
<h3 id="Less安装"><a href="#Less安装" class="headerlink" title="Less安装"></a><code>Less</code>安装</h3><ul>
<li>安装<code>nodejs</code>，可选择最新的版本，网址：<a href="https://nodejs.org/en/download/"><code>Node.js</code></a></li>
<li>检查是否安装成功，使用<code>cmd</code>命令（<code>win10</code>是<code>window</code>+<code>r</code>打开<code>运行</code>输入<code>cmd</code>）</li>
<li>输入<code>node -v</code>查看版本</li>
<li>基于<code>node.js</code>在线安装<code>Less</code>，使用<code>cmd</code>命令<code>npm install -g less</code>即可</li>
<li>检查是否安装成功，使用<code>cmd</code>命令<code>lessc -v</code>查看版本即可</li>
</ul>
<h3 id="Less使用"><a href="#Less使用" class="headerlink" title="Less使用"></a><code>Less</code>使用</h3><p>新建一个后缀名为<code>.less</code>的文件，在这个<code>.less</code>文件里面书写<code>Less</code>语句。</p>
<h4 id="Less变量"><a href="#Less变量" class="headerlink" title="Less变量"></a><code>Less</code>变量</h4><ul>
<li><p>变量是指没有固定的值，可以动态改变的。因为我们<code>CSS</code>中的一些颜色和数值等经常使用。</p>
</li>
<li><p><code>@变量名:值;</code></p>
</li>
<li><p>变量命名规范</p>
<ul>
<li>必须有<code>@</code>为前缀</li>
<li>不能包含特殊字符</li>
<li>不能以数字开头</li>
<li>大小写敏感</li>
</ul>
</li>
<li><p>变量使用规范</p>
<ul>
<li>```less<br>@color: pink;<br>// 直接使用<br>body {<br>  color: @color;<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### `Less`编译</span><br><span class="line"></span><br><span class="line">- 本质上，`Less`包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的`CSS`文件。</span><br><span class="line">- 所以我们需要把我们的`.less`文件，编译生成为`.css`文件，这样我们的`html`页面才能使用。</span><br><span class="line">- 推荐方法（`nodejs`）：在当前文件夹，使用`cmd`命令&quot;`less style.less&gt;style.css`&quot;</span><br><span class="line"></span><br><span class="line">#### `VScode Less`插件</span><br><span class="line"></span><br><span class="line">- `Easy LESS`插件用来把`less`文件编译为`css`文件</span><br><span class="line">- 安装完毕插件，重新加载下`vscode`</span><br><span class="line">- 只要保存一下`Less`文件，会自动生成`CSS`文件</span><br><span class="line"></span><br><span class="line">#### `Less`嵌套</span><br><span class="line"></span><br><span class="line">- 常规`CSS`选择器</span><br><span class="line"></span><br><span class="line">  - ```css</span><br><span class="line">    #header .logo &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Less</code>嵌套写法</p>
<ul>
<li><p>```less<br>#header {</p>
<pre><code>.logo &#123;
    width: 300px;
&#125;
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如果遇见（交集|伪类|伪元素选择器）</span><br><span class="line"></span><br><span class="line">  - 内层选择器的前面没有`&amp;`符号，则它被解析为父选择器的后代；</span><br><span class="line"></span><br><span class="line">  - 如果有`&amp;`符号，它就被解析为父元素自身或父元素的伪类。</span><br><span class="line"></span><br><span class="line">  - 常规`CSS`选择器</span><br><span class="line"></span><br><span class="line">    - ```css</span><br><span class="line">      a:hover &#123;</span><br><span class="line">          color: red;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Less</code>嵌套写法</p>
<ul>
<li><pre><code class="less">a &#123;
    &amp;:hover &#123;
        color: red;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Less运算"><a href="#Less运算" class="headerlink" title="Less运算"></a><code>Less</code>运算</h4><ul>
<li>任何数字、颜色或者变量都可以参与运算。<code>Less</code>提供了加（<code>+</code>）、减（<code>-</code>）、乘（<code>*</code>）、除（<code>/</code>）算术运算。</li>
<li>注意<ul>
<li>乘号（<code>*</code>）和除号（<code>/</code>）的写法</li>
<li>对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位</li>
<li>如果两个值之间只有一个值有单位，则运算结果就取该单位</li>
<li><code>运算符中间左右有个空格隔开1px+5rem</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>移动Web布局</title>
    <url>/2021/08/79ce30c12007/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="流式布局（百分比布局）"><a href="#流式布局（百分比布局）" class="headerlink" title="流式布局（百分比布局）"></a>流式布局（百分比布局）</h3><ul>
<li>流式布局，就是百分比布局，也称非固定像素布局</li>
<li>通过将盒子的宽度设置成百分比，从而根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充</li>
<li>流式布局方式是移动web开发使用的比较常见</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>制作过程中，需要定义页面的最大和最小支持宽度</p>
<ul>
<li><code>max-width</code> 最大宽度 （<code>max-height</code> 最大高度）</li>
<li><code>min-width</code> 最小宽度 （<code>min-height</code> 最小高度）</li>
</ul>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a><code>flex</code>布局</h3><h4 id="传统布局与flex布局"><a href="#传统布局与flex布局" class="headerlink" title="传统布局与flex布局"></a>传统布局与<code>flex</code>布局</h4><ul>
<li><p>传统布局</p>
<ul>
<li>兼容性好</li>
<li>布局繁琐</li>
<li>局限性，不能再移动端很好的布局</li>
</ul>
</li>
<li><p><code>flex</code>布局</p>
<ul>
<li>操作方便，布局极为简单，移动端应用广泛</li>
<li><code>PC</code>端浏览器支持情况较差</li>
<li><code>IE11</code>或更低版本，不支持或仅部分支持</li>
</ul>
</li>
<li><p>建议</p>
<ul>
<li>如果是<code>PC</code>端页面布局，考虑传统布局</li>
<li>如果师移动端或者不考虑兼容性问题的<code>PC</code>端页面布局，我们还是使用<code>flex</code>弹性布局</li>
</ul>
</li>
</ul>
<h4 id="flex布局原理"><a href="#flex布局原理" class="headerlink" title="flex布局原理"></a><code>flex</code>布局原理</h4><ul>
<li>采用<code>Flex</code>布局的元素，称为<code>Flex</code>容器（<code>flex container</code>），简称“容器”。它的所有子元素自动称为容器成员，称为<code>Flex</code>项目（<code>flex item</code>），简称“项目”。</li>
<li>项目可以横向排列也可以纵向排列</li>
<li>通过给容器添加<code>flex</code>属性，来控制项目的位置和排列方式</li>
</ul>
<h4 id="flex布局常见属性"><a href="#flex布局常见属性" class="headerlink" title="flex布局常见属性"></a><code>flex</code>布局常见属性</h4><h5 id="父项常见属性"><a href="#父项常见属性" class="headerlink" title="父项常见属性"></a>父项常见属性</h5><ul>
<li><p><code>flex-direction</code>：设置主轴的方向</p>
<ul>
<li><p>主轴和侧轴</p>
<ul>
<li>在<code>flex</code>布局中，是分为主轴和侧轴两个方向，同样的叫法有：行和列、<code>x</code>轴和<code>y</code>轴</li>
<li>默认主轴方向就是<code>x</code>轴方向，水平向右</li>
<li>默认侧轴方向就是<code>y</code>轴方向，垂直向下</li>
</ul>
</li>
<li><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）</p>
</li>
<li><p>注意：主轴和侧轴是会变化的，就看<code>flex-direction</code>设置谁为主轴，剩下的就是侧轴。而子元素是跟着主轴来排列的。</p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>row</code>（默认值）</td>
<td>从左到右</td>
</tr>
<tr>
<td><code>row-reverse</code></td>
<td>从右到左</td>
</tr>
<tr>
<td><code>column</code></td>
<td>从上到下</td>
</tr>
<tr>
<td><code>column-reverse</code></td>
<td>从下到上</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>justify-content</code>：设置主轴上的子元素排列方式</p>
<ul>
<li><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式</p>
</li>
<li><p>注意：使用这个属性之前一定要确定好主轴是哪个</p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flex-start</code>（默认值）</td>
<td>从头部开始，如果主轴是<code>x</code>轴，则从左到右</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>从尾部开始排列</td>
</tr>
<tr>
<td><code>center</code></td>
<td>在主轴居中对齐（如果主轴是<code>x</code>轴则 水平居中）</td>
</tr>
<tr>
<td><code>space-around</code></td>
<td>平分剩余空间</td>
</tr>
<tr>
<td><code>space-between</code></td>
<td>先两边贴边，再平分剩余空间（重要）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>flex-wrap</code>：设置子元素是否换行</p>
<ul>
<li><p>默认情况下，项目都排列再一条线（又称“轴线”）上</p>
</li>
<li><p><code>flex-wrap</code>属性定义，<code>flex</code>布局中默认是不换行的。</p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>nowrap</code>（默认值）</td>
<td>不换行</td>
</tr>
<tr>
<td><code>wrap</code></td>
<td>换行</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>align-content</code>：设置侧轴上的子元素的排列方式（多行）</p>
<ul>
<li><p>设置子项在侧轴上的排列方式，并且只能用于子项出现<code>换行</code>的情况（多行），在单行下是没有效果的。</p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flex-start</code></td>
<td>在侧轴的头部开始排列</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>在侧轴的尾部开始排列</td>
</tr>
<tr>
<td><code>center</code></td>
<td>在侧轴中间显示</td>
</tr>
<tr>
<td><code>space-around</code></td>
<td>子项在侧轴平分剩余空间</td>
</tr>
<tr>
<td><code>space-between</code></td>
<td>子项在侧轴先分布在两头，再平分剩余空间</td>
</tr>
<tr>
<td><code>stretch</code>（默认值）</td>
<td>设置子项元素高度平分父元素高度</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>align-items</code>：设置侧轴上的子元素排列方式（单行）</p>
<ul>
<li><p>该属性是控制子项再侧轴（默认是<code>y</code>轴）上的排列方式</p>
</li>
<li><p>在子项为单项（单行）的时候使用</p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flex-start</code></td>
<td>从上到下</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>从下到上</td>
</tr>
<tr>
<td><code>center</code></td>
<td>挤在一起居中（垂直居中）</td>
</tr>
<tr>
<td><code>stretch</code>（默认值）</td>
<td>拉伸</td>
</tr>
</tbody></table>
</li>
<li><p><code>align-items</code>和<code>align-content</code>区别</p>
<ul>
<li><code>align-items</code>适用于单行情况下，只有上对齐、下对齐、居中和拉伸</li>
<li><code>align-content</code>适用于换行（多行）的情况下（单行情况下无效），可以设置上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</li>
<li>总结：单行找<code>align-items</code>，多行找<code>align-content</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>flex-flow</code>：复合属性，相当于同时设置了<code>flex-direction</code>和<code>flex-wrap</code></p>
<ul>
<li><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>属性的复合属性</li>
<li><code>flex-flow: row nowrap;</code></li>
</ul>
</li>
</ul>
<h5 id="子项常见属性"><a href="#子项常见属性" class="headerlink" title="子项常见属性"></a>子项常见属性</h5><ul>
<li><code>flex</code> 子项目占的份数<ul>
<li><code>flex</code>属性定义子项目分配父盒子的剩余空间，用<code>flex</code>来表示占多少份数</li>
<li>属性值为数字，数字为1，表示占总份数中的1份。默认值为0。</li>
</ul>
</li>
<li><code>align-self</code> 控制子项自己在侧轴的排列方式<ul>
<li><code>align-self</code> 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。</li>
<li>默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code></li>
</ul>
</li>
<li><code>order</code> 属性定义子项的排列顺序（前后顺序）<ul>
<li>数值越小，排列越靠前，默认为0。</li>
<li>注意：和<code>z-index</code>不一样</li>
</ul>
</li>
</ul>
<h3 id="rem适配布局"><a href="#rem适配布局" class="headerlink" title="rem适配布局"></a><code>rem</code>适配布局</h3><h4 id="rem单位"><a href="#rem单位" class="headerlink" title="rem单位"></a><code>rem</code>单位</h4><ul>
<li><code>rem</code>（<code>root em</code>）是一个相对单位，类似于<code>em</code>，<code>em</code>是父元素字体大小。</li>
<li>不同的是<code>rem</code>的基准是相对于<code>&lt;html&gt;</code>元素的字体大小。</li>
<li>比如，根元素（<code>html</code>）设置<code>font-size=12px;</code>非根元素设置<code>width:2rem;</code>转换成<code>px</code>表示就是<code>24px</code>。</li>
<li><code>rem</code>的优势：父元素文字大小可能不一致，但是整个页面只有一个<code>&lt;html&gt;</code>，可以很好的来控制整个页面的元素大小比例。</li>
</ul>
<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><ul>
<li><p>媒体查询（<code>Media Query</code>）是<code>CSS3</code>新语法。</p>
<ul>
<li>使用<code>@media</code>查询，可以针对不同的媒体类型定义不同的样式</li>
<li><code>@media</code>可以针对不同的屏幕尺寸设置不同的样式</li>
<li>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面</li>
<li>目前针对很多苹果手机、<code>Android</code>手机、平板等设备都用的到多媒体查询</li>
</ul>
</li>
<li><p>语法规范</p>
<ul>
<li>用<code>@media</code>开头，注意<code>@</code>符号</li>
<li><code>mediatype</code>媒体查询</li>
<li>关键字 <code>and</code> <code>not</code> <code>only</code></li>
<li><code>media feature</code> 媒体特性，必须有小括号包含</li>
</ul>
</li>
<li><p><code>mediatype</code>媒体查询</p>
<ul>
<li><p>将不同的终端设备划分成不同的类型，称为媒体类型</p>
</li>
<li><table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>all</code></td>
<td>用于所有设备</td>
</tr>
<tr>
<td><code>print</code></td>
<td>用于打印机和打印预览</td>
</tr>
<tr>
<td><code>screen</code></td>
<td>用于电脑屏幕，平板电脑，智能手机等</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件。</p>
<ul>
<li><code>and</code>：可以将多个媒体特性连接到一起，相当于“且”的意思</li>
<li><code>not</code>：排除某个媒体类型，相当于“非”的意思，可以省略</li>
<li><code>or</code>：可以测试多个媒体查询的条件，只要有一个条件成立，就执行，“或”的意思</li>
<li><code>only</code>：指定某个特定的媒体类型，可以省略。</li>
</ul>
</li>
<li><p>媒体特性</p>
<ul>
<li><p>每种媒体类型都具有各自不同的特性，根据不同类型的媒体特性设置不同的展示风格</p>
</li>
<li><p>这里只展示三个</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>width</code></td>
<td>定义输出设备中页面可见区域的宽度</td>
</tr>
<tr>
<td><code>min-width</code></td>
<td>定义输出设备中页面最小可见区域宽度</td>
</tr>
<tr>
<td><code>max-width</code></td>
<td>定义输出设备中页面最大可见区域宽度</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>媒体查询+<code>rem</code>实现元素动态大小变化</p>
<ul>
<li><code>rem</code>单位是跟着<code>&lt;html&gt;</code>来走的，有了<code>rem</code>页面元素可以设置不同大小尺寸</li>
<li>媒体查询可以根据不同设备宽度来修改样式</li>
<li>媒体查询+<code>rem</code>就可以实现不同设备宽度，实现页面元素大小的动态变化</li>
</ul>
</li>
</ul>
<h4 id="引入资源"><a href="#引入资源" class="headerlink" title="引入资源"></a>引入资源</h4><ul>
<li><p>当样式比较繁多的时候，我们可以针对不同的媒体使用不同的<code>stylesheets</code>（样式表）</p>
</li>
<li><p>原理，就是直接在<code>&lt;link&gt;</code>中判断设备的尺寸，然后引用不同的<code>css</code>文件。</p>
</li>
<li><p>语法规范</p>
<ul>
<li><pre><code class="html">&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><code>rem</code>适配方案</p>
<ul>
<li><p><code>rem</code>实际开发适配方案</p>
<ul>
<li>按照设计稿与设备宽度的比例，动态计算并设置<code>html</code>根标签<code>font-size</code>大小；（媒体查询）</li>
<li><code>CSS</code>中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为<code>rem</code>为单位的值。</li>
</ul>
</li>
<li><p><code>rem</code>适配方案技术使用（市场主流）</p>
<ul>
<li><p>技术方案1</p>
<ul>
<li><code>less</code></li>
<li>媒体查询</li>
<li><code>rem</code></li>
</ul>
</li>
<li><p>技术方案2</p>
<ul>
<li><code>flexble.js</code></li>
<li><code>rem</code></li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>两种方案现在都存在</li>
<li>方案2更简单</li>
</ul>
</li>
<li><p>技术方案1实际开发</p>
<ul>
<li><p>设计稿常见尺寸宽度</p>
<p><img src="https://pic.imgdb.cn/item/617f8e6e2ab3f51d916bfd90.png"></p>
<p>一般情况下，我们以一套或两套效果图适应大部分的屏幕，放弃极端屏或对其优雅降级，牺牲一些效果，<code>现在基本以750为准</code>。</p>
</li>
<li><p>动态设置<code>html</code>标签<code>font-size</code>大小</p>
<ul>
<li>假设设计稿是<code>750px</code></li>
<li>假设我们把整个屏幕划分为15等份（划分标准不一，可以是20等份也可以是10等份）</li>
<li>每一份作为<code>html</code>字体大小，这里就是<code>50px</code></li>
<li>那么在<code>320px</code>设备的时候，字体大小为320/15就是<code>21.33px</code></li>
<li>那我们页面元素的大小除以不同的<code>html</code>字体大小会发现他们比例还是相同的，比如我们以750为标准设计稿<ul>
<li>一个<code>100*100</code>像素的页面元素在750屏幕下，就是100/50转换为<code>rem</code>是<code>2rem*2rem</code>比例是1比1</li>
<li>320屏幕下，<code>html</code>字体大小为21.33则<code>2rem=42.66px</code>，此时宽和高都是42.66但是宽和高的比例还是1比1</li>
<li>但是已经能实现不同屏幕下页面元素盒子等比例缩放的效果</li>
</ul>
</li>
</ul>
</li>
<li><p>元素大小取值方法</p>
<ul>
<li>最后的公式：页面元素的<code>rem</code>值=页面元素值（<code>px</code>）/（屏幕宽度/划分的份数）</li>
<li>屏幕宽度/划分的份数就是<code>html font-size</code>的大小</li>
<li>或者：页面元素的<code>rem</code>值=页面元素值（<code>px</code>）/<code>html font-size</code>字体大小</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h4><ul>
<li><p>响应式开发原理</p>
<ul>
<li><p>就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。</p>
</li>
<li><table>
<thead>
<tr>
<th>设备划分</th>
<th>尺寸区间</th>
</tr>
</thead>
<tbody><tr>
<td>超小屏幕（手机）</td>
<td><code>&lt;768px</code></td>
</tr>
<tr>
<td>小屏设备（平板）</td>
<td><code>&gt;=768px</code>~`&lt;992px`</td>
</tr>
<tr>
<td>中等屏幕（桌面显示器）</td>
<td><code>&gt;=992px</code>~`&lt;1200px`</td>
</tr>
<tr>
<td>宽屏设备（大桌面显示器）</td>
<td><code>&gt;=1200px</code></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>响应式布局容器</p>
<ul>
<li>响应式需要一个父级作为布局容器，来配合子级元素来实现变化效果</li>
<li>原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</li>
<li>平时我们的相应尺寸划分<ul>
<li>超小屏幕（手机，小于<code>768px</code>）：设置宽度为<code>100%</code></li>
<li>小屏幕（平板，大于等于<code>768px</code>）：设置宽度为<code>750px</code></li>
<li>中等屏幕（桌面显示器，大于等于<code>992px</code>）：设置宽度为<code>970px</code></li>
<li>大屏幕（大桌面显示器，大于等于<code>1200px</code>）：设置宽度为<code>1170px</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>移动端技术选型<ul>
<li>流式布局（百分比布局）</li>
<li><code>flex</code>弹性布局（推荐）</li>
<li><code>rem</code>适配布局（推荐）</li>
<li>响应式布局</li>
</ul>
</li>
<li>建议：我们选取一种主要技术选型，其他技术作为辅助，这种混合技术开发</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>移动Web开发</title>
    <url>/2021/08/7ff18ad25f7c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="浏览器现状"><a href="#浏览器现状" class="headerlink" title="浏览器现状"></a>浏览器现状</h3><ul>
<li><p><code>PC</code>端常见的浏览器</p>
<ul>
<li>360浏览器、谷歌浏览器、火狐浏览器、<code>QQ</code>浏览器、百度浏览器、搜狗浏览器、<code>IE</code>浏览器</li>
</ul>
</li>
<li><p>移动端常见的浏览器</p>
<ul>
<li><code>UC</code>浏览器、<code>QQ</code>浏览器、欧朋浏览器、百度手机浏览器、360安全浏览器、谷歌浏览器、搜狗手机浏览器、猎豹浏览器、以及其他杂牌浏览器。</li>
</ul>
</li>
<li><p>国内的<code>UC</code>和<code>QQ</code>，百度等手机浏览器都是根据<code>Webkit</code>修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于<code>Android</code>修改开发的一样。</p>
</li>
<li><p>总结，兼容移动端主流浏览器，处理 <code>Webkit</code>内核浏览器即可。</p>
</li>
</ul>
<h3 id="手机屏幕现状"><a href="#手机屏幕现状" class="headerlink" title="手机屏幕现状"></a>手机屏幕现状</h3><ul>
<li>移动端设备屏幕尺寸非常多，碎片化严重。</li>
<li><code>Android</code>设备有多种分辨率：480×800，480×854，540×960，720×1280，1080×1920等，还有传说中的<code>2K</code>，<code>4k</code>屏</li>
<li>近年来 <code>iPhone</code>的碎片化也加剧了，其设备的主要分辨率有：640×960，640×1136，750×1334，1242×2208等。</li>
<li>作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是<code>px</code>。</li>
</ul>
<h4 id="常见移动端屏幕尺寸"><a href="#常见移动端屏幕尺寸" class="headerlink" title="常见移动端屏幕尺寸"></a>常见移动端屏幕尺寸</h4><p><img src="https://pic.imgdb.cn/item/617689e42ab3f51d9105fa8e.png"></p>
<h4 id="移动端调试方法"><a href="#移动端调试方法" class="headerlink" title="移动端调试方法"></a>移动端调试方法</h4><ul>
<li><code>Chrome DevTools</code>（谷歌浏览器）的模拟手机调试</li>
<li>搭建本地<code>web</code>服务器，手机和服务器一个局域网内，通过手机访问服务器。</li>
<li>使用外网服务器，直接<code>IP</code>或域名访问</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>移动端浏览器我们主要对<code>webkit</code>内核进行兼容</li>
<li>我们现在开发的移动端主要针对手机端开发</li>
<li>现在移动端碎片化比较严重，分辨率和屏幕尺寸大小不一</li>
<li>学会用谷歌浏览器模拟手机界面以及调试</li>
</ul>
<h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p><code>视口(viewport)</code>就是浏览器显示页面内容的屏幕区域。视口可以分为布局视口、视觉视口和理想视口。</p>
<h4 id="布局视口-layout-viewport"><a href="#布局视口-layout-viewport" class="headerlink" title="布局视口 layout viewport"></a>布局视口 <code>layout viewport</code></h4><ul>
<li>一般移动设备的浏览器都默认设置了—个布局视口，用于解决早期的PC端页面在手机上显示的问题。</li>
<li><code>ios</code>，<code>Android</code>基本都将这个视口分辨率设置为<code>980px</code>，所以<code>PC</code>上的网页大多都能在手机<br>上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。</li>
</ul>
<h4 id="视觉视口-visual-viewport"><a href="#视觉视口-visual-viewport" class="headerlink" title="视觉视口 visual viewport"></a>视觉视口 <code>visual viewport</code></h4><ul>
<li>字面意思，它是用户正在看到的网站的区域。注意：<code>是网站的区域</code>.</li>
<li>我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。</li>
</ul>
<h4 id="理想视口-ideal-viewport"><a href="#理想视口-ideal-viewport" class="headerlink" title="理想视口 ideal viewport"></a>理想视口 <code>ideal viewport</code></h4><ul>
<li>为了使网站在移动端又最理想的浏览和阅读宽度而设定</li>
<li>理想视口，对设备来讲，使最理想的视口尺寸</li>
<li>需要手动填写<code>&lt;meta&gt;</code>视口标签通知浏览器操作</li>
<li><code>&lt;meta&gt;</code>视口标签的主要目的：<code>布局视口的宽度应该与理想视口的宽度一直，简单理解就是设备有多宽，我们布局的视口就多宽</code></li>
</ul>
<h4 id="lt-meta-gt-视口标签"><a href="#lt-meta-gt-视口标签" class="headerlink" title="&lt;meta&gt;视口标签"></a><code>&lt;meta&gt;</code>视口标签</h4><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</code></p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">解释说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>width</code></td>
<td align="left">宽度设置的使<code>viewport</code>宽度，可以设置<code>device-width</code>特殊值</td>
</tr>
<tr>
<td align="center"><code>initial-scale</code></td>
<td align="left">初始缩放比，大于0的数字</td>
</tr>
<tr>
<td align="center"><code>maximun-scale</code></td>
<td align="left">最大缩放比，大于0的数字</td>
</tr>
<tr>
<td align="center"><code>minimun-scale</code></td>
<td align="left">最小缩放比，大于0的数字</td>
</tr>
<tr>
<td align="center"><code>user-scalable</code></td>
<td align="left">用户是否可以缩放，<code>yes</code>或<code>no</code>（1或0）</td>
</tr>
</tbody></table>
<h4 id="标准的viewport参数设置"><a href="#标准的viewport参数设置" class="headerlink" title="标准的viewport参数设置"></a>标准的<code>viewport</code>参数设置</h4><ul>
<li>视口宽度和设备保持一致</li>
<li>视口的默认缩放比例1.0</li>
<li>不允许用户自行缩放</li>
<li>最大允许的缩放比例1.0</li>
<li>最小允许的缩放比例1.0</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li>视口就是浏览器显示页面内容的屏幕区域</li>
<li>视口分为布局视口、视觉视口和理想视口</li>
<li>移动端布局想要的是理想视口就是手机屏幕有多宽，布局视口就有多宽</li>
<li>想要理想视口，需要给移动端页面添加<code>&lt;meta&gt;</code>视口标签</li>
</ul>
<h3 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h3><h4 id="物理像素-amp-物理像素比"><a href="#物理像素-amp-物理像素比" class="headerlink" title="物理像素&amp;物理像素比"></a>物理像素&amp;物理像素比</h4><ul>
<li>物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了，比如<code>苹果6\7\8</code>是<code>750*1334</code></li>
<li>我们开发的时候的<code>1px</code>不是一定等于1个物理像素的</li>
<li><code>PC</code>端页面，<code>1px</code>是等于1个物理像素的，但是移动端就不尽相同</li>
<li>一个<code>px</code>的能显示的物理像素点的个数，称为物理像素比或屏幕像素比</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/617773ec2ab3f51d91a99862.png"></p>
<ul>
<li><code>PC</code>端和早前的手机屏幕/普通手机屏幕：<code>1CSS像素</code>=<code>1物理像素</code></li>
<li><code>Retina</code>（视网膜屏幕）是一种显示技术，可以将更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度</li>
</ul>
<h3 id="多倍图"><a href="#多倍图" class="headerlink" title="多倍图"></a>多倍图</h3><ul>
<li>对于一张<code>50px*50px</code>的图片，在手机<code>Retina</code>屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊</li>
<li>再标准的<code>viewport</code>设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题</li>
<li><code>通常使用二倍图</code>，因为<code>iPhone6\7\8</code>的影响，但是现在还存在3倍图4倍图的情况，这个看实际开发公司需求</li>
<li>背景图片注意缩放问题</li>
</ul>
<h3 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h3><h4 id="单独制作移动端页面（主流）"><a href="#单独制作移动端页面（主流）" class="headerlink" title="单独制作移动端页面（主流）"></a>单独制作移动端页面（主流）</h4><ul>
<li>常见网页<ul>
<li>京东商城手机版</li>
<li>淘宝触屏版</li>
<li>苏宁易购手机版</li>
<li>携程手机版</li>
</ul>
</li>
<li>通常情况下，网址域名前面加<code>m(mobile)</code>可以打开移动端。通过判断设备，如果是移动设备打开，则跳到<code>移动端页面</code>。</li>
</ul>
<h4 id="响应式页面兼容移动端（其次）"><a href="#响应式页面兼容移动端（其次）" class="headerlink" title="响应式页面兼容移动端（其次）"></a>响应式页面兼容移动端（其次）</h4><ul>
<li>常见网页<ul>
<li>三星手机官网</li>
</ul>
</li>
<li>响应式网站：即<code>PC</code>和移动端共用一套网站，只不过在不同宽度的屏幕下，样式会自动适配。</li>
<li>三星电子官网：<code>www.samsung.com/cn/</code>，通过判断屏幕宽度来改变样式，以适应不同终端。</li>
<li>缺点：<code>制作麻烦</code>，需要花很大精力去<code>调兼容性问题</code>。</li>
</ul>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li>现在市场常见的移动端开发有<code>单独制作移动端页面</code>和<code>响应式页面</code>两种方案</li>
<li>现在市场主流的选择还是<code>单独制作移动端页面</code></li>
</ul>
<h3 id="移动端技术解决方案"><a href="#移动端技术解决方案" class="headerlink" title="移动端技术解决方案"></a>移动端技术解决方案</h3><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><ul>
<li>移动端浏览器基本以<code>webkit</code>内核为主，因此我们就考虑<code>webkit</code>兼容性问题。</li>
<li>我们可以放心使用<code>H5</code>标签和<code>CSS3</code>样式。</li>
<li>同时我们浏览器的私有前缀我们只需要考虑添加<code>-webkit-</code>即可</li>
</ul>
<h4 id="CSS初始化normalize-css"><a href="#CSS初始化normalize-css" class="headerlink" title="CSS初始化normalize.css"></a><code>CSS</code>初始化<code>normalize.css</code></h4><ul>
<li><p>移动端<code>CSS</code>初始化推荐使用<code>normalize.css</code></p>
</li>
<li><p>优点</p>
<ul>
<li>保护了有价值的默认值</li>
<li>修复了浏览器的<code>bug</code></li>
<li>是模块化的</li>
<li>拥有详细的文档</li>
</ul>
</li>
<li><p>官网地址：<a href="http://necolas.github.io/normalize.css/"><code>normalize.css</code></a></p>
</li>
</ul>
<h4 id="CSS3盒子模型box-sizing"><a href="#CSS3盒子模型box-sizing" class="headerlink" title="CSS3盒子模型box-sizing"></a><code>CSS3</code>盒子模型<code>box-sizing</code></h4><ul>
<li>传统模式宽度计算：<code>盒子的宽度</code>=<code>CSS中设置的width</code>+<code>border</code>+<code>padding</code></li>
<li><code>CSS3</code>盒子模型：<code>盒子的宽度</code>=<code>CSS中设置的宽度width</code>（里面包含了<code>border</code>和<code>padding</code>）</li>
<li>也就是说，<code>CSS3</code>中的盒子模型，<code>padding</code>和<code>border</code>不会撑大盒子了</li>
<li>选择<ul>
<li>移动端可以全部使用<code>CSS3盒子模型</code></li>
<li><code>PC</code>端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择<code>CSS3</code>盒子模型</li>
</ul>
</li>
</ul>
<h4 id="特殊样式"><a href="#特殊样式" class="headerlink" title="特殊样式"></a>特殊样式</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*CSS3盒子模型*/</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">-webkit-<span class="attribute">box-sizing</span>: border-box;</span><br><span class="line"><span class="comment">/*点击高亮我们需要清除清除设置为transparent完成透明*/</span></span><br><span class="line">-webkit-tap-highlight-<span class="attribute">color</span>: transparent;</span><br><span class="line"><span class="comment">/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/</span></span><br><span class="line">-webkit-appearance: none;</span><br><span class="line"><span class="comment">/*禁用长按页面时的弹出菜单*/</span></span><br><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">a</span> &#123;</span><br><span class="line">  -webkit-touch-callout: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="移动端技术选型"><a href="#移动端技术选型" class="headerlink" title="移动端技术选型"></a>移动端技术选型</h3><h4 id="单独制作移动页面（主流）"><a href="#单独制作移动页面（主流）" class="headerlink" title="单独制作移动页面（主流）"></a>单独制作移动页面（主流）</h4><ul>
<li>流式布局（百分比布局）</li>
<li><code>flex</code>弹性布局（强烈推荐）</li>
<li><code>less</code>+<code>rem</code>+媒体查询布局</li>
<li>混合布局</li>
</ul>
<h4 id="响应式页面兼容移动端（其次）-1"><a href="#响应式页面兼容移动端（其次）-1" class="headerlink" title="响应式页面兼容移动端（其次）"></a>响应式页面兼容移动端（其次）</h4><ul>
<li>媒体查询</li>
<li><code>bootstrap</code></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>PC静态网页开发</title>
    <url>/2021/08/deed219e1457/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h3><p><img src="https://pic.imgdb.cn/item/617629b12ab3f51d91c00b81.png"></p>
<h3 id="版心"><a href="#版心" class="headerlink" title="版心"></a>版心</h3><ul>
<li>阅读报纸时我们会发现，虽然其中内容很多很丰富，但是经过合理的排版布局，版面整体依然清晰、易读。</li>
<li>同样，在制作网页过程中，如果要让页面结构清晰、有条理，也需要对网页内容进行“排版”。</li>
<li>版心:是指网页中主要内容所在的区域。一般在浏览器窗口中水平居中显示，从而让用户的视线更集中。</li>
<li>常见的版心宽度值包括<code>960px</code>、<code>980px</code>、<code>1000px</code>、<br><code>1200px</code>等。</li>
<li>制作方法:使用标准流中的<code>margin</code>居中方法。</li>
</ul>
<h3 id="页面布局流程"><a href="#页面布局流程" class="headerlink" title="页面布局流程"></a>页面布局流程</h3><p>为了高网页制作的效率，布局时通常要遵守一定的布局流程，具体如下:</p>
<ul>
<li>确定页面的版心(可视区域)。</li>
<li>分析页面中的行模块，以及每个行模块中的列模块。</li>
<li>制作<code>HTML</code>页面，<code>CSS</code>文件。</li>
<li><code>CSS</code>初始化，然后开始运用盒子模型的原理，通过<code>DIV</code>+<code>CSS</code>布局来控制网页的各个模块。</li>
</ul>
<h3 id="常见的布局类型"><a href="#常见的布局类型" class="headerlink" title="常见的布局类型"></a>常见的布局类型</h3><ul>
<li>一列固定宽度且居中</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6176487d2ab3f51d91d5e96d.png"></p>
<ul>
<li>两列左窄右宽</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6176487d2ab3f51d91d5e977.png"></p>
<ul>
<li>通栏平均分布型</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/6176487d2ab3f51d91d5e985.png"></p>
<ul>
<li>更多的情况，一个网页中可能同时包括2种以上的布局类型。</li>
</ul>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul>
<li><p>网站中会包含多个<code>.html</code>文件和<code>.css</code>文件以及图片等多媒体文件，我们需要使用不同的文件夹分类进行管理。</p>
</li>
<li><p>文件夹最基本的结构包括：</p>
<p><img src="https://pic.imgdb.cn/item/617649a82ab3f51d91d6bf2f.png"></p>
</li>
</ul>
<h3 id="lt-head-gt-内的配置"><a href="#lt-head-gt-内的配置" class="headerlink" title="&lt;head&gt;内的配置"></a><code>&lt;head&gt;</code>内的配置</h3><ul>
<li>真正的上线网站中，<code>HTML</code>文件中的<code>&lt;head&gt;</code>标签内部需要配置更多的内容</li>
</ul>
<h4 id="lt-title-gt-网页标题"><a href="#lt-title-gt-网页标题" class="headerlink" title="&lt;title&gt;网页标题"></a><code>&lt;title&gt;</code>网页标题</h4><ul>
<li><code>&lt;title&gt;</code>网页标题<code>&lt;/title&gt;</code></li>
</ul>
<h4 id="标签页icon图标"><a href="#标签页icon图标" class="headerlink" title="标签页icon图标"></a>标签页<code>icon</code>图标</h4><ul>
<li><p>大部分网站在标签页标题位置会添加网站的<code>icon</code>图标。</p>
</li>
<li><p>图标的文件夹要求以<code>favicon.ico</code>命名，文件需要与<code>index.html</code>文件同级储存</p>
</li>
<li><p>使用方法，通过<code>&lt;link&gt;</code>标签进行引用，设置的属性包括：</p>
<p><code>&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;</code></p>
</li>
</ul>
<h3 id="CSS分级引入"><a href="#CSS分级引入" class="headerlink" title="CSS分级引入"></a><code>CSS</code>分级引入</h3><ul>
<li><code>css</code>文件设置需要根据功能进行分层管理:目的是为了提取出多个页面公共的部分，提供多个<code>HTML</code>同时引用。公共的部分也可以划分范围，有的是所有网站能用的，有的是某几个网站公共的部分。</li>
<li><code>css</code>常见的分层组织:清除默认样式的<code>css</code>，网站的公共样式<code>css</code>，每个页面自己独有的<code>css</code>。注意书写顺序，引入多层<code>css</code>时，需要按照后面的层叠前面的<code>css</code>进行设置，使用页面独有的样式层叠公共的样式。</li>
</ul>
<h4 id="清除默认样式"><a href="#清除默认样式" class="headerlink" title="清除默认样式"></a>清除默认样式</h4><ul>
<li>使用范围:所有网站都能使用。</li>
<li>制作方法:自己工作中进行积累，或者使用网络上已有的资源。</li>
<li>命名的习惯:<code>reset.css</code>。</li>
<li>引入时必须作为第一层引入，网页中独有的样式可以层叠掉<code>reset</code>中的样式。</li>
<li>注意:<code>reset.css</code>文件写完后不允许再次更改。</li>
</ul>
<h4 id="公共样式"><a href="#公共样式" class="headerlink" title="公共样式"></a>公共样式</h4><ul>
<li>使用范围:单独的一个网站所有的页面、几个页面。</li>
<li>制作方法:从设计图中观察，找到所有页面或多个页面公共的部分，划分成不同的模块分别进行<code>.css</code>文件的书写。</li>
<li>命名习惯:<code>common.css</code>或者<code>模块名.css</code>。</li>
<li>多个网站页面的公共部分书写完之后不允许后期更改，一旦更改，多个引用的<code>HTML</code>页面都会发生变化。需要注意类名的使用，公共文件中的类名一般不要在其他的<code>css</code>文件中再用。</li>
<li>引入顺序:一般在<code>reset.css</code>后面，单独样式文件前面。</li>
</ul>
<h4 id="页面渡有样式"><a href="#页面渡有样式" class="headerlink" title="页面渡有样式"></a>页面渡有样式</h4><ul>
<li>使用范围:单独的一个<code>HTML</code>页面。</li>
<li>制作方法:找到页面独有的而其他页面没有的样式，单独书写在一个<code>.css</code>文件中，只有对应的<code>HTML</code>文件能够引用。</li>
<li>命名习惯:一般文件名与<code>HTML</code>的文件名保持一致，例如<code>index.css</code>，如果拆分的更细致可以使用多个单词的拼写，例如<code>index_banner.cs</code>s等。</li>
<li>引入顺序:在所有公共样式后面。</li>
<li>注意:使用单独样式文件去层叠前面公共样式时，需要注意选择器权重。</li>
</ul>
<h4 id="整个CSS分层引入的顺序"><a href="#整个CSS分层引入的顺序" class="headerlink" title="整个CSS分层引入的顺序"></a>整个<code>CSS</code>分层引入的顺序</h4><ul>
<li><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/reset.css&quot;&gt;</code></li>
<li><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/common.css&quot;&gt;</code></li>
<li><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot;&gt;</code></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>CSS3（三）CSS3新增属性</title>
    <url>/2021/08/b3d7c705d61b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h3><ul>
<li><p>属性名：<code>border-­radius</code> </p>
</li>
<li><p>作用：设置边框的圆角。</p>
</li>
<li><p>属性值：可以是像素值，或者百分比，百分比参考的是盒子整体宽度、高度的百分比。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>x-radius</code> / <code>y-radius</code></td>
<td><code>/</code> 分割两部分属性值，前面为水平半径，后面为垂直半径，得到的是椭圆角。</td>
</tr>
<tr>
<td><code>radius</code></td>
<td>一个属性值，则水平和垂直都设置为同一个值，得到的是圆角。</td>
</tr>
</tbody></table>
</li>
<li><p>单一属性</p>
<ul>
<li><code>border-top-left-radius: 半径;</code> </li>
<li><code>border-top-right-radius: 半径;</code> </li>
<li><code>border-bottom-right-radius: 半径;</code> </li>
<li><code>border-bottom-left-radius: 半径;</code></li>
</ul>
</li>
<li><p>简写方法</p>
<ul>
<li><code>border-radius</code> 相当于四个单一属性的简写方法，类似 <code>padding</code> 也可以有四种值的写法。</li>
<li><code>border-radius</code>: <code>左上角</code> <code>右上角</code> <code>右下角</code> <code>左下角</code>;</li>
<li><code>border-radius</code>: <code>左上角</code> <code>右上角和左下角</code> <code>右下角</code>;</li>
<li><code>border-radius</code>: <code>左上角和右下角</code> <code>右上角和左下角</code>;</li>
<li><code>border-radius</code>: <code>四个角相同</code>;</li>
</ul>
</li>
<li><p><code>/</code> 的属性值写法</p>
<ul>
<li><code>border-radius</code> 属性值中出现了 <code>/</code> 斜线，那么 <code>/</code> 前面可以设置水平方向四种值的写法，<code>/</code> 后面可以设置垂直方向四种值的写法。</li>
</ul>
</li>
<li><p>浏览器兼容</p>
<ul>
<li><code>Internet Explorer 8</code> 及以下版本浏览器不支持<code>border-radius</code>属性，其他浏览器都支持。</li>
</ul>
</li>
</ul>
<h3 id="文字阴影"><a href="#文字阴影" class="headerlink" title="文字阴影"></a>文字阴影</h3><p>在 <code>CSS3</code> 中，<code>text-shadow</code> 可向文本应用阴影。通过属性值能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>h-shadow</code></td>
<td>必需。水平阴影的位置。允许负值。</td>
</tr>
<tr>
<td><code>v-shadow</code></td>
<td>必需。垂直阴影的位置。允许负值。</td>
</tr>
<tr>
<td><code>blur</code></td>
<td>可选。模糊的距离。</td>
</tr>
<tr>
<td><code>color</code></td>
<td>可选。阴影的颜色。</td>
</tr>
</tbody></table>
<ul>
<li>文字阴影语法<ul>
<li><code>text-shadow</code> 属性向文本添加阴影，属性值有2-3个长度值和一个可选的颜色值进行规定，省略的长度是 0。</li>
</ul>
</li>
<li>多层阴影<ul>
<li><code>text-shadow</code> 属性也可以向文本添加多个阴影，逗号分隔多个阴影的属性值。</li>
<li>注意：多阴影中，先写的阴影压盖在后写的阴影上。</li>
</ul>
</li>
</ul>
<h3 id="边框阴影"><a href="#边框阴影" class="headerlink" title="边框阴影"></a>边框阴影</h3><p>在 <code>CSS3</code> 中，<code>box-shadow</code> 属性用于对盒子边框添加阴影。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>h-shadow</code></td>
<td>必需。水平阴影的位置。允许负值。</td>
</tr>
<tr>
<td><code>v-shadow</code></td>
<td>必需。垂直阴影的位置。允许负值。</td>
</tr>
<tr>
<td><code>blur</code></td>
<td>可选。模糊距离。</td>
</tr>
<tr>
<td><code>spread</code></td>
<td>可选。阴影的尺寸。</td>
</tr>
<tr>
<td><code>color</code></td>
<td>可选。阴影的颜色。</td>
</tr>
<tr>
<td><code>inset</code></td>
<td>可选。将外部阴影改为内部阴影。</td>
</tr>
</tbody></table>
<ul>
<li>边框阴影语法<ul>
<li><code>box-shadow</code> 属性向盒子添加阴影，属性值有2-4 个长度值、可选的颜色值以及可选的 <code>inset</code> 关键词来规定，省略的长度是 0。</li>
</ul>
</li>
<li>多层阴影<ul>
<li><code>box-shadow</code> 属性也可以向盒子添加多个阴影，逗号分隔多个阴影的属性值。</li>
<li>注意：多阴影中，先写的阴影压盖在后写的阴影上。</li>
</ul>
</li>
</ul>
<h3 id="过渡属性"><a href="#过渡属性" class="headerlink" title="过渡属性"></a>过渡属性</h3><blockquote>
<p><strong>动画效果</strong></p>
<p><code>CSS3</code> 出现之前，前端一般使用 <code>Flash</code> 动画或 <code>JavaScript</code> 制作动画。</p>
<p>帧动画：通过一帧一帧的画面按照固定顺序和速度播放，如电影胶片。</p>
</blockquote>
<ul>
<li><p>属性名：<code>transition</code></p>
</li>
<li><p>作用：在不使用 <code>Flash</code> 动画或 <code>JavaScript</code> 的情况下，使用 <code>transition</code> 可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用<code>A</code>和<code>B</code>代指），那么<code>A</code>和<code>B</code>之间就可以实现平滑的过渡的动画效果。为了方便看效果，我们使用 <code>:hover</code> 切换状态。</p>
</li>
<li><p>语法格式<code>transition: 过渡的属性 过渡时间 运动曲线 延时时间;</code></p>
</li>
<li><p>单一属性写法</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>transition</code></td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
</tr>
<tr>
<td><code>transition-property</code></td>
<td>规定应用过渡的 <code>CSS</code> 属性的名称。</td>
</tr>
<tr>
<td><code>transition-duration</code></td>
<td>定义过渡效果花费的时间。默认是 0。</td>
</tr>
<tr>
<td><code>transition-timing-function</code></td>
<td>规定过渡效果的时间曲线。默认是 “<code>ease</code>“。</td>
</tr>
<tr>
<td><code>transition-delay</code></td>
<td>规定过渡效果何时开始。默认是 0。</td>
</tr>
</tbody></table>
<ul>
<li><p><code>transition-property</code>过渡的属性</p>
<ul>
<li><code>none</code> 表示没有属性过渡</li>
<li><code>all</code> 表示所有变化的属性都过渡</li>
<li>属性名使用具体的属性名，多个属性名中间逗号分隔</li>
</ul>
</li>
<li><p>时间</p>
<ul>
<li>过渡时间：以<code>s</code>秒为单位。</li>
<li>延时时间：以<code>s</code>秒为单位。<code>0s</code>也必须加单位。</li>
</ul>
</li>
<li><p><code>transition-timing-function</code> 时间曲线</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>linear</code></td>
<td>规定以相同速度开始至结束的过渡效果。</td>
</tr>
<tr>
<td><code>ease</code></td>
<td>规定慢速开始，然后变快，然后慢速结束的过渡效果。</td>
</tr>
<tr>
<td><code>ease-in</code></td>
<td>规定以慢速开始的过渡效果。</td>
</tr>
<tr>
<td><code>ease-out</code></td>
<td>规定以慢速结束的过渡效果。</td>
</tr>
<tr>
<td><code>ease-in-out</code></td>
<td>规定以慢速开始和结束的过渡效果。</td>
</tr>
<tr>
<td><code>cubic-bezier(x1,y1,x2,y2)</code></td>
<td>在<code>cubic-bezier</code>函数中定义自己的值。<code>x1</code>、<code>x2</code>取是0至1之间的数值，<code>y1</code>、<code>y2</code>取值任意，四个数值表示拉扯的点的两个坐标。</td>
</tr>
</tbody></table>
</li>
<li><p>贝塞尔曲线</p>
<ul>
<li><img src="https://pic.imgdb.cn/item/616ff0042ab3f51d91bc8195.png"></li>
<li><img src="https://pic.imgdb.cn/item/616ff06e2ab3f51d91bccdda.png"></li>
</ul>
</li>
<li><p>浏览器兼容</p>
<ul>
<li><code>Internet Explorer 10</code>、<code>Firefox</code>、<code>Chrome</code> 以及 <code>Opera</code> 支持 <code>transition</code> 属性。</li>
<li><code>Safari</code> 需要前缀 <code>-webkit-</code>。</li>
<li>注意：<code>Internet Explorer 9</code> 以及更早的版本，不支持 <code>transition</code> 属性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2D-转换"><a href="#2D-转换" class="headerlink" title="2D 转换"></a><code>2D</code> 转换</h3><ul>
<li>属性名：<code>transform</code></li>
<li>作用：对元素进行移动、缩放、旋转、拉长或拉伸。配合过渡和动画知识，可以取代大量之前只能靠<code>Flash</code>才可以实现的效果。</li>
<li>属性值：多种转换方法的属性值，可以实现不同的转换效果。</li>
</ul>
<h4 id="位移-translate"><a href="#位移-translate" class="headerlink" title="位移 translate()"></a>位移 <code>translate()</code></h4><ul>
<li><p><code>transform</code> 的属性值为 <code>translate()</code> 时，可以实现位移效果。</p>
</li>
<li><p>书写语法</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>translate(x,y)</code></td>
<td><code>x</code>,<code>y</code>分别为水平和垂直方向位移的距离，可以为<code>px</code>值或百分比，区分正负</td>
</tr>
<tr>
<td><code>translate(x)</code></td>
<td>只有一个数值，表示水平方向的位移</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="缩放-scale"><a href="#缩放-scale" class="headerlink" title="缩放 scale()"></a>缩放 <code>scale()</code></h4><ul>
<li><p><code>transform</code> 的属性值为 <code>scale()</code> 时，可以实现元素缩放效果。</p>
</li>
<li><p>书写语法</p>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>scale(x, y)</code></td>
<td><code>x</code>,<code>y</code>分别为改变元素的宽度和高度的倍数</td>
</tr>
<tr>
<td><code>scale(n)</code></td>
<td>只有一个值，表示宽度和高度同时缩放<code>n</code>倍</td>
</tr>
<tr>
<td><code>scaleX(n)</code></td>
<td>改变元素的宽度</td>
</tr>
<tr>
<td><code>scaleY(n)</code></td>
<td>改变元素的高度</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="旋转-rotate"><a href="#旋转-rotate" class="headerlink" title="旋转 rotate()"></a>旋转 <code>rotate()</code></h4><ul>
<li><code>transform</code> 属性值设置为 <code>rotate()</code> 时，实现元素的旋转。</li>
<li>书写语法 <code>transform: rotate(数字deg);</code><ul>
<li>其中，<code>deg</code>为度数单位，正数表示顺时针旋转，负数表示逆时针旋转。<code>2D</code>的旋转只有一个属性值。</li>
<li>注意：元素旋转后，坐标轴也跟着发生转变。</li>
<li>因此，多个属性值同时设置给 <code>transform</code> 时，书写顺序不同导致的转换效果有差异。</li>
</ul>
</li>
</ul>
<h4 id="倾斜-skew"><a href="#倾斜-skew" class="headerlink" title="倾斜 skew()"></a>倾斜 <code>skew()</code></h4><ul>
<li><code>transform</code> 属性值设置为 <code>skew()</code> 时，实现元素的倾斜。</li>
<li>书写语法 <code>transform: skew(数字deg,数字deg);</code><ul>
<li>两个属性值分别表示水平和垂直方向倾斜的角度，属性值可以为正可以为负，第二个数值不写默认为0</li>
</ul>
</li>
</ul>
<h4 id="transform­-origin-属性"><a href="#transform­-origin-属性" class="headerlink" title="transform­-origin 属性"></a><code>transform­-origin</code> 属性</h4><ul>
<li>作用：设置调整元素的水平和垂直方向原点的位置。</li>
<li>调整元素的基准点。</li>
<li>属性值：包含两个，中间使用空格分隔。</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>x</code></td>
<td>定义 <code>X</code> 轴的原点在何处。可能的值：<code>left</code> 、<code>center</code>、<code>right</code>、<code>像素值</code>、<code>百分比</code></td>
</tr>
<tr>
<td><code>y</code></td>
<td>定义 <code>Y</code> 轴的原点在何处。可能的值：<code>top</code>、<code>center</code>、<code>bottom</code>、<code>像素值</code>、<code>百分比</code></td>
</tr>
</tbody></table>
<h3 id="3D-转换"><a href="#3D-转换" class="headerlink" title="3D 转换"></a><code>3D</code> 转换</h3><p><code>transform</code> 属性不止能实现 <code>2D</code> 转换，也可以制作 <code>3D</code> 立体转换效果，比普通的 <code>x</code>、<code>y</code> 轴组成的平面效果多了一条 <code>z</code> 轴</p>
<p><img src="https://pic.imgdb.cn/item/6176219d2ab3f51d91bad6d4.png"></p>
<h4 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h4><ul>
<li>电脑显示屏是一个 <code>2D</code> 平面，图像之所以具有立体感（<code>3D</code>效果），其实只是一种视觉呈现，通过透视可以实现此目的。</li>
<li>透视可以将一个 <code>2D</code> 平面，在转换的过程当中，呈现 <code>3D</code> 效果。</li>
<li>透视特点：近大远小。</li>
<li>注意：并非任何情况下需要透视效果，根据开发需要进行设置，如果需要展示 <code>z</code> 轴的变化，则设置透视效果。</li>
</ul>
<h4 id="透视属性-perspective"><a href="#透视属性-perspective" class="headerlink" title="透视属性 perspective"></a>透视属性 <code>perspective</code></h4><ul>
<li>属性名：<code>perspective</code></li>
<li>作用：设置在 <code>z</code> 轴的视线焦点的观察位置，从而实现 <code>3D</code> 查看效果。</li>
<li>属性值：像素值，数值越大，观察点距离 <code>z</code> 轴原点越远，图形效果越完整且接近原始尺寸。</li>
<li>注意：透视属性需要设置给 <code>3D</code> 变化元素的父级。</li>
</ul>
<h4 id="3D-旋转"><a href="#3D-旋转" class="headerlink" title="3D 旋转"></a><code>3D</code> 旋转</h4><ul>
<li><p><code>3D</code>旋转比<code>2D</code>旋转更复杂，需要分别对三个方向的旋转角度值</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>rotateX(angle)</code></td>
<td>定义沿着 <code>X</code> 轴的 <code>3D</code> 旋转。</td>
</tr>
<tr>
<td><code>rotateY(angle)</code></td>
<td>定义沿着 <code>Y</code> 轴的 <code>3D</code> 旋转。</td>
</tr>
<tr>
<td><code>rotateZ(angle)</code></td>
<td>定义沿着 <code>Z</code> 轴的 <code>3D</code> 旋转。</td>
</tr>
</tbody></table>
</li>
<li><p>注意：属性值的角度区分正负，正数表示沿对应坐标轴顺时针方向旋转，负数表示沿对应坐标轴逆时针方向旋转。</p>
</li>
</ul>
<h4 id="3D-位移"><a href="#3D-位移" class="headerlink" title="3D 位移"></a><code>3D</code> 位移</h4><ul>
<li><p>类似的，位移也分为三个方向的移动</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>translateX(x)</code></td>
<td>设置 <code>X</code> 轴的位移值。</td>
</tr>
<tr>
<td><code>translateX(y)</code></td>
<td>设置 <code>Y</code> 轴的位移值。</td>
</tr>
<tr>
<td><code>translateX(z)</code></td>
<td>定义<code>3D</code>位移，设置<code>Z</code>轴的位移值。</td>
</tr>
</tbody></table>
</li>
<li><p>注意：属性值为像素值或百分比，正负表示位移的方向。正值向对应轴的正方向移动，负值向对应轴的负方向移动。</p>
</li>
</ul>
<h4 id="transform-style属性"><a href="#transform-style属性" class="headerlink" title="transform-style属性"></a><code>transform-style</code>属性</h4><ul>
<li><p>用于设置被嵌套的子元素在父元素的 <code>3D</code> 空间中显示，子元素会保留自己的 <code>3D</code> 转换坐标轴。</p>
</li>
<li><p>属性值</p>
<ul>
<li><code>flat</code>：所有子元素在 <code>2D</code> 平面呈现</li>
<li><code>preserve-3d</code>：保留 <code>3D</code> 空间</li>
</ul>
</li>
<li><p><code>3D</code> 元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置<code>transform-style: preserve-3d</code>，来使其变成一个真正的 <code>3D</code> 图形。</p>
</li>
<li><p>一般来说，该属性设置给 <code>3D</code> 变换图形的父级元素。</p>
</li>
</ul>
<h4 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h4><ul>
<li><code>Internet Explorer 10</code>、<code>Firefox</code> 以及 <code>Opera</code> 支持 <code>transform</code> 属性。</li>
<li><code>Chrome</code> 和 <code>Safari</code> 需要前缀 <code>-webkit-</code>。</li>
<li><code>Internet Explorer 9</code> 需要前缀 <code>-ms-</code>。</li>
</ul>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p><code>css3</code> 中提供了自己的动画制作方法，这可以在许多网页中取代动画图片、<code>Flash</code> 动画以及 <code>JavaScript</code>。</p>
<p><code>css3</code> 动画制作分为两步：创建动画、绑定动画。</p>
<h4 id="keyframes-规则"><a href="#keyframes-规则" class="headerlink" title="@keyframes 规则"></a><code>@keyframes</code> 规则</h4><ul>
<li><code>@keyframes</code> 规则用于创建动画。</li>
<li>在 <code>@keyframes</code> 中规定某项 <code>CSS</code> 样式，就能创建由从一种样式逐渐变化为另一种样式的效果。 可以改变任意多的样式任意多的次数。</li>
<li>需要使用百分比来规定变化发生的时间，或用关键词 “<code>from</code>“ 和 “<code>to</code>“，等同于 0% 和 100%。 0% 是动画的开始，100% 是动画的完成。</li>
</ul>
<h4 id="keyframes-书写方法"><a href="#keyframes-书写方法" class="headerlink" title="@keyframes 书写方法"></a><code>@keyframes</code> 书写方法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称 &#123;</span><br><span class="line">  动画过程，可以添加任意百分比处的动画细节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="animation-属性"><a href="#animation-属性" class="headerlink" title="animation 属性"></a><code>animation</code> 属性</h4><ul>
<li><p>需要将 <code>@keyframes</code> 中创建的动画捆绑到某个选择器，否则不会产生动画效果。</p>
</li>
<li><p><code>animation</code> 属性用于对动画进行捆绑。</p>
</li>
<li><p>语法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">	<span class="attribute">animation</span>: 动画名称 过渡时间 速度曲线 动画次数 延时时间;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>其中必须设置动画名称和过渡时间，其他属性值可以根据需求设置。</p>
</li>
<li><p>单一属性列表</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>animation-name</code></td>
<td align="center">规定 <code>@keyframes</code> 动画的名称。</td>
</tr>
<tr>
<td align="center"><code>animation-duration</code></td>
<td align="center">规定动画完成一个周期所花费的秒或毫秒。默认是 0。</td>
</tr>
<tr>
<td align="center"><code>animation­-timing-function</code></td>
<td align="center">规定动画的速度曲线。默认是 “<code>ease</code>“。</td>
</tr>
<tr>
<td align="center"><code>animation­-delay</code></td>
<td align="center">规定动画何时开始。默认是 0。</td>
</tr>
<tr>
<td align="center"><code>animation­iteration-count</code></td>
<td align="center">规定动画被播放的次数。默认是 1。<code>infinite</code>表示无限次播放。</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="浏览器兼容-1"><a href="#浏览器兼容-1" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h4><ul>
<li><code>Internet Explorer 10</code>、<code>Firefox</code> 以及 <code>Opera</code> 支持 <code>@keyframes</code> 规则和 <code>animation</code> 属性。</li>
<li><code>Chrome</code> 和 <code>Safari</code> 需要前缀 <code>-webkit-</code>。 </li>
<li><code>Internet Explorer 9</code>，以及更早的版本，不支持 <code>@keyframe</code> 规则或 <code>animation</code> 属性。 </li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS3（二）CSS3盒模型</title>
    <url>/2021/08/ac64559ba3f1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><code>CSS3</code> 中可以通过 <code>box-sizing</code> 来指定盒模型，这样我们就可以设置如何计算一个元素的总宽度和总高度。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>content-box</code></td>
<td>默认值，标准盒子模型，盒模型是外扩的。<br/><code>width</code> 与 <code>height</code> 只包括内容的宽和高。<br/><code>在 width 和 height 之外绘制元素的内边距和边框。</code></td>
</tr>
<tr>
<td><code>border-box</code></td>
<td>怪异模式，盒模型是内减的。<br/><code>width</code> 和 <code>height</code> 属性包括内容，内边距和边框，但不包括外边距。<br/><code>为元素指定的任何内边距和边框都将在已设定的 width 和 height 内进行绘制。</code></td>
</tr>
</tbody></table>
<p><code>content-box</code> 标准模式</p>
<ul>
<li><code>Standard</code> 模式：标准模式中，盒子总体大小为 <code>width</code>(<code>height</code>) + <code>padding</code> + <code>border</code>，内容区域是 <code>width</code> 和 <code>height</code> 部分。</li>
</ul>
<p><code>border-box</code> 怪异模式</p>
<ul>
<li><code>Quirks</code> 模式：怪异模式中，盒子总体大小为 <code>width</code> 和 <code>height</code>，添加了<code>padding</code>和<code>border</code>后，内容区域会收缩。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS3（一）新增选择器</title>
    <url>/2021/08/54a75abce09f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><code>CSS3</code> 中，相对于 <code>CSS2.1</code> 版本的 7 个选择器，增加了更多其他的选择器，实现了更多的选择方式。</p>
<h3 id="子级选择器"><a href="#子级选择器" class="headerlink" title="子级选择器"></a>子级选择器</h3><ul>
<li>子级选择器用于选取带有特定父元素的元素。</li>
<li>书写语法：<code>element1 &gt; element2</code> 。</li>
<li>注意：如果 <code>element2</code> 元素不是父元素 <code>element1</code> 的直接子元素，则不会被选择。</li>
<li><code>&gt;</code> 符号之前书写父级的选择器，<code>&gt;</code> 符号之后写子级选择器，必须满足父子级关系才能选中标签。</li>
</ul>
<h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>element1+element2</code></td>
<td>匹配同一个父元素中紧跟在<code>element1</code>后面的一个<code>element2</code>元素</td>
</tr>
<tr>
<td><code>element1~element2</code></td>
<td>匹配同一个父元素中在<code>element1</code>后面的所有<code>element2</code>元素</td>
</tr>
</tbody></table>
<ul>
<li>相邻兄弟选择器<ul>
<li>相邻兄弟选择器可以用于选择紧接在另一个元素后的兄弟元素，而且二者有相同的父元素。书写语法：<code>E1 + E2</code>。</li>
<li>注意：<ul>
<li>选中的是紧跟在 <code>E1</code> 之后的同级元素 <code>E2</code>。</li>
<li>只能选中紧跟在后面的一个 <code>E2</code> 元素。</li>
<li>二者有相同的父元素。</li>
<li><code>+</code> 符号前后可以添加空格书写。</li>
</ul>
</li>
</ul>
</li>
<li>其他兄弟选择器<ul>
<li>其他兄弟选择器匹配同一个父元素中在 <code>element1</code> 后面的所有 <code>element2</code> 元素。</li>
<li>书写语法：<code>element1~element2</code> </li>
<li>注意：<ul>
<li>选择 <code>element1</code> 之后出现的所有 <code>element2</code>。</li>
<li>两种元素必须拥有相同的父元素，但是 <code>element2</code> 不必直接紧随 <code>element1</code>。</li>
<li><code>~</code> 符号前后可以添加空格书写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><table>
<thead>
<tr>
<th>选择器</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>E:first-child</code></td>
<td>匹配<code>父元素</code>中的第一个<code>子元素E</code></td>
</tr>
<tr>
<td><code>E:last-child</code></td>
<td>匹配<code>父元素</code>中最后一个<code>E元素</code></td>
</tr>
<tr>
<td><code>E:nth-child(n)</code></td>
<td>匹配<code>父元素</code>中的第<code>n</code>个<code>子元素E</code></td>
</tr>
<tr>
<td><code>E:first-of-type</code></td>
<td>指定类型<code>E</code>的第一个</td>
</tr>
<tr>
<td><code>E:last-of-type</code></td>
<td>指定类型<code>E</code>的最后一个</td>
</tr>
<tr>
<td><code>E:nth-of-type(n)</code></td>
<td>指定类型<code>E</code>的第<code>n</code>个</td>
</tr>
</tbody></table>
<ul>
<li><p><code>nth-child（n）</code></p>
<ul>
<li><p><code>n</code> 可以是数字，关键字和公式</p>
</li>
<li><p><code>n</code> 如果是数字，就是选择第 <code>n</code> 个</p>
</li>
<li><p>常见的关键词 <code>even</code> 偶数 <code>odd</code> 奇数</p>
</li>
<li><p>常见的公式如下 ( 如果 <code>n</code> 是公式，则从 0 开始计算，<code>n</code>是从 0 ，1，2，3.. 一直递增）</p>
</li>
<li><p>但是第 0 元素或者超出了元素的个数会被忽略 </p>
</li>
<li><table>
<thead>
<tr>
<th>公式</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td><code>2n</code></td>
<td>偶数</td>
</tr>
<tr>
<td><code>2n+1</code></td>
<td>奇数</td>
</tr>
<tr>
<td><code>5n</code></td>
<td>5 10 15 ……</td>
</tr>
<tr>
<td><code>n+5</code></td>
<td>从第5个开始（包含第5个）到最后，5 6 7 8 9 ……</td>
</tr>
<tr>
<td><code>-n+5</code></td>
<td>前5个（包含第5个），5 4 3 2 1 0……</td>
</tr>
</tbody></table>
</li>
<li><p><code>E:nth-child(n)</code> 和<code>E:nth-of-type(n)</code> 的区别</p>
<ul>
<li><code>E:nth-child(n)</code> 匹配父元素的第 <code>n</code> 个子元素 <code>E</code>，同时需要满足两个条件。</li>
<li><code>E:nth-of-type(n)</code> 匹配同类型中的第 <code>n</code> 个同级兄弟元素 <code>E</code>，会忽视其他同级的非同类型元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><ul>
<li><p>新增伪元素</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td><code>E::before</code></td>
<td>在 <code>E</code> 元素内部的前面插入一个元素</td>
</tr>
<tr>
<td><code>E::after</code></td>
<td>在 <code>E</code> 元素内部的后面插入一个元素</td>
</tr>
<tr>
<td><code>E::first-letter</code></td>
<td>选择到了 <code>E</code> 容器内的第一个字母</td>
</tr>
<tr>
<td><code>E::first-line</code></td>
<td>选择到了 <code>E</code> 容器内的第一行文本</td>
</tr>
</tbody></table>
</li>
<li><p><code>h5</code> 写法和传统写法区别</p>
<ul>
<li>单冒号 <code>E:before</code></li>
<li>双冒号 <code>E::before</code></li>
<li>浏览器对以上写法都能识别，双冒号是 <code>h5</code> 的语法规范。</li>
</ul>
</li>
<li><p>伪元素的注意事项</p>
<ul>
<li>伪元素只能给双标签添加，不能给单标签添加</li>
<li>伪元素的冒号前不能有空格，如 <code>E ::before</code> 这个写法是错误的</li>
<li>伪元素里面必须写上属性 <code>content:&quot;&quot;;</code></li>
<li><code>before</code> 和 <code>after</code> 创建一个元素，但是属于行内元素。</li>
<li>因为在 <code>DOM</code> 里面看不见刚才创建的元素，所以我们称为伪元素。</li>
</ul>
</li>
</ul>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul>
<li><p>属性选择器用来选择包含指定属性的标签。</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td><code>E[att]</code></td>
<td>选择具有<code>att</code>属性的<code>E元素</code></td>
</tr>
<tr>
<td><code>E[att=&quot;val&quot;]</code></td>
<td>选择具有<code>att</code>属性且属性值等于<code>val</code>的<code>E元素</code></td>
</tr>
<tr>
<td><code>E[att^=&quot;val&quot;]</code></td>
<td>匹配具有<code>att</code>属性、且值以<code>val</code>开头的<code>E元素</code></td>
</tr>
<tr>
<td><code>E[att$=&quot;val&quot;]</code></td>
<td>匹配具有<code>att</code>属性、且值以<code>val</code>结尾的<code>E元素</code></td>
</tr>
<tr>
<td><code>E[att*=&quot;val&quot;]</code></td>
<td>匹配具有<code>att</code>属性、且值中含有<code>val</code>的<code>E元素</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h3><ul>
<li>基础选择器：<code>id 选择器</code> &gt; <code>类选择器</code> &gt; <code>标签选择器</code> &gt; <code>*</code></li>
<li><code>伪类选择器</code>、<code>属性选择器</code> 的权重等于<code>类选择器</code> 。</li>
<li><code>伪元素选择器</code> 的权重等于<code>标签选择器</code> 。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>Html5</title>
    <url>/2021/08/ce5949453f00/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="HTML版本"><a href="#HTML版本" class="headerlink" title="HTML版本"></a><code>HTML</code>版本</h3><p><img src="https://pic.imgdb.cn/item/616e5dea2ab3f51d919bf770.png"></p>
<h3 id="HTML5简介"><a href="#HTML5简介" class="headerlink" title="HTML5简介"></a><code>HTML5</code>简介</h3><p>它是万维网的核心语言、标准通用标记语言下的一个应用超文本标记语言（<code>HTML</code>）的第五次重大修改。用于取代<code>HTML4</code>与<code>XHTML</code>的新一代标准版本，所以叫<code>HTML5</code>。</p>
<h3 id="H5新变化"><a href="#H5新变化" class="headerlink" title="H5新变化"></a><code>H5</code>新变化</h3><ul>
<li><p><strong><code>XHTML</code>可扩展超文本标记语言</strong></p>
<ul>
<li><code>XHTML</code>是一种增强了的<code>HTML</code>，它的可扩展性和灵活性将适应未来网络应用更多的需求。</li>
</ul>
</li>
<li><p><strong><code>HTML5</code></strong></p>
<ul>
<li><code>HTML5</code>的设计目的是为了在移动设备上支持多媒体。</li>
<li>增加了新特性：语义特性，本地存储特性，设备兼容特性，连接特性，网页多媒体特性，三维、图形及特效特性，性能与集成特性，<code>CSS3</code> 特性。</li>
<li>废弃一些元素和属性比如<code>font</code> 、<code>center</code> 等…</li>
</ul>
</li>
</ul>
<h3 id="HTML5优势、劣势"><a href="#HTML5优势、劣势" class="headerlink" title="HTML5优势、劣势"></a><code>HTML5</code>优势、劣势</h3><ul>
<li><code>HTML5</code> 优势<ul>
<li>提高可用性和改进用户的友好体验</li>
<li>更好的语义化标签</li>
<li>可以给站点带来更多的多媒体元素(视频和音频)</li>
<li>可以很好的替代<code>FLASH</code>和<code>Silverlight</code></li>
<li>当涉及到网站的抓取和索引的时候，对于<code>SEO</code>很友好；</li>
<li>将被大量应用于移动应用程序和游戏</li>
<li>可移植性好</li>
</ul>
</li>
<li><code>HTML5</code> 劣势<ul>
<li>该标准并未能很好的被<code>PC</code>端浏览器所支持</li>
<li><code>IE9</code>以下的浏览器几乎都不兼容</li>
</ul>
</li>
</ul>
<h3 id="HTML5前景趋势"><a href="#HTML5前景趋势" class="headerlink" title="HTML5前景趋势"></a><code>HTML5</code>前景趋势</h3><ul>
<li>移动开发优先</li>
<li>游戏开发</li>
</ul>
<h3 id="广义的HTML5"><a href="#广义的HTML5" class="headerlink" title="广义的HTML5"></a>广义的<code>HTML5</code></h3><ul>
<li>狭义的<code>HTML5</code> 是指HTML 语言的第5个版本。</li>
<li>广义的<code>HTML5</code> 是<code>HTML5</code>本身 + <code>CSS3</code> + <code>JavaScript</code> 技术的综合。</li>
</ul>
<h3 id="HTML5新增语义化标签"><a href="#HTML5新增语义化标签" class="headerlink" title="HTML5新增语义化标签"></a><code>HTML5</code>新增语义化标签</h3><ul>
<li>以前制作网页布局，我们基本用<code>div</code> 来做。<code>div</code>就是一个普通的块级标签，对于搜索引擎来说，是没有语义的。</li>
<li>新增语义化标签<ul>
<li><code>&lt;header&gt;</code>：头部标签</li>
<li><code>&lt;nav&gt;</code>：导航标签</li>
<li><code>&lt;main&gt;</code>：主体标签</li>
<li><code>&lt;article&gt;</code>：独立的内容标签</li>
<li><code>&lt;section&gt;</code>：区段标签</li>
<li><code>&lt;aside&gt;</code>：侧边栏标签</li>
<li><code>&lt;footer&gt;</code>：尾部标签</li>
</ul>
</li>
<li>注意事项<ul>
<li>这种语义化标准主要针对搜索引擎的</li>
<li>这些新标签页面中可以使用多次的</li>
<li>在<code>IE9</code>中，需要把这些元素转换为块级元素</li>
<li>移动端更喜欢使用这些标签</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element">HTML 元素参考</a>  </li>
</ul>
</li>
</ul>
<h3 id="HTML5新增多媒体标签"><a href="#HTML5新增多媒体标签" class="headerlink" title="HTML5新增多媒体标签"></a><code>HTML5</code>新增多媒体标签</h3><ul>
<li>多媒体标签包含两个，具体如下<ul>
<li>音频：<code>&lt;audio&gt;</code> </li>
<li>视频：<code>&lt;video&gt;</code></li>
</ul>
</li>
<li>使用它们可以很方便的在页面中嵌入音频和视频，而不再去使用落后的<code>flash</code> 和其他浏览器插件。</li>
</ul>
<h4 id="lt-audio-gt-音频标签"><a href="#lt-audio-gt-音频标签" class="headerlink" title="&lt;audio&gt;音频标签"></a><code>&lt;audio&gt;</code>音频标签</h4><ul>
<li><p><code>HTML5</code> 在不使用插件的情况下也可以原生的支持音频格式文件的播放，当然支持格式是有限的。</p>
</li>
<li><p>音频格式</p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center"><code>MIME-type</code></th>
<th align="center"><code>IE9</code></th>
<th align="center"><code>Firefox3.5</code></th>
<th align="center"><code>Opera10.5</code></th>
<th align="center"><code>Chrome3.0</code></th>
<th align="center"><code>Safari3.0</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Ogg</code></td>
<td align="center"><code>audio/ogg</code></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>MP3</code></td>
<td align="center"><code>audio/mpeg</code></td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center"><code>Wav</code></td>
<td align="center"><code>audio/wav</code></td>
<td align="center"></td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center">√</td>
</tr>
</tbody></table>
</li>
<li><p><code>&lt;audio&gt;</code> 音频标签语法格式</p>
<ul>
<li><p><code>&lt;audio src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/audio&gt;</code></p>
</li>
<li><p>兼容写法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;happy.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;happy.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">	您的浏览器暂不支持audio标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>&lt;audio&gt;</code> 音频标签常见属性</p>
</li>
<li><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>autoplay</code></td>
<td><code>autoplay</code></td>
<td>如果出现该属性，则音频在就绪后马上播放。</td>
</tr>
<tr>
<td><code>controls</code></td>
<td><code>controls</code></td>
<td>如果出现该属性，则向用户显示控件，比如播放按钮。</td>
</tr>
<tr>
<td><code>loop</code></td>
<td><code>loop</code></td>
<td>如果出现该属性，则每当音频结束时重新开始播放。</td>
</tr>
<tr>
<td><code>preload</code></td>
<td><code>preload</code></td>
<td>如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用<code>&quot;autoplay&quot;</code>，则忽略该属性。</td>
</tr>
<tr>
<td><code>src</code></td>
<td><code>url</code></td>
<td>要播放的音频的<code>URL</code>。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="lt-video-gt-视频标签HTML5"><a href="#lt-video-gt-视频标签HTML5" class="headerlink" title="&lt;video&gt;视频标签HTML5"></a><code>&lt;video&gt;</code>视频标签<code>HTML5</code></h4><ul>
<li><p><code>HTML5</code> 在不使用插件的情况下也可以原生的支持视频格式文件的播放，当然支持格式是有限的。</p>
</li>
<li><p>视频格式</p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center"><code>MIME-type</code></th>
<th align="center"><code>IE</code></th>
<th align="center"><code>Firefox</code></th>
<th align="center"><code>Opera</code></th>
<th align="center"><code>Chrome</code></th>
<th align="center"><code>Safari</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Ogg</code></td>
<td align="center"><code>video/ogg</code></td>
<td align="center">×</td>
<td align="center">3.5+</td>
<td align="center">10.5+</td>
<td align="center">5.0+</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center"><code>MP4</code></td>
<td align="center"><code>video/mp4</code></td>
<td align="center">9.0+</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">5.0+</td>
<td align="center">3.0+</td>
</tr>
<tr>
<td align="center"><code>WebM</code></td>
<td align="center"><code>video/webm</code></td>
<td align="center">×</td>
<td align="center">4.0+</td>
<td align="center">10.6+</td>
<td align="center">6.0+</td>
<td align="center">×</td>
</tr>
</tbody></table>
</li>
<li><p><code>&lt;video&gt;</code>视频标签语法格式</p>
<ul>
<li><p><code>&lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</code></p>
</li>
<li><pre><code class="html">&lt;video controls=&quot;controls&quot; width=&quot;300&quot;:
  &lt;source src=&quot;move.ogg type=&quot;video/ogg&quot;&gt;
  &lt;source src=&quot;move.mp4&quot; type=&quot;video/mp4&quot;&gt;
  您的浏览器暂不支持video播放视频标签。
&lt;/video&gt;
</code></pre>
</li>
<li><p><code>&lt;video&gt;</code> 视频标签常见属性</p>
</li>
<li><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>autoplay</code></td>
<td><code>autoplay</code></td>
<td>视频就绪自动播放（谷歌浏览器需要添加<code>muted</code>来解决自动播放问题）</td>
</tr>
<tr>
<td><code>controls</code></td>
<td><code>controls</code></td>
<td>向用户显示播放控件</td>
</tr>
<tr>
<td><code>loop</code></td>
<td><code>loop</code></td>
<td>放完是否继续播放该视频，循环播放</td>
</tr>
<tr>
<td><code>preload</code></td>
<td><code>auto</code>（预先加载视频）<br><code>none</code>（不应加载视频）</td>
<td>规定是否预加载视频(如果有了<code>autoplay</code> 就忽略该属性）</td>
</tr>
<tr>
<td><code>src</code></td>
<td><code>url</code></td>
<td>视频<code>url</code>地址</td>
</tr>
<tr>
<td><code>width</code></td>
<td><code>pixels(像素)</code></td>
<td>设置播放器宽度</td>
</tr>
<tr>
<td><code>height</code></td>
<td><code>pixels(像素)</code></td>
<td>设置播放器高度</td>
</tr>
<tr>
<td><code>poster</code></td>
<td><code>Imgurl</code></td>
<td>加载等待的画面图片</td>
</tr>
<tr>
<td><code>muted</code></td>
<td><code>muted</code></td>
<td>静音播放</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>音频标签和视频标签使用基本一致</li>
<li>浏览器支持情况不同</li>
<li>我们可以给视频标签添加<code>muted</code> 属性进行自动静音播放视频，音频不可以</li>
<li>视频标签是重点，我们经常设置自动播放，循环和设置大小属性，不使用<code>controls</code> 控件。</li>
</ul>
<h3 id="HTML5新增表单标签"><a href="#HTML5新增表单标签" class="headerlink" title="HTML5新增表单标签"></a><code>HTML5</code>新增表单标签</h3><h4 id="新增-lt-input-gt-表单类型"><a href="#新增-lt-input-gt-表单类型" class="headerlink" title="新增&lt;input&gt;表单类型"></a>新增<code>&lt;input&gt;</code>表单类型</h4><table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>type=&quot;email&quot;</code></td>
<td>限制用户输入必须为<code>Email</code>类型</td>
</tr>
<tr>
<td><code>type=&quot;url&quot;</code></td>
<td>限制用户输入必须为<code>URL</code>类型</td>
</tr>
<tr>
<td><code>type=&quot;date&quot;</code></td>
<td>限制用户输入必须为<code>日期</code>类型</td>
</tr>
<tr>
<td><code>type=&quot;time&quot;</code></td>
<td>限制用户输入必须为<code>时间</code>类型</td>
</tr>
<tr>
<td><code>type=&quot;month&quot;</code></td>
<td>限制用户输入必须为<code>月</code>类型</td>
</tr>
<tr>
<td><code>type=&quot;week&quot;</code></td>
<td>限制用户输入必须为<code>周</code>类型</td>
</tr>
<tr>
<td><code>type=&quot;number&quot;</code></td>
<td>限制用户输入必须为<code>数字</code>类型</td>
</tr>
<tr>
<td><code>type=&quot;range&quot;</code></td>
<td>滑动条</td>
</tr>
<tr>
<td><code>type=&quot;tel&quot;</code></td>
<td>手机号码</td>
</tr>
<tr>
<td><code>type=&quot;search&quot;</code></td>
<td>搜索框</td>
</tr>
<tr>
<td><code>type=&quot;color&quot;</code></td>
<td>生成一个颜色选择表单</td>
</tr>
</tbody></table>
<h4 id="lt-datalist-gt-标签"><a href="#lt-datalist-gt-标签" class="headerlink" title="&lt;datalist&gt; 标签"></a><code>&lt;datalist&gt;</code> 标签</h4><ul>
<li><code>&lt;datalist&gt;</code> 标签规定了<code>&lt;input&gt;</code> 元素可能的选项列表。</li>
<li><code>&lt;datalist&gt;</code>元素包含了一组<code>&lt;option&gt;</code>元素，这些元素表示预定义可选值，在<code>&lt;input&gt;</code>元素输入过程中，会自动响应<code>&lt;option&gt;</code>元素的值。</li>
<li>绑定的<code>&lt;input&gt;</code>标签必须设置<code>list</code> 属性，属性值等于<code>&lt;datalist&gt;</code>标签的<code>id</code> 属性值。</li>
</ul>
<h4 id="新增表单属性"><a href="#新增表单属性" class="headerlink" title="新增表单属性"></a>新增表单属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>required</code></td>
<td><code>required</code></td>
<td>表单拥有该属性表示其内容不能为空，必填</td>
</tr>
<tr>
<td><code>placeholder</code></td>
<td>提示文本</td>
<td>表单的提示信息，存在默认值将不显示</td>
</tr>
<tr>
<td><code>autofocus</code></td>
<td><code>autofocus</code></td>
<td>自动聚焦属性，页面加载完成自动聚焦到指定表单，一般页面中放1个</td>
</tr>
<tr>
<td><code>autocomplete</code></td>
<td><code>off</code> / <code>on</code></td>
<td>当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。<br/>默认已经打开，如<code>autocomplete=&quot;on&quot;</code>，关闭<code>autocomplete=&quot;off&quot;</code><br/>-需要放在表单内同时加上name属性<br>-同时成功提交</td>
</tr>
<tr>
<td><code>multiple</code></td>
<td><code>multiple</code></td>
<td>可以多选文件提交</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
        <category>Html</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（九）定位</title>
    <url>/2021/08/408be7c4d1fc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="定位属性-position"><a href="#定位属性-position" class="headerlink" title="定位属性 position"></a>定位属性 <code>position</code></h3><ul>
<li><p>属性名：<code>position</code>。</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>relative</code></td>
<td>相对定位</td>
</tr>
<tr>
<td><code>absolute</code></td>
<td>绝对定位</td>
</tr>
<tr>
<td><code>fiexd</code></td>
<td>固定定位</td>
</tr>
</tbody></table>
</li>
<li><p>作用：设置定位的元素，它需要根据某个参考元素发生位置的偏移。</p>
</li>
<li><p>偏移量属性</p>
<ul>
<li>定位的元素要想发生位置的移动，必须搭配偏移量属性进行设置。 </li>
<li>水平方向：<code>left</code>、<code>right</code>。 </li>
<li>垂直方向：<code>top</code>、<code>bottom</code>。 </li>
<li>属性值：常用 <code>px</code> 为单位的数值，或者百分比。</li>
</ul>
</li>
</ul>
<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><ul>
<li>属性值：<code>relative</code>，相对的意思。</li>
<li>参考元素：标签加载的原始位置。</li>
<li>必须搭配偏移量属性才能发生位置移动。</li>
<li>相对定位的性质<ul>
<li>性质：相对定位的元素不脱离标签的原始状态（标准流、浮动），不会让出原来占有的位置。</li>
<li>元素显示效果上，<strong>原位留坑，形影分离</strong>。</li>
</ul>
</li>
<li>注意事项<ul>
<li>偏移量属性的值是区分正负的。 <ul>
<li>正数：表示偏移方向与属性名方向相反。</li>
<li>负数：表示偏移方向与属性名方向相同。</li>
</ul>
</li>
<li>同一个方向，不能设置两个偏移量属性，如果水平方向同时设置了 <code>left</code> 和 <code>right</code> 属性，只会加载 <code>left</code> 属性。垂直方向只加载 <code>top</code> 属性。<ul>
<li>建议：书写时从水平方向和垂直方向各挑一个属性进行组合。</li>
</ul>
</li>
<li>由于相对定位的参考元素是自身，<code>left</code> 的正值等价于 <code>right</code> 的负值，<code>top</code> 的正值等价于 <code>bottom</code> 的负值。<ul>
<li>为了方便记忆，可以选择只使用 <code>left</code>、<code>top</code> 组合。</li>
</ul>
</li>
</ul>
</li>
<li>实际应用<ul>
<li>由于相对定位元素比较稳定，不会随意让出位置，可以将相对定位的元素作为后期绝对定位的参考元素，就是所说的子绝父相情况。</li>
<li>相对定位比较稳定，可以在占有原始位置的情况下，对加载效果区域进行位置调整，进行微调设置。或者对文字进行微调。</li>
</ul>
</li>
</ul>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><ul>
<li>属性值：<code>absolute</code>，绝对的意思。</li>
<li>参考元素：参考的是距离最近的有定位的祖先元素，如果祖先都没有定位，参考 <code>&lt;body&gt;</code>。</li>
<li>必须搭配偏移量属性才会发生位置移动。</li>
<li>绝对定位的性质<ul>
<li>性质：绝对定位的元素脱离标准流，会让出标准流位置，可以设置宽高，也可以随时定义位置，绝对定位的元素不设置宽高只能被内容撑开。</li>
<li>绝对定位的参考元素是不固定的，不同的参考元素以及不同的偏移量组合，会导致绝对定位元素的参考点不同，具体位移效果不同。</li>
<li>在绝对定位中，由于参考点不同，<code>left</code> 正值不再等价于 <code>right</code> 的负值。</li>
</ul>
</li>
<li><code>&lt;body&gt;</code> 为参考元素的参考点<ul>
<li>以 <code>&lt;body&gt;</code> 为参考元素时，参考点的确定与偏移量方向有关。<ul>
<li>如果有 <code>top</code> 参与的定位，参考点就是 <code>&lt;body&gt;</code> 页面的左上顶点和右上顶点。自身的对比点是盒子的所有盒模型属性最外面的左上角或右上角。</li>
<li>如果有 <code>bottom</code> 参与的绝对定位，参考点是 <code>&lt;body&gt;</code> 页面首屏的左下顶点或右下顶点。对比点是盒子的所有盒模型属性最外面的左下角或右下角。</li>
</ul>
</li>
<li>实际应用中，如果以 <code>&lt;body&gt;</code> 为参考元素，不同分辨率的浏览器中，绝对定位的元素位置是不同的，所以较少使用 <code>&lt;body&gt;</code> 作为参考元素。</li>
</ul>
</li>
<li>祖先级为参考元素<ul>
<li>如果祖先级中有定位的元素，就不会去参考 <code>&lt;body&gt;</code> 。</li>
<li>参考元素：参考的是祖先元素中有任意定位的，在 <code>HTML</code> 结构中距离目标最近的祖先。</li>
</ul>
</li>
<li>根据绝对定位的参考元素的定位类型不同，有三种定位组合方式：<code>子绝父相</code>、<code>子绝父绝</code>、<code>子绝父固</code>，由于相对定位的祖先级位置更稳定，大多使用子绝父相的情况。</li>
<li>祖先元素参考点<ul>
<li>如果绝对定位的参考元素是某个祖先级，参考点是盒子 <code>border</code> 以内的四个顶点，组合方向决定了参考点。绝对定位的元素只关心对比点和参考点之间的距离，会忽视参考元素的 <code>padding</code> 区域。</li>
<li><code>left</code>、<code>top</code>：参考点是祖先的 <code>border</code> 以内的左上顶点，对比点是盒子自身的左上角。</li>
<li><code>right</code>、<code>top</code>：参考点是祖先的 <code>border</code> 以内的右上顶点，对比点是盒子自身的右上角。</li>
<li><code>left</code>、<code>bottom</code>：参考点是祖先的 <code>border</code> 以内的左下顶点，对比点是盒子自身的左下角。 </li>
<li><code>right</code>、<code>bottom</code>：参考点是祖先的 <code>border</code> 以内的右下顶点，对比点是盒子自身的右下角。</li>
</ul>
</li>
</ul>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><ul>
<li>属性值：<code>fixed</code>，固定的意思。</li>
<li>参考元素：浏览器窗口。</li>
<li>参考点：浏览器窗口的四个顶点。跟偏移量组合方向有关。</li>
<li>由于浏览器窗口的四个顶点位置不会发生变化，会导致固定定位的元素会始终显示在定位位置。</li>
<li>固定定位的性质<ul>
<li>性质：固定定位的元素脱离标准流，让出标准流位置，可以设置宽高，根据偏移量属性可以任意设置在浏览器窗口的位置。固定定位的元素会始终显示在浏览器窗口上。</li>
</ul>
</li>
</ul>
<h3 id="定位应用"><a href="#定位应用" class="headerlink" title="定位应用"></a>定位应用</h3><p>定位 <code>position</code> 根据属性值不同有三种类型的定位效果，其中绝对定位和固定定位的元素会脱离标准流。三种定位在页面中有各自的使用场景。</p>
<ul>
<li>压盖效果<ul>
<li>所有的定位类型都可以实现压盖效果。 </li>
<li>由于绝对定位的元素脱标，不占标准流位置，压盖效果更彻底，实际工作中，常见的是绝对定位制作的压盖。</li>
</ul>
</li>
<li>居中<ul>
<li>定位的元素，如果想在参考元素中居中显示，有自己的居中方法</li>
<li>第一步：<ul>
<li>在居中的方向使用一个偏移量属性，例如 <code>left</code>，设置属性值为 50%。导致图片的左顶点移动到参考元素的中心位置。 </li>
<li>百分比形式的属性值，百分百参考的是参考元素的 <code>border</code> 以内的宽度、高度。</li>
</ul>
</li>
<li>第二步：<ul>
<li>给绝对定位的子盒子设置一个同方向的 <code>margin</code>，例如 <code>margin-left</code>，属性值为负的自身宽度的一半。</li>
<li>注意：不论子盒子的宽度是否比参考元素更宽，都能使用以上方法进行居中设置。</li>
</ul>
</li>
</ul>
</li>
<li>扩展应用<ul>
<li>解决标准流中，宽的子盒子在窄的父盒子中的居中，可以设置大的子盒子相对定位，利用相对定位居中的方法进行居中。</li>
<li>浮动的元素居中，在不改变原始浮动状态情况下，可以利用相对定位居中方法。</li>
</ul>
</li>
</ul>
<h3 id="压盖顺序"><a href="#压盖顺序" class="headerlink" title="压盖顺序"></a>压盖顺序</h3><p>实际使用定位时，可能出现多个定位的元素加载到同一个位置的情况，这时候压盖的顺序是可以控制的。</p>
<ul>
<li>默认压盖顺序<ul>
<li>定位的元素不区分定位类型，都会去压盖标准流或浮动的元素。</li>
<li>如果都是定位的元素，在 <code>HTML</code> 中后写的定位压盖先写的定位。</li>
<li>因此，书写代码时，需要注意压盖效果，必须合理设置 <code>HTML</code> 元素的书写顺序。</li>
</ul>
</li>
<li>自定义压盖顺序<ul>
<li>如果想更改定位的元素的压盖顺序，可以设置一个 <code>z-index</code> 属性。 </li>
<li>属性值：数字。</li>
<li>注意事项<ul>
<li>属性值大的会压盖属性值小的，设置<code>z-index</code>属性的会压盖没有设置的。</li>
<li>如果属性值相同，比较<code>HTML</code>书写顺序，后写的压盖先写的。 </li>
<li><code>z-index</code>属性只能设置给定位的元素才会生效，如果给没有定位的元素设置，不会生效。</li>
<li>父子盒模型中，如果父子盒子都进行了定位，与其他的父子级有压盖的部分<ul>
<li>父级盒子：如果不设置<code>z-index</code>，后写的压盖先写的；如果设置了<code>z-index</code>，值大的压盖值小的。</li>
<li>子级盒子：如果父级没有设置<code>z-index</code>属性，子级<code>z-index</code>大的会压盖小的；如果父级设置了<code>z-index</code>值，无论子级值是多少，都是父级的值大的子级压盖父级值小的子级，俗称“从父效应”。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（八）背景</title>
    <url>/2021/08/159520271b03/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><code>CSS</code> 中除了布局类属性，还需要添加一些背景类的内容进行页面的修饰，从而让网页变得更加的美观。</p>
<p><code>CSS</code> 中通过 <code>background</code> 属性来设置背景，它是一个综合属性，可以拆分成多个单一属性。</p>
<h3 id="背景颜色-background-color"><a href="#背景颜色-background-color" class="headerlink" title="背景颜色 background-color"></a>背景颜色 <code>background-color</code></h3><ul>
<li>属性名：<code>background-color</code></li>
<li>作用：在盒子区域添加背景颜色的修饰。</li>
<li>加载区域：在 <code>border</code> 及以内加载背景颜色。</li>
<li>属性值：颜色名、颜色值。</li>
</ul>
<h3 id="背景图片-background-image"><a href="#背景图片-background-image" class="headerlink" title="背景图片 background-image"></a>背景图片 <code>background-image</code></h3><ul>
<li>属性名：<code>background-image</code></li>
<li>作用：给盒子添加图片的背景修饰。</li>
<li>加载范围：默认的加载到边框及以内部分。后期如果图片不重复加载，加载从 <code>border</code> 以内开始。</li>
<li>属性值：<code>url(图片路径)</code></li>
<li><code>url</code>：<code>uniform resource locator</code>，统一资源定位符，小括号内部书写查找图片的路径。<ul>
<li><code>background-image: url(images/meng.jpg);</code></li>
<li>如果图片不重复，从 <code>border</code> 以内开始加载。</li>
<li>背景图和背景颜色可以同时设置，背景图会压盖背景颜色，没有背景图的区域会显示背景颜色。</li>
</ul>
</li>
</ul>
<h3 id="背景重复-background-repeat"><a href="#背景重复-background-repeat" class="headerlink" title="背景重复 background-repeat"></a>背景重复 <code>background-repeat</code></h3><ul>
<li><p>属性名：<code>background-repeat</code></p>
</li>
<li><p>作用：设置添加的背景图是否要在盒子中重复进行加载。</p>
</li>
<li><p>根据属性值不同，有四种重复加载方式。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>repeat</code></td>
<td>重复，默认属性值，表示会使用背景图片重复加载填满整个盒子背景区域</td>
</tr>
<tr>
<td><code>no­repeat</code></td>
<td>不重复，不论背景图是否大于盒子范围，都只加载一次图片</td>
</tr>
<tr>
<td><code>repeat-x</code></td>
<td>水平重复，使用背景图片水平重复加载铺满第一行，垂直方向不重复</td>
</tr>
<tr>
<td><code>repeat-y</code></td>
<td>垂直重复，使用背景图片垂直重复加载铺满第一列，水平方向不重复</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="背景定位-background-position"><a href="#背景定位-background-position" class="headerlink" title="背景定位 background-position"></a>背景定位 <code>background-position</code></h3><ul>
<li>属性名：<code>background-position</code></li>
<li>作用：主要用于设置不重复的图片在背景区域的加载开始位置。</li>
<li>属性值：分为三种写法，单词表示法、像素表示法、百分比表示法。不论哪种写法，属性值都有两个，值之间用空格分隔。</li>
<li>第一个属性值：表示背景图片在水平方向的位置。</li>
<li>第二个属性值：表示背景图片在垂直方向的位置。</li>
<li>单词表示法<ul>
<li>属性值都是使用代表方向的单词进行书写。</li>
<li>水平方向可选单词：<code>left</code>、<code>center</code>、<code>right</code></li>
<li>垂直方向可选单词：<code>top</code>、<code>center</code>、<code>bottom</code></li>
<li>单词表示图片与盒子背景区域进行对应方向的对齐。</li>
</ul>
</li>
<li>像素表示法<ul>
<li>使用像素值作为背景定位的属性值。</li>
<li>第一个属性值：像素是几，表示背景图片左上角针对 <code>border</code> 以内的左上顶点水平方向位移的距离。</li>
<li>第二个属性值：像素是几，表示背景图片左上角针对 <code>border</code> 以内的左上顶点垂直方向位移的距离。</li>
<li>像素值区分正负，正负代表位移方向不同<ul>
<li>正数：表示图片针对盒子的原点向右、向下移动。</li>
<li>负数：表示图片针对盒子的原点向左、向上移动。</li>
</ul>
</li>
<li>可以利用属性值为负数，制作在小盒子中显示大的背景图的一部分。制作方法，需要使用 <code>FW</code> 软件量取尺寸，读取数据。<ul>
<li>第一步：在设计图中，使用切片工具制作一个想要显示区域大小的切片，让切片左上顶点位于想要加载的背景部分。</li>
<li>第二步：读取属性栏的切片数据，其中宽、高就是要加载的盒子的宽高，x 和 y 的数值表示移动的距离的绝对值，直接将数值加负号赋值给背景定位属性。</li>
</ul>
</li>
</ul>
</li>
<li>百分比表示法<ul>
<li>百分比表示法使用百分比数字作为属性值。</li>
<li>100%代表的数值<ul>
<li>水平方向，等价于盒子的<code>border</code>以内的背景区域宽度减去图片的宽度。</li>
<li>垂直方向，等价于盒子的<code>border</code>以内的背景区域高度减去图片的高度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="背景附着-background-attachment"><a href="#背景附着-background-attachment" class="headerlink" title="背景附着 background-attachment"></a>背景附着 <code>background-attachment</code></h3><ul>
<li><p>属性名：<code>background-attachment</code></p>
</li>
<li><p>作用：设置的是背景图片是否要随着页面或者盒子的滚动而滚动。</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>scroll</code></td>
<td>滚动的，表示背景图片与盒子保持相对位置不变，随着页面的滚动而滚走。</td>
</tr>
<tr>
<td><code>fiexd</code></td>
<td>固定的，背景图的定位的参考点从盒子 <code>border</code> 以内的左上顶点变为了浏览器窗口的左上顶点，页面滚动时，浏览器窗口的左上顶点是不变的，导致背景图固定在浏览器窗口的某个位置，不会随着页面滚动而滚走。</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="综合写法-background"><a href="#综合写法-background" class="headerlink" title="综合写法 background"></a>综合写法 <code>background</code></h3><ul>
<li><p><code>background</code> 属性可以将五个单一属性的值进行合写。</p>
</li>
<li><p>属性值：可以有 1-5 个属性值，值之间用空格进行分隔，背景定位的两个属性值算作一个属性值，不能被分开也不能颠倒顺序。五个属性值之间可以互换位置。</p>
</li>
<li><p>注意事项</p>
<ul>
<li>如果属性值没有设置完全，其他没有设置的单一属性会按照默认值加载。</li>
<li>如果想去层叠综合属性中的一部分，其他的属性保持不变，最好使用单一属性写法进行层叠。</li>
</ul>
</li>
</ul>
<h3 id="背景应用"><a href="#背景应用" class="headerlink" title="背景应用"></a>背景应用</h3><p>背景属性在实际应用中有很多使用场景，我们需要了解几个比较常见的场景。</p>
<ul>
<li><p>场景一：替换插入图</p>
<ul>
<li><code>&lt;h1&gt;</code> 标签是权重最高的标签，一般会在内部书写最重要的内容，比如 <code>logo</code> 图片、最大的标题等。</li>
<li>另外 <code>&lt;h1&gt;</code> 内部的文字，可以帮助提高 <code>SEO</code> 搜索排名。</li>
<li>在设置的是 <code>logo</code> 图片时，如果使用插入图，就不能书写搜索关键字。</li>
<li>背景图替换插入图方法<ul>
<li>如果想解决 <code>SEO</code> 问题，可以将 <code>HTML</code> 结构中，插入图换成搜索关键字，然后使用 <code>css</code> 添加背景图给 <code>&lt;a&gt;</code> 标签或 <code>&lt;h1&gt;</code> 标签。 </li>
</ul>
</li>
<li>文字隐藏方法<ul>
<li>将字号设置为 0。<code>IE8</code> 及以上或高版本浏览器可以隐藏文字，但是 <code>IE7</code> 及以下有兼容问题。</li>
<li>可以设置给 <code>&lt;a&gt;</code> 标签一个 <code>text-indent</code> 属性，属性值为负的很大的值，文字会走到盒子外部，直接再设置溢出隐藏属性，将溢出文字隐藏。</li>
</ul>
</li>
</ul>
</li>
<li><p>场景二：<code>padding</code> 区域背景图</p>
<p><img src="https://pic.imgdb.cn/item/616e2c862ab3f51d91773302.png"></p>
<ul>
<li>制作方法<ul>
<li>在一个盒子中有背景图部分，而且有文字内容，文字会让开背景图区域进行加载，背景区域应该使用 padding 挤出位置。</li>
<li>四个方向的 padding 都可能用于添加背景图。 </li>
</ul>
</li>
</ul>
</li>
<li><p>场景三：精灵图技术</p>
<ul>
<li>当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。</li>
<li>然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。</li>
<li>为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了 <code>CSS</code> 精灵技术（也称 <code>CSS Sprites</code>、<code>CSS 雪碧</code>）。</li>
<li><code>css</code> 精灵<ul>
<li><code>css</code> 精灵是一种处理网页背景图像的方式。</li>
<li>它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。</li>
<li>通常情况下，这个由很多小的背景图像合成的大图被称为精灵图。</li>
<li><code>css</code> 精灵的技术依据<ul>
<li>将网页中需要用到的小尺寸背景图制作成一张背景透明的 <code>png</code> 图片。</li>
<li>利用背景定位技术，将精灵图的每个小图片加载到对应的标签上。 </li>
</ul>
</li>
<li>制作精灵图的注意事项<ul>
<li>精灵图上放的都是小的装饰性质的背景图片，插入图片不能往上放。 </li>
<li>精灵图的宽度取决于最宽的那个背景图片的标签宽度。 </li>
<li>精灵图可以横向摆放也可以纵向摆放，但是每个图片之间必须留够足够的空白，保证背景图片加载到一个标签内部时，不能出现多余内容。</li>
<li>在精灵图的最底端，尽量留一点空白，方便以后添加其他精灵图。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CSS3-新增背景属性"><a href="#CSS3-新增背景属性" class="headerlink" title="CSS3 新增背景属性"></a><code>CSS3</code> 新增背景属性</h3><h4 id="背景半透明"><a href="#背景半透明" class="headerlink" title="背景半透明"></a>背景半透明</h4><ul>
<li><code>CSS3</code> 支持背景半透明的写法，颜色值增加了一种 <code>rgba</code> 模式。</li>
<li><code>rgba</code> 模式：在 <code>rgb</code> 基础上增加了一个不透明度的设置，不透明度 <code>alpha</code> 取值范围在 0-1 之间，0 表示完全透明，1 表示完全不透明，0.5 表示半透明。</li>
<li>书写方式：<code>rgba(红色，绿色，蓝色，不透明度)</code> </li>
<li>注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不受影响。</li>
<li>半透明其他应用：可以给文字和边框透明，都是 <code>rgba</code> 的格式来写。</li>
</ul>
<h4 id="背景缩放-background-size"><a href="#背景缩放-background-size" class="headerlink" title="背景缩放 background-size"></a>背景缩放 <code>background-size</code></h4><p>通过 <code>background-size</code> 设置背景图片的尺寸，就像我们设置 <code>&lt;img&gt;</code> 的尺寸一样，在移动 <code>Web</code> 开发中做屏幕适配应用非常广泛。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>px</code>值</td>
<td>1-2个像素值，只设置1个值，垂直方向等比例拉伸；设置2个值，按照设置值加载。</td>
</tr>
<tr>
<td>百分比</td>
<td>同像素值设置方法相同，设置百分比时，数值参照盒子的宽、高属性</td>
</tr>
<tr>
<td><code>cover</code></td>
<td>自动调整缩放比例，把背景图像扩展至足够大，以使<strong>背景图像完全覆盖背景区域</strong>。如有溢出部分则会被隐藏。</td>
</tr>
<tr>
<td><code>contain</code></td>
<td>自动调整缩放比例，把图像图像扩展至最大尺寸，<strong>保证图片始终完整显示</strong>在背景区域。</td>
</tr>
</tbody></table>
<h4 id="多背景"><a href="#多背景" class="headerlink" title="多背景"></a>多背景</h4><ul>
<li><code>CSS3</code> 中规定，一个盒子上，可以添加多个背景图片。</li>
<li><code>background-image</code> 的属性值书写时，以逗号分隔多背景的 <code>URL</code>路径地址。</li>
<li>注意：背景加载时，先写的背景压盖后写的背景图片。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（七）a标签的伪类</title>
    <url>/2021/08/916d87fabf67/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>伪类和类之间有一定的相似之处，也存在明显的区别。</li>
<li>普通的类：必须给标签设置对应的 class 属性值，才能选中标签，而且类选择器后面添加的属性，会立即加载到浏览器之上。</li>
<li>伪类：不需要给标签添加任何属性，伪类名都是语法提前规定好的，书写时伪类必须搭配其他选择器使用，伪类选择器后面添加的样式不一定立即加载到浏览器之上，只有用户触发了对应的行为，伪类的样式才会立即加载。</li>
<li>伪类选择器的权重与普通的类选择器相同。</li>
<li>伪类选择器写法：前面是普通的选择器，后面紧跟:伪类名。</li>
</ul>
<h3 id="lt-a-gt-标签的伪类"><a href="#lt-a-gt-标签的伪类" class="headerlink" title="&lt;a&gt;标签的伪类"></a><code>&lt;a&gt;</code>标签的伪类</h3><p><code>&lt;a&gt;</code> 标签可以根据用户行为不同，划分为四种状态，通过<code>&lt;a&gt;</code> 标签的伪类可以将四种状态选中设置为不同的样式效果，用户触发对应行为，就可以加载对应的样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123; <span class="comment">/* 访问前状态 */</span></span><br><span class="line">  <span class="attribute">color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="comment">/* 访问后状态 */</span></span><br><span class="line">  <span class="attribute">color</span>: cyan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="comment">/* 鼠标悬浮状态 */</span></span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123; <span class="comment">/* 鼠标点击状态 */</span></span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lt-a-gt-标签的伪类书写顺序"><a href="#lt-a-gt-标签的伪类书写顺序" class="headerlink" title="&lt;a&gt; 标签的伪类书写顺序"></a><code>&lt;a&gt;</code> 标签的伪类书写顺序</h3><ul>
<li><code>&lt;a&gt;</code> 标签上可能会同时触发 2 到 3 个状态，每个状态的属性都会进行加载，相同的属性之间会发生层叠。</li>
<li>伪类的权重是相同的，只能根据书写顺序，后写的层叠先写的，所以伪类书写顺序非常重要。</li>
<li>要想让每个伪类的状态正常加载，书写顺序必须是：访问前<code>link</code>、访问后<code>visited</code>、鼠标移上<code>hover</code>、鼠标点击<code>active</code>。</li>
</ul>
<h3 id="lt-a-gt-标签的伪类实际应用"><a href="#lt-a-gt-标签的伪类实际应用" class="headerlink" title="&lt;a&gt; 标签的伪类实际应用"></a><code>&lt;a&gt;</code> 标签的伪类实际应用</h3><ul>
<li>一般会将访问前和访问后状态设置为一样的效果，保证了页面的统一性，可以选择性的设置鼠标移上和鼠标点击状态。</li>
<li>更加常用的一种设置方式如下<ul>
<li><code>&lt;a&gt;</code> 标签任何普通的选择器，可以同时选中四种状态，可以将四种状态设置为相同的样式，属性可以设置所有的 <code>&lt;a&gt;</code> 默认显示样式的属性，包括盒模型、文字等。</li>
<li><code>a:hover</code> 伪类选择器：设置鼠标移上时不一样的样式属性。</li>
</ul>
</li>
<li>注意：其他标签也可以设置 <code>:hover</code> 伪类状态。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（六）浮动</title>
    <url>/2021/08/c1a7e041e208/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="浮动定义"><a href="#浮动定义" class="headerlink" title="浮动定义"></a>浮动定义</h3><ul>
<li><p>浮动是一种非常重要的布局属性。 </p>
</li>
<li><p>属性名：<code>float</code>，漂流、浮动的意思。 </p>
</li>
<li><p>属性值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code></td>
<td>左浮动</td>
</tr>
<tr>
<td><code>right</code></td>
<td>右浮动</td>
</tr>
</tbody></table>
</li>
<li><p>作用：让元素脱离标准流，同一级的浮动的元素可以并排在一排显示。</p>
</li>
</ul>
<h3 id="浮动的性质"><a href="#浮动的性质" class="headerlink" title="浮动的性质"></a>浮动的性质</h3><p>为了更好的利用浮动进行布局，我们需要了解浮动相关的性质。</p>
<ul>
<li><p>浮动的元素脱离标准流</p>
<ul>
<li>标准文档流特点：区分行块。<ul>
<li>块级元素：可以设置宽高，必须独占一行。 </li>
<li>行内元素：不能设置宽高，可以并排一行。</li>
</ul>
</li>
<li>浮动的元素脱离了标准流的限制，具备行块二象性，浮动的元素可以设置宽高，还可以并排一行，而且不会有空白折叠现象，如果元素不设置宽高，可以被元素内容自动撑开。</li>
</ul>
</li>
<li><p>浮动的元素依次贴边</p>
<ul>
<li><p>浮动属性值：<code>left</code>、<code>right</code>。</p>
</li>
<li><p>浮动方向设置不同，进行布局时，加载位置方向不同。 </p>
</li>
<li><p>以 <code>left</code> 为例：</p>
<ul>
<li><p><code>父元素</code>宽度足够，所有<code>子元素</code>会按照<code>HTML</code>书写顺序，依次向左进行贴边，<code>父元素左边</code>←<code>子元素1</code>←<code>子元素2</code>←<code>子元素3</code>←<code>子元素4</code>。</p>
</li>
<li><p>浮动前</p>
<p><img src="https://pic.imgdb.cn/item/616d488b2ab3f51d91ca8955.png"></p>
</li>
<li><p>浮动后：并排一排，<code>父元素</code>宽度足够。</p>
<p><img src="https://pic.imgdb.cn/item/616d487f2ab3f51d91ca817d.png"></p>
</li>
<li><p><code>父元素</code>宽度如果不够，例如不能放下一个<code>子元素4</code>，那么<code>子元素4</code>在贴边时，会跳过上一个<code>子元素3</code>，向更上一个<code>子元素2</code>进行贴边，如果<code>子元素2</code>后面位置不够，继续跳过<code>子元素2</code>向前面的<code>子元素1</code>进行贴边。</p>
<p><img src="https://pic.imgdb.cn/item/616d487f2ab3f51d91ca8187.png"></p>
</li>
<li><p>如果<code>子元素4</code>在跳过<code>子元素3</code>向更前面的<code>子元素2</code>贴边时，<code>子元素2</code>的高度不高于<code>子元素3</code>，<code>子元素2</code>没有延伸出一个高度的边让<code>子元素4</code>贴边，那么<code>子元素4</code>就会跳过<code>子元素2</code>向<code>子元素1</code>进行贴边。</p>
<p><img src="https://pic.imgdb.cn/item/616d488b2ab3f51d91ca8950.png"></p>
</li>
<li><p>如果贴边的这个<code>子元素4</code>宽度小于<code>子元素2</code>，<code>子元素2</code>的高度低于<code>子元素1</code>和<code>子元素3</code>，形成一个凹陷，<code>子元素4</code>会受前面<code>子元素3</code>高度影响，不会出现钻空现象。</p>
<p><img src="https://pic.imgdb.cn/item/616d487f2ab3f51d91ca8182.png"></p>
</li>
<li><p>如果<code>子元素1</code>后面的距离也放不下<code>子元素4</code>，<code>子元素4</code>最终会贴到<code>父元素</code>左边，如果<code>子元素4</code>的宽度超过了<code>父元素</code>，只会出现溢出现象。</p>
<p><img src="https://pic.imgdb.cn/item/616d487f2ab3f51d91ca818f.png"></p>
</li>
<li><p>右浮动与左浮动贴边效果是一致的，只是贴边方向不同。按照 <code>HTML</code> 书写顺序依次向右向上一个元素贴边，第一个元素贴<code>父元素</code>的右边。</p>
<p><img src="https://pic.imgdb.cn/item/616d487f2ab3f51d91ca81a0.png"></p>
</li>
</ul>
</li>
<li><p>贴边性质应用：利用浮动的这个依次贴边性质，可以完成多种网页布局效果。例如：平均分布表格效果、导航栏效果、常见的电商或企业网站布局。</p>
</li>
</ul>
</li>
<li><p>浮动的元素没有<code>margin</code>塌陷</p>
<ul>
<li><code>margin</code> 塌陷现象出现在标准流中的，浮动元素已经脱离标准流，不再具有 <code>margin</code> 塌陷现象。</li>
</ul>
</li>
<li><p>浮动的元素让出标准流位置</p>
<ul>
<li>元素浮动之后，脱离了标准流，会将原来占有的标准流位置让给后面的一个同级元素。</li>
<li>在 <code>IE6</code> 、 <code>IE7</code>浏览器中，有兼容问题</li>
<li>由于浏览器中有兼容性问题，不会使用这种属性制作压盖效果，真正的压盖效果使用定位制作。</li>
<li>如果没有特殊需求，不允许一个父元素中的子元素有的浮动有的不浮动，同级元素中有一个浮动其他的也要浮动。</li>
</ul>
</li>
<li><p>字围现象</p>
<ul>
<li><p>与前面压盖效果结构类似，同级元素中前面的元素浮动，后面的元素不浮动，不浮动的元素内部还有一些文字，浮动的蓝盒子会压盖住粉盒子的一部分，但是文字内容不会被盖住，粉盒子中的文字会让开蓝盒子位置，围绕它进行加载。这种效果称为字围现象。</p>
<p><img src="https://pic.imgdb.cn/item/616d4afd2ab3f51d91cc4bd3.png"></p>
</li>
<li><p>可以利用字围现象制作一些特殊的图文混排布局效果</p>
</li>
</ul>
</li>
</ul>
<h3 id="浮动的问题"><a href="#浮动的问题" class="headerlink" title="浮动的问题"></a>浮动的问题</h3><ul>
<li>标准流中的元素，不设置高度的情况下，都能被内部的标准流元素自动撑高。 如果内部的子元素进行了浮动，浮动的子元素是撑不高标准流父亲的。</li>
<li>父元素没有高度，会影响后面元素的标准流位置，如果浮动的子元素足够高时，有可能影响到后面浮动元素的贴边。</li>
</ul>
<h3 id="清除浮动方法"><a href="#清除浮动方法" class="headerlink" title="清除浮动方法"></a>清除浮动方法</h3><ul>
<li><p>给标准流的父元素强制给一个合适的高度<code>height</code></p>
<ul>
<li>解决：父元素有了高度，前面的浮动不能影响后面元素的标准流位置和贴边。 </li>
<li>问题：父元素高度不是自适应，一旦子元素高度变化，问题可能再次出现。</li>
</ul>
</li>
<li><p><code>clear</code>属性</p>
<ul>
<li><p><code>clear</code>，清除。</p>
</li>
<li><p>作用：清除标签元素自身受到的前面的浮动元素的影响。</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code></td>
<td>清除前面左浮动带来的影响</td>
</tr>
<tr>
<td><code>right</code></td>
<td>清除前面右浮动带来的影响</td>
</tr>
<tr>
<td><code>both</code></td>
<td>清除前面所有浮动带来的影响</td>
</tr>
</tbody></table>
</li>
<li><p>给标准流父元素添加 <code>clear</code> 属性，父元素不受前面浮动影响，不会再占有浮动让出的位置。</p>
</li>
<li><p><code>clear: both;</code></p>
<ul>
<li>解决：浮动元素影响后面元素标准流位置和贴边。</li>
<li>问题：父元素不能高度自适应，两个父元素之间如果有 <code>margin</code> 效果不正确。 </li>
</ul>
</li>
</ul>
</li>
<li><p>隔墙法</p>
<ul>
<li>外墙法<ul>
<li>在两个大的父盒子之间，添加一个空的 <code>&lt;div&gt;</code> 标签，标签上带有 <code>clear：both</code> 属性。</li>
<li>解决：浮动影响后面元素标准流位置和贴边，模拟父元素间的距离。</li>
<li>问题：父元素没有高度自适应。</li>
</ul>
</li>
<li>内墙法<ul>
<li>在父元素内部，所有的浮动子元素后面添加一个空的 <code>&lt;div&gt;</code> 元素，标签高度为 0，添加 <code>clear</code> 属性。</li>
<li>解决：父元素高度自适应，浮动影响后面的元素位置和贴边。 </li>
<li>缺点：浮动是 <code>css</code> 样式属性带来的问题，内墙法使用 <code>HTML</code> 结构去辅助解决问题，如果页面中浮动元素很多，需要添加多个没有语义的空标签，造成 <code>HTML</code> 结构的冗余。</li>
</ul>
</li>
</ul>
</li>
<li><p>伪类</p>
<ul>
<li>本质是使用伪类方法利用<code>css</code>代码书写一堵内墙。</li>
<li>伪类选择器：通过选中的标签添加伪类，去选中标签的某个状态或位置。</li>
<li><code>:after</code>：这个伪类表示选中的是某个标签内部的最后的位置。</li>
<li>书写方法：前面必须加普通的选择器，后面连续书写伪类名称。</li>
<li>将伪类添加给一个选中父盒子的选择器后面，一般给需要清除浮动的父盒子设置一个<code>clearfix</code>的类名。</li>
<li>解决：父元素高度自适应，浮动影响后面的元素位置和贴边。 </li>
</ul>
</li>
<li><p>溢出隐藏</p>
<ul>
<li>小偏方：给内部有浮动子元素的父元素添加溢出隐藏 <code>overflow: hidden;</code> 属性，可以解决浮动的所有问题。</li>
<li>元素高度设置后，<code>overflow：hidden；</code>效果是将超过高度的部分直接隐藏。 </li>
<li>元素高度没有设置时，如果元素同时设置了<code>overflow：hidden</code>属性，元素会自适应内容的高度。</li>
<li>高度自适应原因：一个元素没有设置高度，同时设置了溢出隐藏，浏览器在加载盒子尺寸时，遇到溢出隐藏浏览器会强制性去检索内部的子元素的高度，不论子元素是标准流还是浮动，都会将最高的高度作为父盒子高度加载。 </li>
<li>浮动影响后面的元素：父元素有了高度后，可以管理住内部所有的浮动元素，不会延伸到后面标签中影响贴边。</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>如果父元素高度是固定的，建议使用 <code>height</code> 属性解决。</li>
<li>如果父元素高度需要自适应，建议使用 <code>overflow</code> 属性解决浮动问题。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（五）文档流及显示模式</title>
    <url>/2021/08/1910e3869cce/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在我们遇到的 <code>HTML</code> 元素中，有的标签元素如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 等在浏览器中加载时必须独自占满一行，有的标签元素如 <code>&lt;a&gt;</code> 、<code>&lt;span&gt;</code>等则不会独占一行，原因是什么？</p>
<h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><ul>
<li>标准文档流，指的是元素排版布局过程中，元素会默认自动从左往右，从上往下的流式排列方式。前面内容发生了变化，后面的内容位置也会随着发生变化。</li>
<li>HTML就是一种标准文档流文件。 </li>
<li>HTML中的标准文档流特点通过两种方式体现：微观现象和元素等级。</li>
</ul>
<h4 id="微观现象"><a href="#微观现象" class="headerlink" title="微观现象"></a>微观现象</h4><ul>
<li>空白折叠现象。</li>
<li>文字类的元素如果排在一行会出现一种高低不齐、底边对齐效果。</li>
<li>自动换行，元素内一行内容写满元素的 <code>width</code> 时会自动进行换行。</li>
</ul>
<h4 id="元素等级"><a href="#元素等级" class="headerlink" title="元素等级"></a>元素等级</h4><ul>
<li>在标准流中，大部分元素是区分等级的，习惯将元素划分为几种常见的加载级别：块级元素、行内元素、行内块元素等。 </li>
<li>块级元素：大部分容器级标签包括p标签都是块级元素，比如 <code>&lt;div&gt;</code> 、<code>&lt;h1&gt;</code> 等。</li>
<li>行内元素：大部分的文本级标签，比如 <code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;b&gt;</code> 等。</li>
<li>行内块元素：比如 <code>&lt;img&gt;</code>、<code>&lt;input&gt;</code> 等。</li>
<li>各种等级的元素有自己的加载特点。</li>
</ul>
<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><ul>
<li><strong>块级元素可以设置宽高，在浏览器中正常加载。</strong></li>
<li><strong>块级元素必须独占一行，不能与其他任何标签并排一行。</strong></li>
<li>块级元素如果不设置宽度，会自动撑满父级的 <code>width</code> 区域；高度不设置，会被内容自动撑开高度。</li>
</ul>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><ul>
<li><strong>行内元素不能正常加载宽度和高度属性，其他的盒模型属性虽然能设置，但是容易出现加载问题。</strong></li>
<li><strong>行内元素可以与其他的行内或行内块元素并排一行显示。</strong></li>
<li>行内元素不论是否设置宽高，宽度和高度都只能被内容自动撑开。</li>
</ul>
<h4 id="行内块元素"><a href="#行内块元素" class="headerlink" title="行内块元素"></a>行内块元素</h4><ul>
<li><strong>行内块元素可以设置宽度和高度。</strong></li>
<li><strong>行内块元素可以与其他的行内或行内块并排一行显示</strong>。</li>
<li><strong>行内块元素如果不设置宽高，要么以原始尺寸加载要么被内容自动撑开。</strong></li>
<li><strong>行内块依旧具有标准流的微观性质，例如空白折叠现象。</strong></li>
</ul>
<h3 id="显示模式-display"><a href="#显示模式-display" class="headerlink" title="显示模式 display"></a>显示模式 <code>display</code></h3><ul>
<li><p>标准流中的元素有自己默认的浏览器加载模式，但是加载模式不是一成不变的，后期可以通过 <code>display</code> 属性更改一个标签的显示模式。 </p>
</li>
<li><p>属性值：元素根据属性值不同，可以加载对应元素等级的显示模式的特点。</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>block</code></td>
<td>表示元素要以块级元素模式加载，具备块级特点</td>
</tr>
<tr>
<td><code>inline</code></td>
<td>表示元素要以行内元素模式加载，具备行内特点</td>
</tr>
<tr>
<td><code>inline-block</code></td>
<td>表示标签要以行内块模式加载，具备行内块特点</td>
</tr>
<tr>
<td><code>none</code></td>
<td>表示标签及内部内容直接隐藏，让出原有标准流的位置</td>
</tr>
</tbody></table>
</li>
<li><p>脱离标准流</p>
<ul>
<li><code>display</code> 属性更改的显示模式并没有改变标准流本质性质，页面还是只能从上往下加载，存在空白折叠现象等微观性质。要想实现更多的界面布局效果需要脱离标准流的限制。</li>
<li>标签元素脱离标准流的方法包括：浮动、绝对定位、固定定位。 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（四）盒模型拓展</title>
    <url>/2021/08/dbe127acbd8a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>虽然我们了解了盒模型的五个属性的基本语法，但是在实际工作中还有更多的方法和技巧需要掌握，因此，我们需要扩展对盒模型的应用知识。</p>
<h3 id="清除默认样式"><a href="#清除默认样式" class="headerlink" title="清除默认样式"></a>清除默认样式</h3><ul>
<li>大部分标签都有一个浏览器加载的默认样式，会对布局造成一些影响。为了避免默认样式对整体布局效果造成影响，一定要清除默认样式。</li>
<li>盒模型属性中内外边距：大部分容器级标签都有默认边距，要么用标签选择器的并集方式，要么通配符清除。</li>
<li><code>&lt;ul&gt;</code> 和 <code>&lt;ol&gt;</code> 两种列表有默认的列表前缀：清除 <code>list-style</code> 属性。 </li>
<li><code>&lt;a&gt;</code> 标签的默认样式，顺带设置页面中常用的<code>a</code>的公共样式：设置 <code>color</code> 和 <code>text-decoration</code>。</li>
<li>清除默认加粗效果：设置<code>font-weight</code>。</li>
<li>还可以给 <code>&lt;body&gt;</code> 标签设置整体文字样式，让大部分后代标签全部去继承。</li>
</ul>
<h3 id="高度-height-应用"><a href="#高度-height-应用" class="headerlink" title="高度 height 应用"></a>高度 <code>height</code> 应用</h3><ul>
<li>根据不同的需求，高度属性可以设置也可以不设置。</li>
<li>如果设置了高度：盒子占有的高度位置就确定死了，后面的同级元素会紧挨着加载。</li>
<li>如果不设置高度：会根据标签内部内容高度自动撑开。</li>
<li>以 <code>&lt;div&gt;</code> 标签为例，根据情况不同选择是否设置高度<ul>
<li>必须设置高度<ul>
<li>设计图中盒子高度占位是固定的，后面同级元素在高度下面加载。</li>
<li>自身盒子内部内容过多会溢出盒子区域。</li>
</ul>
</li>
<li><code>overflow</code> 属性<ul>
<li>设置了高度的盒子，如果内部元素的加载高度超过父级，会出现溢出效果。</li>
<li>可以通过一个溢出的属性 <code>overflow</code>，进行溢出部分内容的显示效果设置。</li>
</ul>
</li>
<li>必须不设置高度<ul>
<li>要求盒子高度必须自适应内部内容的高度。</li>
<li>或者设置<code>height</code>的属性值是自动的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><ul>
<li>在网页中经常见到元素或者文字居中的效果。</li>
<li>文本水平居中<ul>
<li>水平居中：<code>text-align</code>属性。</li>
<li>不论单行或多行都可以设置。</li>
</ul>
</li>
<li>文本垂直居中<ul>
<li>单行文本垂直居中：让文字行高 <code>line-height</code> 等于盒子高度 <code>height</code>。</li>
<li>多行文本垂直居中：让元素高度自适应或者正好等于多行文字的高度，设置元素内边距上下值相同。</li>
</ul>
</li>
<li>元素垂直居中<ul>
<li>个元素内部嵌套的子元素，在父元素中居中。</li>
<li>垂直居中：与多行文字类似，让父元素高度自适应，子元素高度自动撑开父级的高度，再给父元素设置相同的上下边距。 </li>
</ul>
</li>
<li>元素水平居中<ul>
<li>针对类似 <code>&lt;div&gt;</code> 样式上必须独占一行的盒子，如果<strong>子盒子宽度低于父盒子宽度</strong>，可以设置子盒子的 <code>margin</code> 值，水平方向的值都设置为 <code>auto</code>。</li>
<li>原因：<code>auto</code> 只在水平方向有作用，水平方向的 <code>margin</code> 如果设置为 <code>auto</code>，边距会自动无限增大，直到撑满整个父元素除了子元素宽度之外剩余的区域，如果两个水平方向都是 <code>auto</code>，两边都要无限大，只能达到一个平衡，两边距离相同，导致盒子居中。</li>
</ul>
</li>
</ul>
<h3 id="父子盒模型"><a href="#父子盒模型" class="headerlink" title="父子盒模型"></a>父子盒模型</h3><ul>
<li>一般情况下，一个父元素内部可以放一个或多个子元素，而且多个子元素要排成一行显示，必须保证父元素的宽度一定要足够（不考虑溢出情况），需要遵循一个设置尺寸的规律：所有子元素的宽度加在一起不能大于父元素的宽度 <code>width</code>。</li>
<li>父元素的<code>width</code> ≥ 所有子元素<code>width</code> + <code>padding</code> + <code>border</code> + <code>margin</code> 如果不满足条件：要么多余的子元素掉下来不能在一排，要么溢出父元素</li>
<li>特殊情况：盒模型自动内减<ul>
<li>父子盒模型中，只有一个子元素，且子元素是类似 <code>&lt;div&gt;</code> 标签必须占一行的。</li>
<li>不设置子元素的 <code>width</code> 属性，子元素的 <code>width</code> 属性值会自动加载父级元素的 <code>width</code>。</li>
<li>如果同时设置了子元素水平方向的 <code>padding</code> 和 <code>border</code> 、<code>margin</code>，不需要手动去进行内减，子元素的 <code>width</code> 会自动收缩尺寸。子元素所有的水平方向的位置所有属性的加和等于父元素的 <code>width</code> 。</li>
</ul>
</li>
</ul>
<h3 id="margin-塌陷现象"><a href="#margin-塌陷现象" class="headerlink" title="margin 塌陷现象"></a><code>margin</code> 塌陷现象</h3><ul>
<li>在垂直方向如果有两个元素的外边距有相遇的，浏览器中加载的真正的外边距不是两个间距的加和，而是两个边距中值较大的，边距值小的塌陷到了边距值大的值内部。</li>
<li>同级元素塌陷<ul>
<li>上面的元素有下边距，下面的元素有上边距，两个边距相遇，真正的盒子间距离是较大的那个值。</li>
</ul>
</li>
<li>父子元素塌陷<ul>
<li>父子元素之间也会出现 <code>margin</code> 塌陷，父元素和子元素都设置了同方向的 <code>margin-top</code> 值，两个属性之间没有其他的内容进行隔离，导致两个属性相遇，发生 <code>margin</code> 塌陷。</li>
<li>本身父元素与上一个元素的距离是0，子元素如果设置了垂直方向的上边距，会带着父级一起掉下来。</li>
</ul>
</li>
<li>解决 <code>margin</code> 塌陷问题的方法 <ul>
<li>同级元素：如果两个元素垂直方向有间距，只需要设置给一个元素，不要进行拆分。 </li>
<li>父子元素：让两个边距不要相遇，中间可以使用父元素 <code>border</code> 或 <code>padding</code> 将边距分隔开；更加常用的方法，父子盒模型之间的距离就不要用儿子的 <code>margin</code> 去踹出来，而是父级的 <code>padding</code> 挤出来。</li>
</ul>
</li>
<li>另外注意：水平方向的 <code>margin</code> 没有塌陷现象。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（三）盒模型</title>
    <url>/2021/08/5fff91662ea7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul>
<li>盒模型又叫框模型，包含了五个用来描述盒子位置、尺寸的属性，分别是宽度 <code>width</code>、高度 <code>height</code>、内边距 <code>padding</code>、 边框 <code>border</code>、外边距 <code>margin</code>。</li>
</ul>
<h3 id="常见盒模型区域"><a href="#常见盒模型区域" class="headerlink" title="常见盒模型区域"></a>常见盒模型区域</h3><ul>
<li>盒模型的属性中，根据不同属性的效果，可以划分区域：</li>
<li>书写元素内容区域：<code>width</code>+<code>height</code></li>
<li>盒子可以实体化的区域：<code>width</code>+<code>height</code>+<code>padding</code>+<code>border</code> </li>
<li>盒子实际占位的位置：<code>width</code>+<code>height</code>+<code>padding</code>+<code>border</code>+<code>margin</code></li>
</ul>
<h3 id="盒模型图"><a href="#盒模型图" class="headerlink" title="盒模型图"></a>盒模型图</h3><ul>
<li>学习过程中，学会查看浏览器控制台中的盒模型图：</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/616d17732ab3f51d91a045af.png"></p>
<h3 id="宽度-width"><a href="#宽度-width" class="headerlink" title="宽度 width"></a>宽度 <code>width</code></h3><ul>
<li><p>作用：设置可以添加元素内容的区域的宽度。 </p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>默认值。浏览器可计算出实际的宽度。</td>
</tr>
<tr>
<td><code>px</code></td>
<td>像素值定义的宽度。</td>
</tr>
<tr>
<td><code>%</code></td>
<td>定义参考父元素宽度<code>width</code>的百分比宽度。</td>
</tr>
</tbody></table>
</li>
<li><p>特殊应用</p>
<ul>
<li>如果一个元素不添加<code>width</code> 属性，默认属性值为<code>auto</code>，不同的元素浏览器会根据其特点自动计算出实际宽度，例如 <code>&lt;div&gt;</code> 元素等独占一行的，其 <code>width</code> 属性的值会自动撑满父元素的 <code>width</code> 区域，如果是 <code>&lt;span&gt;</code> 元素等不需要独占一行的，其 <code>width</code> 属性的值是内部元素内容自动撑开的宽度。</li>
<li><code>&lt;body&gt;</code> 元素比较特殊，不需要设置 <code>width</code> 属性，宽度会自动适应浏览器窗口的宽度。</li>
</ul>
</li>
</ul>
<h3 id="高度-height"><a href="#高度-height" class="headerlink" title="高度 height"></a>高度 <code>height</code></h3><ul>
<li><p>作用：设置可以添加元素内容的区域的高度。 </p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>默认。浏览器会计算出实际的高度。</td>
</tr>
<tr>
<td><code>px</code></td>
<td>像素值定义的而高度。</td>
</tr>
<tr>
<td><code>%</code></td>
<td>定义参考父元素高度height的百分比高度。</td>
</tr>
</tbody></table>
<h3 id="特殊应用"><a href="#特殊应用" class="headerlink" title="特殊应用"></a>特殊应用</h3></li>
<li><p>如果一个元素不添加 <code>height</code> 属性，默认属性值为<code>auto</code>，浏览器会自动计算出实际高度，也就是是内部元素内容自动撑开的高度。元素的高度自适应内部内容的高度。</p>
</li>
</ul>
<h3 id="内边距-padding"><a href="#内边距-padding" class="headerlink" title="内边距 padding"></a>内边距 <code>padding</code></h3><ul>
<li>作用：设置的是元素的边框内部到宽高区域之间的距离。</li>
<li>特点：可以去加载背景，不能书写嵌套的内容。 </li>
<li>属性值：常用<code>px</code>为单位的数值。</li>
<li><code>padding</code> 是一个复合属性，可以根据内边距的方向不同划分为四个方向的单一属性。</li>
<li>单一属性：书写四个方向单一属性时，一般是按照顺时针规律书写：上、右、下、左。</li>
<li>简写<ul>
<li>有时为了简化书写，一般习惯将四个方向的单一属性进行合写成 <code>padding</code> 属性。</li>
<li><code>padding</code> 属性值：可以有 1-4 个值，值之间用空格进行分隔。</li>
<li>根据四个方向属性值不同，<code>padding</code> 有多种值的书写表示方法。</li>
<li>根据 <code>padding</code> 的属性值的个数不同，区分了四种表示法<ul>
<li>四值法：设置四个属性值，分配方向上、右、下、左。</li>
<li>三值法：设置三个值分配给上、左右、下。</li>
<li>二值法：设置两个值，分配给上下、左右。</li>
<li>单值法：设置属性值只有一个，分配方向上右下左，四边的值相同。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="边框-border"><a href="#边框-border" class="headerlink" title="边框 border"></a>边框 <code>border</code></h3><ul>
<li>作用：设置的是内边距外面的边界区域，作为盒子的实体化的最外层。 </li>
<li>属性值：由三个值组成，分为线的宽度、线的形状、线的颜色 。</li>
<li><code>border</code> 属性是一个复合属性，根据划分依据不同可以有两种单一属性的划分方式。</li>
<li>按照属性值的类型划分<ul>
<li>线宽：<code>border-width</code> </li>
<li>线型：<code>border-style</code> </li>
<li>颜色：<code>border-color</code></li>
</ul>
</li>
</ul>
<h3 id="线宽-border-width"><a href="#线宽-border-width" class="headerlink" title="线宽 border-width"></a>线宽 <code>border-width</code></h3><ul>
<li>作用：设置边框线的宽度。</li>
<li>属性值：常用<code>px</code>形式的数值，四个方向都有边框，属性值类似于 <code>padding</code>，也有四种值的写法。</li>
<li></li>
</ul>
<h3 id="线型-border-style"><a href="#线型-border-style" class="headerlink" title="线型 border-style"></a>线型 <code>border-style</code></h3><ul>
<li><p>作用：设置边框的线条形状。</p>
</li>
<li><p>属性值：形状的单词，总体也是类似 <code>padding</code> 的综合属性写法。</p>
</li>
<li><p>属性值的单词可能性</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>none</code></strong></td>
<td>定义无边框。</td>
</tr>
<tr>
<td><strong><code>solid</code></strong></td>
<td>定义实线。</td>
</tr>
<tr>
<td><strong><code>dashed</code></strong></td>
<td>定义虚线。在大多数浏览器中呈现为实线。</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>定义点状边框。在大多数浏览器中呈现为实线。</td>
</tr>
<tr>
<td><code>double</code></td>
<td>定义双线。双线的宽度等于<code>border-width</code>的值。</td>
</tr>
<tr>
<td><code>groove</code></td>
<td>定义<code>3D</code>凹槽边框。其效果取决于<code>border-color</code>的值。</td>
</tr>
<tr>
<td><code>ridge</code></td>
<td>定义<code>3D</code>垄状边框。其效果取决于<code>border-color</code>的值。</td>
</tr>
<tr>
<td><code>inset</code></td>
<td>定义<code>3D</code>内容凹陷效果。其效果取决于<code>border-color</code>的值。</td>
</tr>
<tr>
<td><code>outset</code></td>
<td>定义<code>3D</code>内容凸出效果。其效果取决于<code>border-color</code>的值。</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="边框颜色-border-color"><a href="#边框颜色-border-color" class="headerlink" title="边框颜色 border-color"></a>边框颜色 <code>border-color</code></h3><ul>
<li>作用：设置边框的颜色。</li>
<li>属性值：颜色名或颜色值，整体类似 <code>padding</code> 综合属性写法。</li>
<li>根据边框的方向划分<ul>
<li>上边框：<code>border-top</code></li>
<li>右边框：<code>border-right</code></li>
<li>下边框：<code>border-bottom</code></li>
<li>左边框：<code>border-left</code></li>
<li>每个单一属性都必须与复合属性 <code>border</code> 一致，设置三个属性值。</li>
</ul>
</li>
<li>根据方向和类型，进一步细分<ul>
<li>类似 <code>border-top</code> 的单一方向属性，也可以根据属性值类型继续进行单一属性划分。</li>
<li>单一属性写法：<code>border-方向-类型</code>。</li>
<li>注意：细分时必须先写方向划分再写类型划分，否则属性名错误。</li>
</ul>
</li>
</ul>
<h3 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距 margin"></a>外边距 <code>margin</code></h3><ul>
<li>作用：设置的是盒子与盒子之间的距离。</li>
<li>特点：不能渲染背景。 </li>
<li>属性值：常用 <code>px</code> 为单位的数值。</li>
<li>外边距的设置方式与内边距 <code>padding</code> 一模一样的。</li>
<li>单一属性<ul>
<li><code>margin‐top: 20px;</code></li>
<li><code>margin‐right: 20px;</code></li>
<li><code>margin‐left: 20px;</code></li>
<li><code>margin‐bottom: 10px;</code></li>
</ul>
</li>
<li>复合属性的四种值的写法<ul>
<li><code>margin: 10px 20px 30px 40px;</code></li>
<li><code>margin: 10px 20px 30px;</code></li>
<li><code>margin: 10px 20px;</code></li>
<li><code>margin: 10px;</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（二）文本类样式</title>
    <url>/2021/08/eb852cdecbf4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="颜色-color"><a href="#颜色-color" class="headerlink" title="颜色 color"></a>颜色 <code>color</code></h3><ul>
<li><p>作用：给文字设置颜色。</p>
</li>
<li><p>属性名 <code>k</code> ：<code>color</code></p>
</li>
<li><p>属性值 <code>v</code> ：颜色名、颜色值。</p>
</li>
<li><p>颜色名</p>
<ul>
<li><p>颜色名就是使用颜色的英文单词进行表示。 </p>
</li>
<li><p>需要记忆一些最常用的颜色名：</p>
<table>
<thead>
<tr>
<th>颜色</th>
<th>色值</th>
<th>颜色</th>
<th>色值</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td><code>red</code></td>
<td>黑色</td>
<td><code>black</code></td>
</tr>
<tr>
<td>橙色</td>
<td><code>orange</code></td>
<td>白色</td>
<td><code>white</code></td>
</tr>
<tr>
<td>黄色</td>
<td><code>yellow</code></td>
<td>金色</td>
<td><code>gold</code></td>
</tr>
<tr>
<td>绿色</td>
<td><code>green</code></td>
<td>粉色</td>
<td><code>pink</code></td>
</tr>
<tr>
<td>青色</td>
<td><code>cyan</code></td>
<td>浅黄色</td>
<td><code>lightyellow</code></td>
</tr>
<tr>
<td>蓝色</td>
<td><code>blue</code></td>
<td>黄绿色</td>
<td><code>yellowgreen</code></td>
</tr>
<tr>
<td>紫色</td>
<td><code>purple</code></td>
<td>天蓝色</td>
<td><code>skyblue</code></td>
</tr>
</tbody></table>
<p>更多的颜色名可以通过查询手册得到</p>
</li>
</ul>
</li>
<li><p>颜色值</p>
<ul>
<li><p>颜色值指使用具体颜色的数值表示。</p>
</li>
<li><p>包括： <code>rgb</code> 模式和十六进制模式写法。</p>
<ul>
<li><p><code>rgb</code> 模式</p>
<ul>
<li><p><code>rgb</code> 模式：是根据红绿蓝三原色进行混合而成的颜色模式。</p>
</li>
<li><p>每个原色的取值范围是0-255，一共256个数值。三个原色共能混合成1677多万种颜色。</p>
</li>
<li><p>书写方法：<code>rgb(红,绿,蓝)</code> </p>
</li>
<li><p>常用颜色的 <code>rgb</code> 色值： </p>
<table>
<thead>
<tr>
<th>颜色</th>
<th>色值</th>
<th>颜色</th>
<th>色值</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td><code>rgb(255,0,0)</code></td>
<td>黑色</td>
<td><code>rgb(0,0,0)</code></td>
</tr>
<tr>
<td>绿色</td>
<td><code>rgb(0,255,0)</code></td>
<td>白色</td>
<td><code>rgb(255,255,255)</code></td>
</tr>
<tr>
<td>蓝色</td>
<td><code>rgb(0,0,255)</code></td>
<td>灰色</td>
<td><code>rgb(128,128,128)</code></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>十六进制模式</p>
<ul>
<li><p>十六进制模式：是 <code>rgb</code> 模式的一种简化写法，使用十六进制的数字字符去替换十进制的 <code>0-255</code> 的数字。</p>
</li>
<li><p>十六进制：逢十六进一，每个数位上只能出现 <code>0-9</code>，<code>a-f</code> 之间的字符。 </p>
</li>
<li><p>书写为颜色值时，红、绿、蓝每个色值都要使用两位数的十六进制进行替换。</p>
<ul>
<li><code>0→00</code> </li>
<li><code>255→ff</code> </li>
</ul>
</li>
<li><p>书写方式：使用 <code>#</code> 开头，后面连续书写红、绿、蓝三个颜色的十六进制的两位数值。</p>
</li>
<li><p>常用颜色的十六进制色值：</p>
<table>
<thead>
<tr>
<th>颜色</th>
<th>色值</th>
<th>颜色</th>
<th>色值</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td><code>#ff0000</code></td>
<td><code>黑色</code></td>
<td><code>#000000</code></td>
</tr>
<tr>
<td>绿色</td>
<td><code>#00ff00</code></td>
<td>白色</td>
<td><code>#ffffff</code></td>
</tr>
<tr>
<td>蓝色</td>
<td><code>#0000ff</code></td>
<td>灰色</td>
<td><code>#808080</code></td>
</tr>
</tbody></table>
</li>
<li><p>十六进制颜色值简写模式：如果红、绿、蓝三个原色的色值每一个都是由重叠的数字组成，可以将重叠的数字简化成一个进行书写。</p>
<ul>
<li>红色<code>#f00</code> </li>
<li>绿色<code>#0f0</code> </li>
<li>蓝色<code>#00f</code> </li>
<li>类似 <code>#808080</code> 是不能进行简化的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="水平对齐text-align"><a href="#水平对齐text-align" class="headerlink" title="水平对齐text-align"></a>水平对齐<code>text-align</code></h3><ul>
<li><p>作用：设置文本水平方向的对齐。</p>
</li>
<li><p>在盒子中，不论文本是单行还是多行，都会对应方向对齐。</p>
</li>
<li><p>属性值：三个方向的单词 </p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>left</code></td>
<td>居左对齐，大部分标签的默认值</td>
</tr>
<tr>
<td><code>center</code></td>
<td>居中对齐</td>
</tr>
<tr>
<td><code>right</code></td>
<td>居右对齐</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="文本修饰text-decoration"><a href="#文本修饰text-decoration" class="headerlink" title="文本修饰text-decoration"></a>文本修饰<code>text-decoration</code></h3><ul>
<li><p>作用：设置文本整体是否有线条的修饰效果。</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>没有修饰，大部分标签的默认值</td>
</tr>
<tr>
<td><code>overline</code></td>
<td>上划线</td>
</tr>
<tr>
<td><code>line-through</code></td>
<td>中划线，删除线，<code>&lt;del&gt;</code>标签的默认值</td>
</tr>
<tr>
<td><code>underline</code></td>
<td>下划线，<code>&lt;a&gt;</code>标签的默认值</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="文本缩进-text-indent"><a href="#文本缩进-text-indent" class="headerlink" title="文本缩进 text-indent"></a>文本缩进 <code>text-indent</code></h3><ul>
<li><p>作用：设置段落首行是否进行缩进。</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>px</code>单位</td>
<td>表示首行缩进多少像素</td>
</tr>
<tr>
<td><code>em</code>单位</td>
<td>首行缩进几个中文字符的位置</td>
</tr>
<tr>
<td>百分比</td>
<td>表示缩进文字所在标签的父级标签的<code>width</code>属性值的百分比</td>
</tr>
</tbody></table>
<ul>
<li>实际工作中，最常使用 <code>em</code> 为单位的属性值。</li>
<li>属性值区分正负，正数表示向右缩进，负数表示向左缩进。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS常用样式（一）字体类样式</title>
    <url>/2021/08/de65dc4b4401/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="字体-font-family"><a href="#字体-font-family" class="headerlink" title="字体 font-family"></a>字体 <code>font-family</code></h3><ul>
<li><p>作用：定义元素内文字的字体。</p>
</li>
<li><p>属性名 <code>k</code> ：<code>font-family</code>，字体属于 <code>font</code> 综合属性的一个单一属性。</p>
</li>
<li><p>属性值 <code>v</code> ：字体名称，必须包裹在一对引号中，属性值可以有多个，值之间用逗号分隔。</p>
</li>
<li><p>常用字体</p>
<ul>
<li>常用的中文字体<ul>
<li>宋体 <code>SimSun</code></li>
<li>微软雅黑 <code>Microsoft Yahei</code> </li>
</ul>
</li>
<li>常用的英文字体<ul>
<li><code>Arial</code></li>
<li><code>consolas</code></li>
</ul>
</li>
<li>如果不设置字体属性，不同的浏览器有自己的默认字体。</li>
</ul>
</li>
<li><p>注意事项</p>
<ul>
<li><code>font-family</code> 可以设置多个字体名称，在实际加载时只会选择一种加载，选择的依据是按书写顺序进行，如果浏览器不支持第一个字体，则会尝试下一个，直到找到第一个支持的字体。</li>
<li>浏览器中加载的字体是用户机器中自带的，如果用户的电脑中没有设置的字体则加载失败，需要查找下一个，因此，必须在最后设置一个所有机器都具备的通用字体作为后路。</li>
<li>中文字体中一般带有英文可以加载的字体效果，为了避免对英文字的字体影响，建议将英文字体写在属性值最前面。</li>
</ul>
</li>
<li><p>实际应用</p>
<ul>
<li>首选字体需要根据设计图确定，最后需要设置备用字体。</li>
</ul>
</li>
</ul>
<h3 id="字号-font-size"><a href="#字号-font-size" class="headerlink" title="字号 font-size"></a>字号 <code>font-size</code></h3><ul>
<li>作用：设置文字的大小。</li>
<li>属性名 <code>k</code> ：<code>font-size</code>，字号属于 <code>font</code> 综合属性的一个单一属性。 </li>
<li>属性值 <code>v</code> ：可以使用相对长度单位，也可以使用绝对长度单位。推荐使用相对长度单位。</li>
<li>单位</li>
</ul>
<table>
<thead>
<tr>
<th>相对长度单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>px</code></td>
<td>像素值，最常使用的单位</td>
</tr>
<tr>
<td><code>em</code></td>
<td>倍数，继承自祖先元素设置的字号的倍数</td>
</tr>
<tr>
<td><code>%</code></td>
<td>百分比，继承自祖先元素设置的字号的百分比</td>
</tr>
<tr>
<td><strong>绝对长度单位</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td><code>in</code></td>
<td>英寸</td>
</tr>
<tr>
<td><code>cm</code></td>
<td>厘米</td>
</tr>
<tr>
<td><code>mm</code></td>
<td>毫米</td>
</tr>
<tr>
<td><code>pt</code></td>
<td>点</td>
</tr>
</tbody></table>
<ul>
<li><p>注意事向</p>
<ul>
<li>如果 <code>HTML</code> 中不设置字号，不同的浏览器有自己默认的加载字号，比如 <code>chrome</code>、<code>IE</code>，默认显示字号为 <code>16px</code>。</li>
<li>不同的浏览器也有自己最小加载显示字号，如果设置的字号低于最小字号，都以最小字号加载，0除外。<code>chrome</code> 浏览器最小加载显示字号为<code>8px</code>，<code>IE</code> 浏览器最小可以支持<code>1px</code>的字号。</li>
</ul>
</li>
<li><p>实际应用</p>
<ul>
<li>网页中最小设置字号必须是<code>12px</code>，如果低于<code>12px</code>会出现兼容问题。现在网页中普遍使用<code>14px+</code>。</li>
<li>尽量使用<code>12px</code>、<code>14px</code>、<code>16px</code>等偶数的数字字号，<code>ie6</code> 等老式浏览器支持奇数会有 <code>bug</code>。</li>
<li>实际工作中的字号，需要以设计图为准。</li>
</ul>
</li>
</ul>
<h3 id="实体化属性"><a href="#实体化属性" class="headerlink" title="实体化属性"></a>实体化属性</h3><ul>
<li><p>如果想在浏览器中具体看到一个盒子占有的实际位置，需要设置盒子可以实体化的三属性。</p>
</li>
<li><table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>width</code></td>
<td><code>px</code>单位的数值</td>
<td>定义元素占有的宽度</td>
</tr>
<tr>
<td><code>height</code></td>
<td><code>px</code>单位的数值</td>
<td>定义元素占有的高度</td>
</tr>
<tr>
<td><code>background-color</code></td>
<td>颜色名、颜色值</td>
<td>定义元素的背景颜色</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="粗细-font-weight"><a href="#粗细-font-weight" class="headerlink" title="粗细 font-weight"></a>粗细 <code>font-weight</code></h3><ul>
<li><p>作用：设置文字是否加粗显示。</p>
</li>
<li><p>属性名：<code>font-weight</code>，属于 <code>font</code> 属性的一个单一属性。</p>
</li>
<li><p>属性值有两种方式：单词类型、数字类型。</p>
</li>
<li><p>单词类型</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code></td>
<td>默认值，定义标准的字体</td>
</tr>
<tr>
<td><code>bold</code></td>
<td>定义粗体字符，<code>b</code>、<code>strong</code>标签的默认值</td>
</tr>
<tr>
<td><code>bolder</code></td>
<td>定义更粗的字体</td>
</tr>
<tr>
<td><code>lighter</code></td>
<td>定义更细的字体</td>
</tr>
</tbody></table>
</li>
<li><p>数字类型</p>
<ul>
<li>100-900 之间的整百数字。</li>
<li>数字越大，文字显示越粗。</li>
<li>其中 400 等价于 <code>normal</code>，700 等价于 <code>bold</code>。</li>
</ul>
</li>
</ul>
<h3 id="字体风格font-style"><a href="#字体风格font-style" class="headerlink" title="字体风格font-style"></a>字体风格<code>font-style</code></h3><ul>
<li><p>作用：设置文字是否斜体显示。</p>
</li>
<li><p>属性名：<code>font-style</code>，属于<code>font</code>属性的一个单一属性。</p>
</li>
<li><p>属性值：单词。</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code></td>
<td>设置正规的字体，大多数标签的默认值</td>
</tr>
<tr>
<td><code>italic</code></td>
<td>设置斜体的字体，主要针对英文，要求英文以字体中的斜体样式显示</td>
</tr>
<tr>
<td><code>oblique</code></td>
<td>设置倾斜的文字，只是将文字倾斜显示，与字体无关</td>
</tr>
</tbody></table>
</li>
<li><p>实际应用中，更多的斜体效果习惯使用italic属性值。</p>
</li>
</ul>
<h3 id="行高-line-height"><a href="#行高-line-height" class="headerlink" title="行高 line-height"></a>行高 <code>line-height</code></h3><ul>
<li><p>作用：设置的是一行文字实际占有的高度，文字字号在行高中是垂直居中的。</p>
</li>
<li><p>属性名：<code>line-height</code>，属于 <code>font</code> 属性的一个单一属性。</p>
</li>
<li><p>属性值</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>px</code>像素值</td>
<td>设置的行高的具体像素值</td>
</tr>
<tr>
<td>百分比数值</td>
<td>设置的本身字号像素值的百分比</td>
</tr>
</tbody></table>
</li>
<li><p>实际应用中，行高的数值通过设计图获取，量取数值时需要使用一些辅助软件工具。</p>
</li>
</ul>
<h3 id="字体综合-font"><a href="#字体综合-font" class="headerlink" title="字体综合 font"></a>字体综合 <code>font</code></h3><ul>
<li><p>字体、字号、行高、加粗、斜体都是<code>font</code>综合属性的单一属性。 </p>
</li>
<li><p><code>font</code>属性五个单一属性的值可以进行合写，属性值可以有2到多个，值之间用空格进行分隔。</p>
</li>
<li><p>写法</p>
<ul>
<li>font进行综合书写时，<strong>必须有字号和字体参与</strong>，而且必须字号在前，字体在后，不能颠倒顺序。</li>
<li>font属性经常对字体、字号、行高进行合写，书写顺序必须是字号、行高、字体，<strong>字号和行高之间必须用/进行分隔</strong>。</li>
<li>如果font属性需要设置加粗和斜体，两个属性值只能写在最前面，两个值之间可以互换位置。后面的<strong>字号、行高、字体不能更改位置</strong>。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>CSS基础语法</title>
    <url>/2021/07/04dd7123fa55/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h3><ul>
<li>从<code>HTML</code>被发明开始，样式就以各种形式存在，最初的<code>HTML</code>只包含很少的显示属性。</li>
<li>随着<code>HTML</code>的成长，为了满足页面设计者的要求，<code>HTML</code>添加了很多显示功能，例如文本格式化标签。</li>
<li>但是随着这些功能的增加，<code>HTML</code>变的越来越杂乱，而且<code>HTML</code>页面也越来越臃肿。</li>
<li>于是<code>CSS</code>便诞生了。</li>
</ul>
<h3 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h3><table>
<thead>
<tr>
<th>版本</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>CSS1</code></td>
<td>1995年12月，层叠样式表的第一份正式标准（<code>Cascading style Sheets Level 1</code>）完成，成为 <code>w3c</code> 的推荐标准。</td>
</tr>
<tr>
<td><code>CSS2</code></td>
<td>1997年初，<code>W3C</code> 组织负责 <code>CSS</code> 的工作组开始讨论第一版中没有涉及到的问题。其讨论结果组成了1998年5月出版的 <code>CSS</code> 规范第二版。</td>
</tr>
<tr>
<td><code>CSS3</code></td>
<td><code>CSS3</code> 是 <code>CSS</code> 层叠样式表技术的升级版本，于1999年开始制订，2001年5月23日 <code>W3C</code> 完成了 <code>CSS3</code> 的工作草案，主要包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块 。</td>
</tr>
</tbody></table>
<h3 id="CSS-概念"><a href="#CSS-概念" class="headerlink" title="CSS 概念"></a><code>CSS</code> 概念</h3><ul>
<li><code>css</code> 全称 <code>cascading style sheets</code>，层叠式样式表，是一种用来表现 <code>HTML</code> 的文件样式的计算机语言。</li>
<li>作用：静态地修饰网页，并且可以配合各种脚本语言动态地对网页各元素进行格式化。</li>
<li><code>CSS</code> 的出现，实现了网页的结构和样式分离，拯救了混乱的 <code>HTML</code>，更加拯救了我们 <code>web</code> 开发者。</li>
<li><code>CSS</code> 可以说是网页的美容师， 让我们的网页更加美观。</li>
</ul>
<h3 id="前端三层技术"><a href="#前端三层技术" class="headerlink" title="前端三层技术"></a>前端三层技术</h3><ul>
<li><code>html</code><ul>
<li>结构层</li>
<li>从语义的角度搭建网页结构</li>
</ul>
</li>
<li><code>css</code><ul>
<li>样式层</li>
<li>从美观的角度描述页面样式</li>
</ul>
</li>
<li><code>JavaScript</code><ul>
<li>行为层</li>
<li>从交互的角度描述页面行为</li>
</ul>
</li>
</ul>
<h3 id="CSS-的组成"><a href="#CSS-的组成" class="headerlink" title="CSS 的组成"></a><code>CSS</code> 的组成</h3><ul>
<li>层叠式：<code>css</code> 中贯穿始终的加载特性<ul>
<li>层叠性</li>
<li>继承性</li>
</ul>
</li>
<li>样式：定义如何显示 HTML 元素<ul>
<li>文字文本</li>
<li>背景</li>
<li>盒模型</li>
<li>浮动</li>
<li>定位</li>
<li>其他</li>
</ul>
</li>
</ul>
<h3 id="CSS-语法"><a href="#CSS-语法" class="headerlink" title="CSS 语法"></a><code>CSS</code> 语法</h3><ul>
<li><p><code>CSS</code> 规则</p>
<ul>
<li><code>CSS</code> 规则由两个主要的部分构成：选择器，以及一条或多条声明</li>
</ul>
</li>
<li><p>书写位置</p>
<ul>
<li><p><code>css</code> 的代码根据书写位置不同分为四种书写方式：内联式、内嵌式、外联式、导入式。</p>
</li>
<li><p>内联式</p>
<ul>
<li>内联式，也被习惯叫做行内式。</li>
<li>书写位置：在 <code>HTML</code> 标签之上的 <code>style</code> 属性中书写 <code>css</code> 样式。</li>
<li>所有的 <code>css</code> 样式属性总体组成标签的 <code>style</code> 属性的属性值。</li>
<li>缺点<ul>
<li>内联式必须写在标签上，没有完全脱离 <code>HTML</code> 标签。</li>
<li><code>css</code> 样式代码让标签结构繁重，不利于 <code>HTML</code> 结构的解读。 </li>
<li>个内联式的 <code>css</code> 代码，只能给一个标签使用，如果多个标签有相同的样式，同样的 <code>css</code> 代码需要书写多次，增加代码量。</li>
<li>因此，实际工作中不会使用内联式（行内式）编写 <code>css</code> 代码。 </li>
</ul>
</li>
</ul>
</li>
<li><p>内嵌式</p>
<ul>
<li>书写位置：在 <code>HTML</code> 文件中，<code>&lt;head&gt;</code> 标签内部有一个 <code>&lt;style&gt;</code> 标签。 <code>&lt;style&gt;</code> 标签书写在<code>&lt;title&gt;</code> 标签后面，所有 <code>css</code> 代码书写在 <code>&lt;style&gt;</code> 标签内部 。</li>
<li><code>&lt;style&gt;</code> 标签有一个标签属性叫做 <code>type</code>，属性值是 <code>”text/css”</code>。</li>
<li>优点<ul>
<li>实现了结构和样式的初步分离，<code>css</code> 只负责样式，<code>HTML</code> 负责结构。</li>
<li>多个标签可以利用一段代码设置相同的样式，节省代码量。</li>
</ul>
</li>
<li>缺点<ul>
<li>结构和样式并没有完全分离，代码依旧书写在 <code>HTML</code> 文件的<code>&lt;style&gt;</code>标签内部。</li>
<li><code>css</code> 样式只能给一个 <code>HTML</code> 文件使用，不能够被多个 <code>HTML</code> 文件同时利用。</li>
<li>在 <code>HTML</code> 中如果 <code>css</code> 代码太多，会造成文件头重脚轻。</li>
</ul>
</li>
</ul>
</li>
<li><p>外联式</p>
<ul>
<li><p>外联式 <code>CSS</code>，也可以叫做外链式 <code>CSS</code>、外部 <code>CSS</code>。</p>
</li>
<li><p>书写位置：在一个单独的扩展名为 <code>.css</code> 的文件中。</p>
</li>
<li><p>书写语法：内部代码与内嵌式样式表中 <code>&lt;style&gt;</code> 标签内部的代码一样的。需要通过选择器去选中标签，添加对应的样式。</p>
</li>
<li><p>注意：在 <code>.css</code> 文件中书写时，不需要再加 <code>&lt;style&gt;</code> 标签</p>
</li>
<li><p>引用</p>
<ul>
<li><p>外联式样式表必须引入到 <code>HTML</code> 文件中，才能正常进行加载。 </p>
</li>
<li><p>引入方式：在 HTML 中的 <code>&lt;head&gt;</code> 标签内部使用 <code>&lt;link&gt;</code> 标签进行引入。</p>
</li>
<li><p><code>&lt;link&gt;</code> 标签属性</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>rel</code></td>
<td><code>stylesheet</code></td>
<td>表示引入的外部文件与 <code>HTML</code> 之间的关系，样式表</td>
</tr>
<tr>
<td><code>href</code></td>
<td><code>css</code> 文件路径</td>
<td><code>hypertext reference</code>，超文本引用</td>
</tr>
<tr>
<td><code>type</code></td>
<td><code>text/css</code></td>
<td>表示加载时代码按照纯文本形式的 <code>css</code> 代码加载。<code>HTML5</code> 中可以省略 <code>type</code> 属性不写。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>实现了 <code>HTML</code> 和 <code>css</code> 完全分离。</li>
<li>多个 <code>HTML</code> 文件可以共用一个 <code>css</code> 文件，便于提取公共 <code>css</code>，减少代码量。 </li>
<li>可以实现一个 <code>css</code> 变化，多个 <code>HTML</code> 页面同时变化，减少工作量。</li>
<li>一个 <code>HTML</code> 文件可以引入多个 <code>css</code> 文件，可以实现同一个页面中 <code>css</code> 代码分层。</li>
</ul>
</li>
</ul>
</li>
<li><p>导入式</p>
<ul>
<li>书写位置：在内嵌式样式表 <code>&lt;style&gt;</code> 标签内部，或者在外联式样式表内部，导入其他的外部的 <code>.css</code> 文件。</li>
<li>导入方式：利用一条 <code>@import url(路径)</code> 语句进行引入。 </li>
<li>问题<ul>
<li>导入式样式表的作用与外联式样式表基本相同。</li>
<li>但是由于导入式在浏览器中加载时，会在 <code>HTML</code> 结构加载完毕后再进行编译，如果网速比较慢时，会导致网页出现没有 <code>css</code> 样式的效果，给用户的体验不好。</li>
<li>实际工作中，较少使用导入式，推荐使用外联式样式表。</li>
</ul>
</li>
</ul>
</li>
<li><p>实际应用</p>
<ul>
<li>小型案例：可以使用内嵌式 <code>CSS</code>。</li>
<li>实际工作、大型网站项目：推荐使用外联式 <code>CSS</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p>样式规则</p>
<ul>
<li>以内嵌式样式表为例<ul>
<li>所有的 <code>css</code> 代码都必须书写在 <code>&lt;head&gt;</code> 标签内部的一对 <code>&lt;style&gt;</code> 标签内。</li>
<li><code>css</code> 在给某个标签设置样式前，必须使用选择器先选中标签。</li>
<li><code>css</code> 样式的属性，属性名和属性值的键值对写法为 <code>k:v;</code> 。 </li>
<li>给每个选择器添加的样式属性都必须写在一对大括号 <code>&#123;&#125;</code> 之内。</li>
<li>给一个标签添加的所有需要的样式，都要在 <code>&#123;&#125;</code> 内部一一罗列出来 </li>
</ul>
</li>
<li>注意事项<ul>
<li>分号必要性：每条属性后面的分号必须写，如果不写，会导致后面所有的代码加载错误。</li>
<li><code>css</code> 中所有属性与属性之间对空格、换行、缩进不敏感。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>CSS</code> 注释语法</p>
<ul>
<li>一个清晰易读的 <code>CSS</code> 代码，离不开 <code>CSS</code> 注释的合理添加。</li>
<li>语法格式：<code>/*中间部分为注释内容*/</code></li>
<li><code>vs code</code>快捷键：<code>ctrl+/</code> 。</li>
</ul>
</li>
<li><p><code>CSS</code> 样式格式</p>
<ul>
<li>代码风格是实际开发中的书写方式，并非强制标准。</li>
<li>展开格式：开发过程使用，代码可读性强，便于调错。</li>
<li>紧凑格式：上传服务器时使用，减少不必要的空白字符，压缩文件大小，利于传输。</li>
<li>英文大小写<ul>
<li><code>CSS</code> 中的英文可以使用大写，也可以使用小写。</li>
<li>建议：<code>css</code> 中的选择器和样式属性名、属性值等都使用小写英文，特殊情况除外。</li>
</ul>
</li>
<li>空格规范<ul>
<li>选择器与大括号 <code>&#123;&#125;</code> 之间保留一个空格。</li>
<li>冒号后面，属性值前面，保留一个空格。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CSS-常用样式"><a href="#CSS-常用样式" class="headerlink" title="CSS 常用样式"></a><code>CSS</code> 常用样式</h3><ul>
<li><p>颜色 <code>color</code></p>
<ul>
<li><p>作用：给文字设置颜色。</p>
</li>
<li><p>属性名 <code>k</code> ：<code>color</code></p>
</li>
<li><p>属性值 <code>v</code> ：颜色名、颜色值。</p>
</li>
<li><p>颜色名</p>
<ul>
<li><p>颜色名就是使用颜色的英文单词进行表示。 </p>
</li>
<li><p>需要记忆一些最常用的颜色名：</p>
<table>
<thead>
<tr>
<th>颜色</th>
<th>色值</th>
<th>颜色</th>
<th>色值</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td><code>red</code></td>
<td>黑色</td>
<td><code>black</code></td>
</tr>
<tr>
<td>橙色</td>
<td><code>orange</code></td>
<td>白色</td>
<td><code>white</code></td>
</tr>
<tr>
<td>黄色</td>
<td><code>yellow</code></td>
<td>金色</td>
<td><code>gold</code></td>
</tr>
<tr>
<td>绿色</td>
<td><code>green</code></td>
<td>粉色</td>
<td><code>pink</code></td>
</tr>
<tr>
<td>青色</td>
<td><code>cyan</code></td>
<td>浅黄色</td>
<td><code>lightyellow</code></td>
</tr>
<tr>
<td>蓝色</td>
<td><code>blue</code></td>
<td>黄绿色</td>
<td><code>yellowgreen</code></td>
</tr>
<tr>
<td>紫色</td>
<td><code>purple</code></td>
<td>天蓝色</td>
<td><code>skyblue</code></td>
</tr>
</tbody></table>
<p>更多的颜色名可以通过查询手册得到</p>
</li>
</ul>
</li>
<li><p>颜色值</p>
<ul>
<li><p>颜色值指使用具体颜色的数值表示。</p>
</li>
<li><p>包括： <code>rgb</code> 模式和十六进制模式写法。</p>
<ul>
<li><p><code>rgb</code> 模式</p>
<ul>
<li><p><code>rgb</code> 模式：是根据红绿蓝三原色进行混合而成的颜色模式。</p>
</li>
<li><p>每个原色的取值范围是0-255，一共256个数值。三个原色共能混合成1677多万种颜色。</p>
</li>
<li><p>书写方法：<code>rgb(红,绿,蓝)</code> </p>
</li>
<li><p>常用颜色的 <code>rgb</code> 色值： </p>
<table>
<thead>
<tr>
<th>颜色</th>
<th>色值</th>
<th>颜色</th>
<th>色值</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td><code>rgb(255,0,0)</code></td>
<td>黑色</td>
<td><code>rgb(0,0,0)</code></td>
</tr>
<tr>
<td>绿色</td>
<td><code>rgb(0,255,0)</code></td>
<td>白色</td>
<td><code>rgb(255,255,255)</code></td>
</tr>
<tr>
<td>蓝色</td>
<td><code>rgb(0,0,255)</code></td>
<td>灰色</td>
<td><code>rgb(128,128,128)</code></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>十六进制模式</p>
<ul>
<li><p>十六进制模式：是 <code>rgb</code> 模式的一种简化写法，使用十六进制的数字字符去替换十进制的 <code>0-255</code> 的数字。</p>
</li>
<li><p>十六进制：逢十六进一，每个数位上只能出现 <code>0-9</code>，<code>a-f</code> 之间的字符。 </p>
</li>
<li><p>书写为颜色值时，红、绿、蓝每个色值都要使用两位数的十六进制进行替换。</p>
<ul>
<li><code>0→00</code> </li>
<li><code>255→ff</code> </li>
</ul>
</li>
<li><p>书写方式：使用 <code>#</code> 开头，后面连续书写红、绿、蓝三个颜色的十六进制的两位数值。</p>
</li>
<li><p>常用颜色的十六进制色值：</p>
<table>
<thead>
<tr>
<th>颜色</th>
<th>色值</th>
<th>颜色</th>
<th>色值</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td><code>#ff0000</code></td>
<td><code>黑色</code></td>
<td><code>#000000</code></td>
</tr>
<tr>
<td>绿色</td>
<td><code>#00ff00</code></td>
<td>白色</td>
<td><code>#ffffff</code></td>
</tr>
<tr>
<td>蓝色</td>
<td><code>#0000ff</code></td>
<td>灰色</td>
<td><code>#808080</code></td>
</tr>
</tbody></table>
</li>
<li><p>十六进制颜色值简写模式：如果红、绿、蓝三个原色的色值每一个都是由重叠的数字组成，可以将重叠的数字简化成一个进行书写。</p>
<ul>
<li>红色<code>#f00</code> </li>
<li>绿色<code>#0f0</code> </li>
<li>蓝色<code>#00f</code> </li>
<li>类似 <code>#808080</code> 是不能进行简化的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字体 <code>font-family</code></p>
<ul>
<li>作用：定义元素内文字的字体。</li>
<li>属性名 <code>k</code> ：<code>font-family</code>，字体属于 <code>font</code> 综合属性的一个单一属性。</li>
<li>属性值 <code>v</code> ：字体名称，必须包裹在一对引号中，属性值可以有多个，值之间用逗号分隔。</li>
<li>常用字体<ul>
<li>常用的中文字体<ul>
<li>宋体 <code>SimSun</code></li>
<li>微软雅黑 <code>Microsoft Yahei</code> </li>
</ul>
</li>
<li>常用的英文字体<ul>
<li><code>Arial</code></li>
<li><code>consolas</code></li>
</ul>
</li>
<li>如果不设置字体属性，不同的浏览器有自己的默认字体。</li>
</ul>
</li>
<li>注意事项<ul>
<li><code>font-family</code> 可以设置多个字体名称，在实际加载时只会选择一种加载，选择的依据是按书写顺序进行，如果浏览器不支持第一个字体，则会尝试下一个，直到找到第一个支持的字体。</li>
<li>浏览器中加载的字体是用户机器中自带的，如果用户的电脑中没有设置的字体则加载失败，需要查找下一个，因此，必须在最后设置一个所有机器都具备的通用字体作为后路。</li>
<li>中文字体中一般带有英文可以加载的字体效果，为了避免对英文字的字体影响，建议将英文字体写在属性值最前面。</li>
</ul>
</li>
<li>实际应用<ul>
<li>首选字体需要根据设计图确定，最后需要设置备用字体。</li>
</ul>
</li>
</ul>
</li>
<li><p>字号 <code>font-size</code></p>
<ul>
<li><p>作用：设置文字的大小。</p>
</li>
<li><p>属性名 <code>k</code> ：<code>font-size</code>，字号属于 <code>font</code> 综合属性的一个单一属性。 </p>
</li>
<li><p>属性值 <code>v</code> ：可以使用相对长度单位，也可以使用绝对长度单位。推荐使用相对长度单位。</p>
</li>
<li><p>单位</p>
<table>
<thead>
<tr>
<th>相对长度单位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>px</code></td>
<td>像素值，最常使用的单位</td>
</tr>
<tr>
<td><code>em</code></td>
<td>倍数，继承自祖先元素设置的字号的倍数</td>
</tr>
<tr>
<td><code>%</code></td>
<td>百分比，继承自祖先元素设置的字号的百分比</td>
</tr>
<tr>
<td><strong>绝对长度单位</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td><code>in</code></td>
<td>英寸</td>
</tr>
<tr>
<td><code>cm</code></td>
<td>厘米</td>
</tr>
<tr>
<td><code>mm</code></td>
<td>毫米</td>
</tr>
<tr>
<td><code>pt</code></td>
<td>点</td>
</tr>
</tbody></table>
</li>
<li><p>注意事向</p>
<ul>
<li>如果 <code>HTML</code> 中不设置字号，不同的浏览器有自己默认的加载字号，比如 <code>chrome</code>、<code>IE</code>，默认显示字号为 <code>16px</code>。</li>
<li>不同的浏览器也有自己最小加载显示字号，如果设置的字号低于最小字号，都以最小字号加载，0除外。<code>chrome</code> 浏览器最小加载显示字号为<code>8px</code>，<code>IE</code> 浏览器最小可以支持<code>1px</code>的字号。</li>
</ul>
</li>
<li><p>实际应用</p>
<ul>
<li>网页中最小设置字号必须是<code>12px</code>，如果低于<code>12px</code>会出现兼容问题。现在网页中普遍使用<code>14px+</code>。</li>
<li>尽量使用<code>12px</code>、<code>14px</code>、<code>16px</code>等偶数的数字字号，<code>ie6</code> 等老式浏览器支持奇数会有 <code>bug</code>。</li>
<li>实际工作中的字号，需要以设计图为准。</li>
</ul>
</li>
</ul>
</li>
<li><p>实体化属性</p>
<ul>
<li><p>如果想在浏览器中具体看到一个盒子占有的实际位置，需要设置盒子可以实体化的三属性。</p>
</li>
<li><table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>width</code></td>
<td><code>px</code>单位的数值</td>
<td>定义元素占有的宽度</td>
</tr>
<tr>
<td><code>height</code></td>
<td><code>px</code>单位的数值</td>
<td>定义元素占有的高度</td>
</tr>
<tr>
<td><code>background-color</code></td>
<td>颜色名、颜色值</td>
<td>定义元素的背景颜色</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="CSS-选择"><a href="#CSS-选择" class="headerlink" title="CSS 选择"></a><code>CSS</code> 选择</h3><ul>
<li>在内嵌式和外部<code>css</code>中，要想将 <code>CSS</code> 样式应用于特定的 <code>HTML</code> 元素，首先需要找到该目标元素，这时需要用到 <code>CSS</code> 中的选择器。 </li>
<li>选择器<ul>
<li>选择器：选择要添加样式的 <code>HTML</code> 标签的一种方法、模式。 </li>
<li>首先学习 <code>css2.1</code> 版本的七种选择器<ul>
<li>基础选择器：标签选择器、<code>id</code> 选择器、类选择器、通配符选择器。</li>
<li>高级选择器：后代选择器、交集选择器、并集选择器。</li>
</ul>
</li>
</ul>
</li>
<li>标签选择器<ul>
<li>通过标签名去选择标签元素。</li>
<li>书写方式：标签名。 </li>
<li>选择范围：选中的是<code>HTML</code>文件中所有的同名标签。</li>
<li>注意：标签选择器可以选择所有的同名标签，会忽视 <code>HTML</code> 元素的嵌套关系，不管嵌套多深，都能被选中。</li>
<li>特点<ul>
<li>优点：可以选中所有的同名标签，设置所有同名标签的公共样式。</li>
<li>缺点：只能实现全选，不能对局部的标签添加特殊样式。 </li>
</ul>
</li>
</ul>
</li>
<li>基础选择器<ul>
<li><code>id</code> 选择器<ul>
<li>通过标签上的 <code>id</code> 属性去选择标签。</li>
<li>书写方式：<code>#id</code> 属性值 </li>
<li>选择范围：只能选中一个标签。</li>
<li><code>id</code> 命名规则：必须以字母开头，后面可以有字母、数字、下划线、横线，严格区分大小写。每个 <code>id</code> 属性值必须是唯一的，不能与其他的 <code>id</code> 同名。</li>
<li>注意：如果希望多个标签设置相同的样式，使用<code>id</code>选择器的话，必须给这多个标签取不同的 <code>id</code> 名，分别选中设置。</li>
<li>特点<ul>
<li>缺点：<code>id</code> 选择器只能实现单选，不能帮我们完成多选的功能。</li>
</ul>
</li>
</ul>
</li>
<li>类选择器<ul>
<li>通过标签的 <code>class</code> 属性去选择标签。</li>
<li>书写方式：<code>.class</code>属性值。</li>
<li>选择范围：是页面中所有 <code>class</code> 属性值相同的标签。 </li>
<li><code>class</code> 命名规则：必须以字母开头，后面可以有字母、数字、下划线、横线，严格区分大小写。<code>class</code> 属性值可以与其他的<code>class</code>相同。</li>
<li>特点<ul>
<li>多个不同的标签，不区分标签类型，只要 <code>class</code> 属性值相同，都可以被同一个类选择器选中。</li>
<li>一个标签的 <code>class</code> 属性可以有多个属性值，值之间用空格分隔，每个属性值组成的选择器，都可以选中这一个标签，每个选择器后面的样式都会添加给同一个标签。 </li>
</ul>
</li>
<li>特殊应用<ul>
<li>原子类：在<code>css</code>中提前设置一些类名，每个类选择器后面只添加一条<code>css</code>样式属性，这些属性会在页面中常被使用，后期可以不需要多次书写属性，只要将对应的类名添加给需要的标签即可。</li>
</ul>
</li>
<li>优点<ul>
<li>通过一个类选择器进行多选，选中多个标签，添加公共样式。</li>
<li>个标签可以被多个类选择器选中，可以将所有样式进行分离，分别提取公共样式和单独样式，节省代码量。</li>
</ul>
</li>
<li>实际工作中，通常我们有一个使用规律：类上样式(<code>CSS</code>)，<code>id</code> 上行为(<code>JavaScript</code>)。</li>
</ul>
</li>
<li>通配符选择器<ul>
<li>通过一个特殊符号选择页面内所有的标签。</li>
<li>书写方式：<code>*</code> </li>
<li>选择范围：包含 <code>&lt;html&gt;</code>标签在内的所有标签。</li>
<li>特点和应用<ul>
<li>优点：可以实现全选，简化书写。</li>
<li>缺点：通配符选择效率低，设置的部分公共样式不是所有标签都需要添加，如果使用通配符选择，会让不需要的标签也加载一次样式，导致浏览器多做无用的工作。</li>
<li>注意：实际上线的网站不允许使用 <code>*</code> 去清除默认内外边距。</li>
<li>不过普通的案例，代码量较少时，为了节省书写，可以使用通配符。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>高级选择器<ul>
<li>由于基础选择器不能实现所有选择情况，后期在基础选择器的基础上衍生出了几种高级选择器。高级选择器的组成部分是基础选择器。</li>
<li>后代选择器<ul>
<li>通过标签之间存的嵌套关系（族谱关系）去选择元素，基本组成部分就是基础选择器。</li>
<li>后代选择器也叫包含选择器。</li>
<li>书写方式：空格表示后代，基础选择器中间使用空格分隔，空格前面的选择器选中的标签必须是后面选择器选中标签的祖先级。 </li>
<li>选择范围：通过后代选择器中前面的一系列基础选择器缩小选择范围，最终由最后一个选择器确定选中的标签。</li>
<li>注意：后代选择器必须满足所有的后代关系才能够被选中，后代关系不一定只能是父子关系。</li>
<li>优点：减少 <code>class</code> 属性的定义使用，选择效率更高。</li>
</ul>
</li>
<li>交集选择器<ul>
<li>通过一个标签之上满足所有的基础选择器的需求去选择标签。</li>
<li>书写方式：基础选择器进行连续书写，如果有标签选择器参与交集，必须书写在开头。</li>
<li>选择范围：选择的是满足所有基础选择器需求的标签，如果一个条件不满足都不能被选中。</li>
<li>比较常见的是标签与类的交集。</li>
<li>更多写法<ul>
<li>交集选择器可以进行类名的连续交集，需要满足更多的条件才能选中标签。</li>
<li><code>IE6</code> 不支持类名连续交集写法。</li>
<li>交集选择器可以作为其他高级选择器的组成部分。</li>
</ul>
</li>
</ul>
</li>
<li>并集选择器<ul>
<li>不同选择器选中的元素都要设置相同的样式，多次书写相同的样式属性对代码造成浪费，可以将前面六种选择器可以进行并集书写，相当于一种简化写法。</li>
<li>书写方式：将多个选择器中间用逗号进行分隔，最后一个后面不能加逗号。</li>
<li>选择范围：是所有的单独选择器选中的标签的并集集合。</li>
<li>用途<ul>
<li>如果多个标签具有公共样式，但是不能用一个选择器选中，可以使用并集写法。</li>
<li>可以使用标签选择器的并集写法，进行默认样式的清除，替换通配符的功能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CSS-层叠式"><a href="#CSS-层叠式" class="headerlink" title="CSS 层叠式"></a><code>CSS</code> 层叠式</h3><ul>
<li><code>CSS</code> 的概念中，除了前面提到的样式外，还有一个重要的概念就是层叠式，层叠式是贯穿整个<code>css</code>的一个性质，包含继承性和层叠性。 </li>
<li>继承性<ul>
<li>如果一个标签没有设置过一些样式，它的某个祖先级曾经设置过，在浏览器中该标签也加载了这些样式，这些样式都是从祖先级继承而来，这种现象就是继承性。</li>
<li>能够被继承的样式是所有的<strong>文字相关样式属性</strong>，其他的属性都不能被继承。</li>
<li>继承性是一个很好的性质，可以将页面中出现最多的文字样式设置给一个较大的祖先级标签比如 <code>&lt;body&gt;</code>，后期所有的后代标签都可以从 <code>&lt;body&gt;</code> 进行继承。</li>
</ul>
</li>
<li>层叠性<ul>
<li>思考问题：同一个标签可以被多个选择器选中，如果选择器后面设置了相同的样式属性，标签最终该加载哪个？或者，在继承性中，如果多个祖先都设置了相同的文字样式，后代中该继承哪个祖先级的？</li>
<li>解决方法：就是使用层叠性去解决冲突。多个选择器在进行对比的过程中，最终只有一个属性会成功加载，它会层叠、覆盖掉其他的属性。</li>
<li>判断最终胜出的属性是谁，需要依赖判断<strong>优先级</strong>。</li>
<li>判断方法<ul>
<li>选中目标标签<ul>
<li><strong>第一步：比较多个选择器的权重，权重高的层叠权重低的。</strong></li>
<li>基础选择器的权重：根据选择范围，范围越大权重越小，<code>*</code> &lt; 标签选择器 &lt; 类选择器 &lt; <code>id</code> 选择器。</li>
<li>高级选择器权重比较方法：依次比较组成高级选择器的 <code>id</code> 的个数，类的个数，标签的个数，如果前面能够比较出大小就不再比较后面，如果前面相等就往后比较，直到比较出大小。</li>
<li>比较顺序：( <code>id</code> 个数, 类的个数, 标签的个数 ) </li>
<li><strong>第二步：如果选择器权重都相同，需要比较 <code>CSS</code> 中代码的书写顺序，后写的层叠先写的。</strong></li>
</ul>
</li>
<li>选中目标标签的组先级<ul>
<li>如果选择器选中的是祖先元素，文字的样式可以被继承。</li>
<li>第一步：比较就近原则，比较选择器选中的祖先级在 <code>HTML</code> 结构中距离目标标签的远近，近的层叠远的。</li>
<li>第二步：如果选中的祖先级距离目标一样近（同一个祖先级），比较选择器权重，权重大的层叠小的。</li>
<li>第三步：如果距离一样近，权重也相同，最后比较 <code>CSS</code> 中的书写顺序，后面的层叠前面的。</li>
</ul>
</li>
<li><code>!important</code> 关键字<ul>
<li>如果在比较选择器权重的过程中，遇见一个 <code>!important</code> 关键字，可以将某条 <code>CSS</code> 样式属性的权重提升到最大。 </li>
<li>书写位置：在某个<code>css</code>属性的属性值后面空格加 <code>!important</code> 。</li>
<li>注意：<ul>
<li>就近原则中，不需要比较选择器权重，所有 <code>important</code> 会失效。</li>
<li> <code>important</code> 不能提升选择器的权重，只能提升某条属性的权重到最大。</li>
</ul>
</li>
</ul>
</li>
<li>行内式权重<ul>
<li> 行内式样式与内嵌式或外链式样式比较权重时，行内式的权重最高。</li>
<li>但是，与 <code>!important</code> 关键字相比权重要低。</li>
</ul>
</li>
<li>总结<img src="https://pic.imgdb.cn/item/616581512ab3f51d91348fd8.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Css</category>
      </categories>
  </entry>
  <entry>
    <title>Html基础（三）HTML常用标签</title>
    <url>/2021/07/5c8258b43431/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li>在很多代码技术中都可以添加注释内容，我们也可以向HTML源代码添加注释</li>
<li>HTML注释语法：<code>&lt;!-- 书写注释内容 --&gt;</code></li>
<li>特点：注释只在源代码中可见，在浏览器窗口是不显示的</li>
<li>用途<ul>
<li>在源代码中添加描述性的提示信息，便于我们阅读代码。</li>
<li>队医HTML纠错也大有帮助，可以通过注释某一行HTML代码，一边检索错误的位置。</li>
<li>暂时注释掉一部分不用的代码，便于后期恢复代码。</li>
</ul>
</li>
</ul>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul>
<li>标题（<code>Heading</code>），是通过<code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>六个标签分别来对应六个级别的标题进行定义的。</li>
<li><code>&lt;h1&gt;</code>定义最大的标题，<code>&lt;h6&gt;</code>定义最小的标题</li>
<li><code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>标签都是双标签，且是容器级标签</li>
<li>作用：给标签内部的元素内容添加对应级别的标题的语义，不负责文字的粗体、字号等样式，样式是由<code>CSS</code>设定的</li>
<li>级别：标题标签之间是不能互相嵌套的，下一级标题与上一级标题之间通过同级关系书写，下一级标题解释说明的是前面距离最近的上一级标题</li>
<li>权重<ul>
<li>标题标签对于呈现文档结构非常重要，使用时要根据标签的重要成都进行选择，其中<code>&lt;h1&gt;</code>标签最重要，<code>&lt;h2&gt;</code>标签次重要，以此类推。</li>
<li><code>&lt;h1&gt;</code>在整个<code>HTML</code>中的权重非常高，内部应该放置<code>HTML</code>中最重要的内容，比如<code>logo</code></li>
<li><code>&lt;h1&gt;</code>由于非常重要，内部的文字对于提高搜索引擎排名也非常重要，为了防止作弊，如果一个页面出现多个<code>&lt;h1&gt;</code>，反而降低权重。约定俗成的，一个页面中只会出现一个<code>&lt;h1&gt;</code>。</li>
</ul>
</li>
</ul>
<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><ul>
<li>段落（<code>paragraph</code>）是通过<code>&lt;p&gt;</code>标签定义的。</li>
<li><code>&lt;p&gt;</code>标签是双标签，且为文本级标签。内部只能放置文本、图片、表单元素，或者废弃的<code>&lt;font&gt;</code>标签等。</li>
<li>每一对儿<code>&lt;p&gt;</code>标签内部的元素为一个完整的段落，如果有多个段落，需要分别使用不同的<code>&lt;p&gt;</code>标签进行定义</li>
</ul>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li><code>&lt;br/&gt;</code>（<code>breaking</code>）标签是<code>HTML</code>中一个简单的换行符。</li>
<li><code>&lt;br/&gt;</code>标签是一个单标签。</li>
<li>在需要换行的位置可以使用<code>&lt;br/&gt;</code>标签书写，但是<code>&lt;br/&gt;</code>与<code>&lt;p&gt;</code>不同，<code>&lt;br/&gt;</code>没有建立新的段落的语义，只是简单的进行强制转换。</li>
</ul>
<h3 id="文本格式化"><a href="#文本格式化" class="headerlink" title="文本格式化"></a>文本格式化</h3><ul>
<li><code>HTML</code>中有部分标签是用来对文字进行格式化显示设置的，比如粗体和斜体等。</li>
<li>但是在<code>HTML4.0</code>版本规范后，结构和样式进行了分离，<code>HTML</code>只负责搭建结构，<code>CSS</code>负责格式化样式，所以大部分文本格式化标签被废弃，但是在<code>HTML4.01</code>和<code>XHTML1.0</code> <code>transitional</code>版本中依旧可以使用。</li>
<li>文本格式化的标签均为双标签，且为文本级标签，内部只能书写文字。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>b</code></td>
<td>定义粗体文本，<code>bold</code></td>
</tr>
<tr>
<td align="left"><code>big</code></td>
<td>定义大号字</td>
</tr>
<tr>
<td align="left"><code>em</code></td>
<td>定义着重文字，<code>emphasis</code>，自带斜体效果</td>
</tr>
<tr>
<td align="left"><code>i</code></td>
<td>定义斜体字，<code>italic</code></td>
</tr>
<tr>
<td align="left"><code>small</code></td>
<td>定义小号字</td>
</tr>
<tr>
<td align="left"><code>strong</code></td>
<td>定义加重语气，自带加粗效果</td>
</tr>
<tr>
<td align="left"><code>sub</code></td>
<td>定义下标字，<code>subscript</code></td>
</tr>
<tr>
<td align="left"><code>sup</code></td>
<td>定义上标字，<code>superscript</code></td>
</tr>
<tr>
<td align="left"><code>ins</code></td>
<td>定义插入字，自带下划线效果，<code>insert</code></td>
</tr>
<tr>
<td align="left"><code>del</code></td>
<td>定义删除字，<code>delete</code></td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td>不赞成使用，使用<code>del</code>代替，<code>strike</code>的简化</td>
</tr>
<tr>
<td align="left"><code>strike</code></td>
<td>不赞成使用，使用<code>del</code>代替</td>
</tr>
<tr>
<td align="left"><code>u</code></td>
<td>定义下划字，不赞成使用，使用<code>css</code>中样式代替，<code>underline</code></td>
</tr>
</tbody></table>
<h3 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h3><ul>
<li>图像（<code>image</code>）由<code>&lt;img&gt;</code>标签进行定义。</li>
<li><code>&lt;img&gt;</code>标签是单标签，本身相当于一个特殊的文本。</li>
<li><code>&lt;img&gt;</code>标签的作用是在指定的位置插入一张图片。</li>
<li>在<code>HTML</code>文件，常用的插入图片类型有：<code>jpg</code>、<code>png</code>、<code>gif</code>。</li>
<li>标签属性：由于<code>&lt;img&gt;</code>为单标签，所以它只能通过属性进行相关的图像设置。</li>
</ul>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>src</code></td>
<td>表示图片的路径</td>
</tr>
<tr>
<td><code>width</code></td>
<td>表示图片的宽度</td>
</tr>
<tr>
<td><code>height</code></td>
<td>表示图片的高度</td>
</tr>
<tr>
<td><code>border</code></td>
<td>边框属性；它的值可以设置边框的厚度</td>
</tr>
<tr>
<td><code>title</code></td>
<td>设置提示文本</td>
</tr>
<tr>
<td><code>alt</code></td>
<td>设置图像没有找到时候的替代文本</td>
</tr>
</tbody></table>
<ul>
<li><p><code>src</code>属性和路径</p>
<ul>
<li>如果需要插入一张图片到<code>HTML</code>中，<code>&lt;img&gt;</code>标签必须设置<code>src</code>属性。</li>
<li><code>src</code>：全称<code>source</code>资源，属性值是图片查找的路径。</li>
<li>路径：指的是寻找文件时所历经的线路，在<code>HTML</code>中有特殊的书写语法。</li>
<li>路径分为相对路径和绝对路径，不同的方式出发点和参考位置不同。</li>
</ul>
</li>
<li><p>相对路径</p>
<ul>
<li>相对路径查找文件时，需要从<code>HTML</code>文件本身出发，根据相对的位置进行查找，包括三种方向。<ul>
<li>同级查找：指目标文件与<code>HTML</code>文件位于同一级，直接书写文件名+后缀格式。</li>
<li>子级查找：指目标文件在与<code>HTML</code>文件同一级的文件夹的内部，需要先查找文件夹名称，然后通过关闭符号<code>/</code>进入文件夹查找里面的文件；如果有多层文件夹，需要<code>/</code>进入多层。</li>
<li>上级查找：指目标文件在<code>HTML</code>文件所在文件夹的更上一级，需要跳出当前文件夹到上一层，路径写法利用<code>../</code>表示跳出一级，如果跳出多级书写多次<code>../</code>，直到找到文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>绝对路径</p>
<ul>
<li>绝对路径查找文件时，不需要从<code>HTML</code>文件出发，而是直接从电脑的盼复触发进行查找，或者使用网址形式查找。</li>
<li>盘符出发：例如从<code>c</code>盘或者<code>d</code>盘触发查找图片，书写时以<code>c:/</code>开头，后续类似子级查找写法直至找到目标文件。</li>
<li>网址形式：要查找的文件是来自网络资源，路径写法以<code>http://</code>开头。</li>
<li>从盘符出发的绝对路径的缺点<ul>
<li>盘符出发的路径不可移植，不可移动。</li>
<li>盘符出发的路径容易出现中文字符，中文的路径容易出现错误。</li>
</ul>
</li>
<li>路径实际应用<ul>
<li>建议多使用相对路径，可以适当使用网址形式的绝对路径。</li>
<li>使用相对路径必须将图片或文件与<code>HTML</code>同时上传，而且需要保持相对位置不变。</li>
</ul>
</li>
</ul>
</li>
<li><p>宽度和高度</p>
<ul>
<li><code>width</code>：图片的宽度</li>
<li><code>height</code>：图片的高度</li>
<li>属性值：以<code>px</code>为单位的数值，或者省略<code>px</code>不写。</li>
<li>如果不设置两个属性，会以图片的原始尺寸加载。</li>
<li>如果设置属性<ul>
<li>只设置了其中一个，另一个会等比例变换</li>
<li>如果两个都设置，按照设置值加载</li>
</ul>
</li>
</ul>
</li>
<li><p>边框</p>
<ul>
<li><code>border</code>：设置图片的边框。</li>
<li>属性值：数值、数值是几表示边框为几像素。</li>
<li>注意：<code>border</code>属性可以使用<code>css</code>进行设置，<code>css</code>中的边框有更多的设置效果。</li>
</ul>
</li>
<li><p>提示文本</p>
<ul>
<li><code>title</code>：设置的是鼠标悬停时的提示文本。</li>
<li>属性值：自定义的提示文字内容。</li>
</ul>
</li>
<li><p>替换文本</p>
<ul>
<li><code>alt</code>：设置的时图片查找错误时，出现的替换文本。</li>
<li>如果能正常找到图片，替换文本是不显示的。</li>
<li>属性值：自定义的替换内容。</li>
</ul>
</li>
<li><p>总结：<code>&lt;img&gt;</code>标签最为重要的属性为<code>src</code>，尽量使用<code>alt</code>属性对图片进行说明，添加相对关键词可以有利于<code>SEO</code>搜索引擎优化。其他属性可以根据需求进行设置。</p>
</li>
</ul>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><ul>
<li>音频使用<code>&lt;audio&gt;</code>标签进行定义。</li>
<li><code>&lt;audio&gt;</code>是双标签。</li>
<li>同图片一样，需要使用<code>src</code>属性设置音频查找的路径。</li>
<li>音频文件支持的格式包括：<code>.mp3</code>、<code>.ogg</code>、<code>.wav</code>。</li>
<li>音频控制条属性<ul>
<li>音频加载后不会自动显示播放器的控制条，需要使用<code>controls</code>属性进行设置，属性值也是<code>controls</code>。</li>
</ul>
</li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li>视频的设置方法与音频非常类似。</li>
<li>视频使用<code>&lt;video&gt;</code>标签进行定义。</li>
<li><code>&lt;video&gt;</code>是双标签。</li>
<li>使用<code>src</code>属性设置视频查找的路径。</li>
<li>视频我呢见支持的格斯包括：<code>.mp4</code>、<code>.ogg</code>、<code>.webm</code>。</li>
<li>视频控制条属性<ul>
<li>视频也需要使用<code>controls</code>属性设置控制条，属性值也是<code>controls</code>。</li>
</ul>
</li>
</ul>
<h3 id="超级链接"><a href="#超级链接" class="headerlink" title="超级链接"></a>超级链接</h3><ul>
<li><code>HTML</code>使用超级链接与网络上的另一个文档相连。超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。</li>
<li>在<code>HTML</code>中使用<code>&lt;a&gt;</code>标签可以创建链接。</li>
<li><code>a</code>全称<code>anchor</code>，锚的意思。</li>
<li><code>&lt;a&gt;</code>为双标签。</li>
<li>作用：在指定的位置添加超级链接，提供用户进行点击和跳转。</li>
<li><code>&lt;a&gt;</code>标签可以实现两种跳转：跨页面跳转、页面内跳转。实现跳转的方式需要用到一些标签属性。</li>
<li><code>href</code>属性<ul>
<li><code>href</code>全称<code>hypertext reference</code>，超文本引用，用于规定链接的目标地址。</li>
<li>属性值：链接目标的路径地址。可以使用相对路径或网址形式的绝对路径。</li>
<li><code>href</code>属性非常重要，<code>&lt;a&gt;</code>标签想要实现点击跳转，必须设置该属性，拥有这个属性<code>&lt;a&gt;</code>标签在鼠标移上去时才会显示一个小手指针状态。</li>
</ul>
</li>
<li><code>target</code>属性<ul>
<li>使用<code>target</code>属性，可以定义被链接的文档在何处跳转显示。</li>
<li>属性值有两种：</li>
<li><code>_self</code>：默认值，表示跳转的页面在当前窗口打开，不会打开新的窗口。</li>
<li><code>_blank</code>：空白的，表示跳转的页面在新窗口打开。</li>
</ul>
</li>
<li><code>title</code>属性<ul>
<li><code>title</code>设置的时鼠标悬停时的提示文本，与<code>&lt;img&gt;</code>标签类似</li>
<li>属性值：自定义的文字内容。</li>
<li>该属性用于给用户进行提示，该链接的功能是什么，提高用户的体验。</li>
</ul>
</li>
<li>锚点跳转<ul>
<li>超级链接的跳转效果不止包括跨页面的跳转，还包括锚点跳转的方式。</li>
<li>页面内锚点跳转<ul>
<li>这种跳转方式实现的是从某个位置跳转到同页面的另一个位置。</li>
<li>制作方法分为两个步骤，分别是设置锚点、添加链接。</li>
<li>设置锚点，也就是设置跳转目标位置，有两种设置方式。<ul>
<li>在目标位置找到任意一个标签，给它添加<code>id</code>属性，<code>id</code>的属性值必须是唯一的。<code>id</code>的属性值自定义规则：必须以字母开头，候面可以有字母、数字、下划线和横线，区分大小写。</li>
<li>在目标位置添加一个空的<code>&lt;a&gt;</code>标签，只设置一个<code>name</code>属性，<code>name</code>属性值设置方式与<code>id</code>相同，也必须是唯一的。</li>
</ul>
</li>
<li>添加链接<ul>
<li>链接到锚点，在需要点击的位置设置<code>&lt;a&gt;</code>标签，给<code>a</code>的<code>href</code>属性设置属性值为<code>#id</code>属性值或者<code>#</code>加<code>a</code>的<code>name</code>属性值</li>
</ul>
</li>
</ul>
</li>
<li>跨页面锚点跳转<ul>
<li>这种跳转方法综合了跨页面跳转和锚点跳转。</li>
<li>制作方法也分为两个步骤，分别是设置锚点、添加链接。</li>
<li>第一步：设置锚点，方式与页面内锚点跳转一直，在目标网页的指定位置设置使用<code>id</code>或<code>name</code>属性。</li>
<li>第二步：链接到锚点，添加超级链接时<code>href</code>属性需要更改，属性值写在页面的路径<code>#id</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li>列表用于制作<code>HTML</code>中的一系列项目。</li>
<li>通常我们会将内容相关、结构相似、样式相近的内容使用列表结构进行搭建。</li>
<li>根据项目的内容不同，可以有三种语义的列表结构：无序列表、有序列表、定义列表。</li>
<li>无序列表<ul>
<li>无序列表需要两个标签参与，分别是<code>&lt;ul&gt;</code>和<code>&lt;li&gt;</code>。<ul>
<li><code>ul</code>：<code>unordered list</code>，表示定义一个无序列表的大结构。</li>
<li><code>li</code>：<code>list item</code>，列表项，定义的是无序列表内的某一项。</li>
</ul>
</li>
<li><code>&lt;ul&gt;</code>和<code>&lt;li&gt;</code>是嵌套关系，快捷键：<code>ul&gt;li</code>。</li>
<li>注意事项<ul>
<li><code>&lt;ul&gt;</code>内部只能嵌套<code>&lt;li&gt;</code>，<code>&lt;li&gt;</code>标签不能脱离<code>&lt;ul&gt;</code>单独书写。</li>
<li><code>&lt;li&gt;</code>标签是一个经典的容器级标签，内部可以放置任意内容，甚至可以放一组<code>ul&gt;li</code>无序列表结构。</li>
<li>无序列表的列表项<code>&lt;li&gt;</code>之间，没有顺序的先后之分，它们的重要程度是相同的</li>
<li>无序列表的作用只是搭建列表结构，没有添加样式前缀的功能，样式是由<code>css</code>负责。</li>
</ul>
</li>
</ul>
</li>
<li>有序列表<ul>
<li>有序列表的语法与无序列表非常类似，只是在语义上有差异。</li>
<li>有序列表由两个标签组成，分别是<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code>。<ul>
<li><code>ol</code>：<code>ordered list</code>，表示定义一个有序的列表的大结构。</li>
<li><code>li</code>：<code>list item</code>，定义的是有序列表的每一项。<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code>是嵌套关系，快捷键：<code>ol&gt;li</code>。</li>
</ul>
</li>
<li><code>&lt;ol&gt;</code>标签内部可以嵌套任意多个<code>&lt;li&gt;</code>标签。</li>
<li>注意事项<ul>
<li><code>&lt;ol&gt;</code>内部只能嵌套<code>&lt;li&gt;</code>标签，而<code>&lt;li&gt;</code>不能脱离<code>&lt;ol&gt;</code>单独书写。</li>
<li><code>&lt;li&gt;</code>标签是一个经典的容器级标签，内部可以放置任何内容，甚至可以放<code>ol&gt;li</code>。</li>
<li>有序列表的列表项<code>&lt;li&gt;</code>之间，存在顺序先后之分，根据内容的顺序需要合理调整书写位置。</li>
<li>有序列表的作用只是搭建有顺序的列表结构，前面的数字排序样式不是<code>&lt;ol&gt;</code>标签的作用，而是<code>css</code>负责的。</li>
</ul>
</li>
</ul>
</li>
<li>定义列表<ul>
<li>自定义列表不仅仅是一列项目，而是项目及其注释的组合。</li>
<li>由三个标签组成完整的结构，包含<code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>。<ul>
<li><code>&lt;dl&gt;</code>：<code>definition list</code>，表示定义一个自定义列表的大结构。</li>
<li><code>&lt;dt&gt;</code>：<code>definition term</code>，表示定义自定义列表中的一个主题或者术语。</li>
<li><code>&lt;dd&gt;</code>：<code>definition description</code>，定义解释项，表示描述或解释前面的定义主题。</li>
</ul>
</li>
<li><code>&lt;dl&gt;</code>内部只能嵌套<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>，<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>是同级关系。</li>
<li>注意事项<ul>
<li><code>&lt;dl&gt;</code>内部只能嵌套<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>，<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code>不能脱离<code>&lt;dl&gt;</code>单独书写。</li>
<li><code>&lt;dl&gt;</code>内部可以放多组<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>，每个<code>&lt;dd&gt;</code>解释说明的是前面的距离最近的一个<code>&lt;dt&gt;</code>。</li>
<li>每个<code>&lt;dt&gt;</code>候面可以有0到多个解释项的<code>&lt;dd&gt;</code>，每个<code>&lt;dd&gt;</code>解释的都是前面距离最近的一个<code>&lt;dt&gt;</code>。</li>
<li><code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>标签也是容器级标签，内部可以放置任意内容。</li>
<li>定义列表中的缩进样式由<code>css</code>主责，标签只负责搭建语义结构。</li>
<li>配合着<code>css</code>布局效果，最好每个<code>dl</code>中只添加一组<code>&lt;dt&gt;</code>和<code>&lt;dd&gt;</code>，便于后期管理</li>
</ul>
</li>
</ul>
</li>
<li>总结<ul>
<li>根据项目的内容不同，分别选择对应语义的列表结构：无序列表、有序列表、定义列表。</li>
</ul>
</li>
</ul>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul>
<li><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>标签常用作布局工具，我们俗称盒子，后期<code>h5</code>也增加了更多的布局标签。</li>
<li><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>都是没有具体明确的语义的。</li>
<li><code>&lt;div&gt;</code>标签<ul>
<li><code>div</code>：全称<code>division</code>，分隔、区域、跨度的意思。俗称大盒子。</li>
<li><code>&lt;div&gt;</code>是双标签，是最经典的容器级标签，内部可以放置任意内容。</li>
<li>作用：多用于划分网页区域，进行结构布局。一般将相关的内容使用<code>&lt;div&gt;</code>包裹起来，整体设置大的布局效果。</li>
</ul>
</li>
<li><code>&lt;span&gt;</code>标签<ul>
<li>span：小区域、小跨度的意思。俗称小盒子。</li>
<li><code>&lt;span&gt;</code>也是双标签，容器级标签。</li>
<li>作用：在不改变整体效果的情况下，可以辅助进行局部调整。</li>
</ul>
</li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><ul>
<li>创建一个简单的表格至少有三个标签组成，分别是<code>&lt;table&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;td&gt;</code>标签。<ul>
<li><code>table</code>：表格，定义的是整个的表格大结构。</li>
<li><code>tr</code>：<code>table rows</code>，表格的行，定义的是表格由多少行组成。</li>
<li><code>td</code>：<code>table data</code>，表格数据，也叫表格单元格，定义的是每一行内部的单元格。</li>
</ul>
</li>
<li>三者的关系：<code>table&gt;tr&gt;td</code>。一个表格中有多个行，每个行中有多个单元格。</li>
<li><code>&lt;table&gt;</code>的属性<ul>
<li><code>&lt;table&gt;</code>标签可以添加<code>border</code>边框属性。<ul>
<li>属性值：数字，表示像素值。</li>
</ul>
</li>
<li>表格的单元格之间有默认的空隙，会导致双线边框。<ul>
<li>解决方法：设置标签样式属性<code>style</code>。</li>
<li>属性值：<code>border-collapse : collapse;</code> 表示边框塌陷。</li>
</ul>
</li>
</ul>
</li>
<li>表头单元格<ul>
<li>如果要绘制表头，使用标签<code>&lt;th&gt;</code>，<code>table head data</code>，表头单元格。</li>
<li>在表格中绘制的时候，替换的是<code>&lt;td&gt;</code>的位置。</li>
<li><code>&lt;th&gt;</code>标签中自带默认的<code>css</code>样式效果，文字显示粗体居中。</li>
</ul>
</li>
<li>合并单元格<ul>
<li>常见的表格操作中，有一种叫做合并单元格，可以通过单元格属性进行设置。</li>
<li>单元格属性<ul>
<li>表格的单元格可以进行合并，通过<code>&lt;th&gt;</code>和<code>&lt;td&gt;</code>的两个属性可以进行合并设置。</li>
<li><code>rowspan</code>：跨行和并。上下的合并。</li>
<li><code>colspan</code>：跨列合并。左右的合并。</li>
<li>属性值：数字，数字是几表示跨几行或跨几列合并。</li>
</ul>
</li>
<li>制作技巧<ul>
<li>先列出所有行<code>&lt;tr&gt;</code>，以最小单元格为标准。</li>
<li>再添加每一行的<code>&lt;td&gt;</code>或<code>&lt;th&gt;</code>单元格。</li>
<li>划分单元格所在行时，顶边对齐的属于同一行。</li>
<li>将所有行和列写完后，再查看哪个单元格有跨行或跨列，属性值的个数要参考最小的单元格。</li>
</ul>
</li>
</ul>
</li>
<li>表格分区<ul>
<li>一个完整的表格分为四个大的区域：表格标题、表格头部、表格主体、表格页脚。</li>
<li>分区标签<ul>
<li><code>&lt;table&gt;</code>内部最直接的子级包含四个分区标签，他们都是双标签。<ul>
<li><code>caption</code>：表格的标题，内部书写标题文字。</li>
<li><code>thead</code>：<code>table head</code>，表格的头部。内部嵌套<code>tr&gt;th</code>。</li>
<li><code>tbody</code>：<code>table body</code>，表格的主体。内部嵌套<code>tr&gt;td</code>。</li>
<li><code>tfoot</code>：<code>table foot</code>，表格的页脚。内部嵌套<code>tr&gt;td</code>。</li>
</ul>
</li>
<li>四个分区可以选择性的进行组合。</li>
<li>注意：不论书写顺序如何颠倒，浏览器中的加载顺序都是自动按照<code>caption</code>、<code>thead</code>、<code>tbody</code>、<code>tfoot</code>执行的。</li>
</ul>
</li>
<li>制作技巧<ul>
<li>先书写大分区标签结构。</li>
<li>填充每个分区的内部内容。</li>
<li>如果有合并单元格内容，进行单元格合并。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ul>
<li>表单是用来收集用户输入信息的。</li>
<li>表单的组成<ul>
<li><code>HTML</code>表单用于搜集不同类型的用户输入，表单元素就是网页中提供用户进行输入或点击的小控件。</li>
<li>在<code>HTML</code>中，一个完整的表单通常由表单域、提示信息和表单控件（也称为表单元素）3个部分构成。</li>
</ul>
</li>
<li>功能<ul>
<li>表单域：相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的<code>url</code>地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</li>
<li>提示信息：一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</li>
<li>表单控件：包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</li>
</ul>
</li>
</ul>
<h3 id="表单域"><a href="#表单域" class="headerlink" title="表单域"></a>表单域</h3><ul>
<li><p>HTML表单域使用<code>&lt;form&gt;</code>标签进行定义。</p>
</li>
<li><p><code>&lt;form&gt;</code>标签是一个功能性标签，填写的表单信息要想正确的提交到后台服务器，必须放在一个<code>&lt;form&gt;</code>标签之内。</p>
</li>
<li><p><code>&lt;form&gt;</code>标签为双标签，容器级标签。</p>
</li>
<li><p>标签属性</p>
<ul>
<li><p><code>&lt;form&gt;</code>标签通过对应属性规定提交数据的方法和提交位置。</p>
</li>
<li><table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>action</code></td>
<td><code>url</code></td>
<td>指定接收并处理表单数据的服务器程序的<code>url</code>地址</td>
</tr>
<tr>
<td><code>method</code></td>
<td><code>get</code>/<code>post</code></td>
<td>用于设置表单数据的提交方式</td>
</tr>
<tr>
<td><code>name</code></td>
<td>自定义名称</td>
<td>规定表单的名称</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><ul>
<li><p><code>&lt;input&gt;</code></p>
<ul>
<li><p><code>&lt;input&gt;</code>标签是最重要的一个表单元素。</p>
</li>
<li><p><code>&lt;input&gt;</code>标签为单标签，本身相当于一个特殊的文本。</p>
</li>
<li><p><code>&lt;input&gt;</code>标签需要通过标签属性实现各种功能。</p>
</li>
<li><table>
    <tr>
        <th>属性名</th>
        <th>属性值</th>
        <th>描述</th>  
    </tr>
    <tr>
        <td rowspan="10">type</td>
        <td>text</td>
        <td>单行文本输入框</td>
    </tr>
    <tr>
        <td>password</td>
        <td>密码输入框</td>
    </tr>
    <tr>
        <td>radio</td>
        <td>单选框</td>
    </tr>
    <tr>
        <td>checkbox</td>
        <td>复选框</td>
    </tr>
    <tr>
        <td>button</td>
        <td>普通按钮</td>
    </tr>
    <tr>
        <td>reset</td>
        <td>重置按钮</td>
    </tr>
    <tr>
        <td>submit</td>
        <td>提交按钮</td>
    </tr>
    <tr>
        <td>image</td>
        <td>图像形式的按钮</td>
    </tr>
    <tr>
        <td>file</td>
        <td>定义输入字段和“浏览"按钮，供文件上传。</td>
    </tr>
    <tr>
        <td>hidden</td>
        <td>定义隐藏的输入字段</td>
    </tr>
    <tr>
        <td>name</td>
        <td>自定义</td>
        <td>定义控件的名称</td>
    </tr>
    <tr>
        <td>value</td>
        <td>自定义</td>
        <td>定义控件的默认文本值</td>
    </tr>
    <tr>
        <td>size</td>
        <td>数字</td>
        <td>定义控件的宽度</td>
    </tr>
    <tr>
        <td>checked</td>
        <td>checked</td>
        <td>定义选框控件的默认被选中项</td>
    </tr>
    <tr>
        <td>maxlength</td>
        <td>数字</td>
        <td>定义允许输入的最多字符数</td>
    </tr>
</table></li>
<li><p>其中，<code>type</code>属性的值不同，决定了<code>&lt;input&gt;</code>标签的形态不同。</p>
</li>
<li><p>单行文本输入框：<code>text</code></p>
<ul>
<li><code>&lt;input&gt;</code>标签的<code>type</code>属性值为<code>text</code>。</li>
<li>定义提供用户输入的单行文本的输入框，不能输入多行文字。</li>
<li>常用<code>value</code>属性定义默认的输入文字。</li>
</ul>
</li>
<li><p>密码输入框：<code>password</code></p>
<ul>
<li><code>&lt;input&gt;</code>标签的<code>type</code>属性值为<code>password</code>。</li>
<li>定义提供用户输入的密码框。</li>
<li><code>password</code> 字段中的字符会被做掩码处理（显示为星号或实心圆）。</li>
</ul>
</li>
<li><p>单选框：<code>radio</code></p>
<ul>
<li><code>&lt;input&gt;</code>标签的<code>type</code>属性值为<code>radio</code>。</li>
<li>定义提供用户点击选择的单选框。</li>
<li>单选框一般都是成组出现，多个单选框组成一组选择的情况。</li>
<li>同一组单选框之间必须是互斥的关系，通过给同一组单选框都设置相同的<code>name</code>属性值实现。</li>
<li>默认选中设置<ul>
<li>单选框和复选框都可以提前设置默认选中项。</li>
<li><code>&lt;input&gt;</code>标签有一个<code>checked</code>属性，如果不设置表示默认没有选中。属性值如果设置为<code>&quot;checked&quot;</code>，表示该项默认被选中。</li>
</ul>
</li>
</ul>
</li>
<li><p>复选框：<code>checkbox</code></p>
<ul>
<li><code>&lt;input&gt;</code>标签的<code>type</code>属性值为<code>checkbox</code>。</li>
<li>定义提供用户点击选择的多选框。</li>
<li>复选框允许用户在有限数量的选项中选择零个或多个选项。</li>
<li>同一组复选框最好也设置相同的name属性。</li>
<li>默认选中设置<ul>
<li>单选框和复选框都可以提前设置默认选中项。</li>
<li><code>&lt;input&gt;</code>标签有一个<code>checked</code>属性，如果不设置表示默认没有选中。属性值如果设置为<code>&quot;checked&quot;</code>，表示该项默认被选中。</li>
</ul>
</li>
</ul>
</li>
<li><p>按钮</p>
<ul>
<li><p><code>&lt;input&gt;</code>标签有四种形式的按钮</p>
</li>
<li><table>
<thead>
<tr>
<th><code>type</code></th>
<th>名称</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><code>button</code></td>
<td>普通按钮</td>
<td>没有任何特殊功能</td>
</tr>
<tr>
<td><code>reset</code></td>
<td>重置按钮</td>
<td>将同一个<code>&lt;form&gt;</code>中填写的表单内容清空，恢复成默认</td>
</tr>
<tr>
<td><code>submit</code></td>
<td>提交按钮</td>
<td>将填写数据提交到<code>&lt;form&gt;</code>中指定的后台服务器，并重置清空<code>&lt;form&gt;</code>中填写的信息</td>
</tr>
<tr>
<td><code>image</code></td>
<td>图片按钮</td>
<td>默认与提交按钮的效果相同，使用的图片需要利用<code>src</code>属性查找正确路径。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>文件上传：<code>file</code></p>
<ul>
<li><code>&lt;input&gt;</code>标签的<code>type</code>属性值为<code>file</code>。</li>
<li>定义文件上传按钮，可以提供用户选择本地文件进行上传服务器。</li>
<li>使用<code>input</code>的<code>multiple</code>属性，可以决定是否可以选择多个文件。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>&lt;textarea&gt;</code></p>
<ul>
<li>文本域使用<code>&lt;textarea&gt;</code>标签定义，制作可以输入多行文本的区域。</li>
<li><code>&lt;textarea&gt;</code>标签为双标签，本身相当于一个特殊的文字。</li>
<li>文本域可以设置默认输入的文字，在双标签之间书写默认文字。</li>
<li><code>&lt;textarea&gt;</code>属性<ul>
<li><code>&lt;textarea&gt;</code>有两个标签属性，可以设置显示区域大小。</li>
<li><code>rows</code>：行，属性值是数字，数字是几表示文本框显示的最大行数，如果超过了行数，会被隐藏并且出现滚动条。</li>
<li><code>cols</code>：列，属性值是数字，数字是几，表示在出现滚动条之后，每一行显示的最大字节数（一个汉字按2字节计算）。</li>
</ul>
</li>
</ul>
</li>
<li><p>下拉菜单</p>
<ul>
<li><code>HTML</code>中的下拉菜单提前设置一些选项，然后可以通过点击选择其中一项。</li>
<li>下拉菜单需要至少两个标签完成结构：<ul>
<li><code>&lt;select&gt;</code>：选择，表示定义下拉菜单整体结构。</li>
<li><code>&lt;option&gt;</code>：选项，表示定义下拉菜单的每一项。</li>
<li>两个标签都是双标签，文本级标签。</li>
<li>关系：<code>select&gt;option</code>，<code>option</code>可以有任意多项。</li>
</ul>
</li>
<li>默认选中项<ul>
<li>默认情况下，选中的是第一项。</li>
<li>下拉菜单可以通过给<code>&lt;option&gt;</code>标签设置<code>selected</code>属性，属性值为<code>selected</code>，更改默认选中项。</li>
</ul>
</li>
<li>分组管理<ul>
<li>下拉菜单中如果选项变得复杂，可以将<code>&lt;option&gt;</code>进行分组管理。</li>
<li>可以使用<code>&lt;optgroup</code>&gt;标签对选项进行分组，<code>&lt;optgroup&gt;</code>是一个双标签。</li>
<li>关系：<code>select&gt;optgroup&gt;option</code></li>
<li><code>&lt;optgroup&gt;</code>可以设置一个<code>label</code>属性，表示给这一组选项添加一个分组标签名，分组标签<code>&lt;optgroup&gt;</code>是不能被点击选择的。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>label</code>标签</p>
<ul>
<li>所有的表单元素都可以通过绑定其他内容去扩大触发点击范围，这时需要使用一个<code>&lt;label&gt;</code>标签。</li>
<li><code>&lt;label&gt;</code>标签的作用是帮表单元素定义标注（标记）。</li>
<li>如果将表单控件与提示内容使用<code>&lt;label&gt;</code>进行绑定后，当用户鼠标点击<code>&lt;label&gt;</code>内的提示内容时，浏览器就会自动将焦点转到和标签相关的表单控件上。</li>
<li>绑定方法一<ul>
<li>给表单元素设置<code>id</code>属性。</li>
<li>然后将需要绑定的其他内容用<code>&lt;label&gt;</code>标签包裹。</li>
<li>给<code>&lt;label&gt;</code>标签设置<code>for</code>属性，属性值为绑定的表单元素的<code>id</code>属性值。</li>
</ul>
</li>
<li>绑定方法二<ul>
<li>如果绑定内容和表单元素写在一起，可以化简绑定写法。</li>
<li>直接使用<code>&lt;label&gt;</code>标签将绑定内容与表单元素一起进行嵌套。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h3><ul>
<li><p>在普通文字书写时，有一些特殊符号不能直接书写（例如连续的空格），或者符号具有特殊功能也不能直接书写（例如<code>&lt;</code> <code>&gt;</code>符号）。可以使用一些<code>HTML</code>提前预留好的替换字符进行书写，这些替换字符叫做字符实体。</p>
</li>
<li><p>通过查询<code>w3cshool</code>手册，查看所有的字符实体。</p>
</li>
<li><p>使用方法：可以查询特殊字符的替换写法，包含实体名称以及实体编号。</p>
</li>
<li><table>
<thead>
<tr>
<th>显示结果</th>
<th>描述</th>
<th>实体名称</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
<td><code>&amp;#160;</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于号</td>
<td><code>&amp;lt;</code></td>
<td><code>&amp;#60;</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于号</td>
<td><code>&amp;gt;</code></td>
<td><code>&amp;#62;</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>和号</td>
<td><code>&amp;amp;</code></td>
<td><code>&amp;#38;</code></td>
</tr>
<tr>
<td><code>&quot;</code></td>
<td>引号</td>
<td><code>&amp;quot;</code></td>
<td><code>&amp;#34;</code></td>
</tr>
<tr>
<td><code>&#39;</code></td>
<td>撇号</td>
<td><code>&amp;apos;</code>(IE不支持)</td>
<td><code>&amp;#39;</code></td>
</tr>
<tr>
<td><code>¢</code></td>
<td>分(<code>cent</code>)</td>
<td><code>&amp;cent;</code></td>
<td><code>&amp;#162;</code></td>
</tr>
<tr>
<td><code>£</code></td>
<td>镑(<code>pound</code>)</td>
<td><code>&amp;pount;</code></td>
<td><code>&amp;#163;</code></td>
</tr>
<tr>
<td><code>¥</code></td>
<td>元(<code>yen</code>)</td>
<td><code>&amp;yen;</code></td>
<td><code>&amp;#165;</code></td>
</tr>
<tr>
<td><code>€</code></td>
<td>欧元(<code>euro</code>)</td>
<td><code>&amp;euro;</code></td>
<td><code>&amp;#8364;</code></td>
</tr>
<tr>
<td><code>§</code></td>
<td>小节</td>
<td><code>&amp;sect;</code></td>
<td><code>&amp;#167;</code></td>
</tr>
<tr>
<td><code>©</code></td>
<td>版权(<code>copyright</code>)</td>
<td><code>&amp;copy;</code></td>
<td><code>&amp;#169;</code></td>
</tr>
<tr>
<td><code>®</code></td>
<td>注册商标</td>
<td><code>&amp;reg;</code></td>
<td><code>&amp;#174;</code></td>
</tr>
</tbody></table>
</li>
<li><p>规则：所有的字符实体和实体编号都是以<code>&amp;</code>开头，以<code>;</code>结尾的。</p>
</li>
<li><p>建议</p>
<ul>
<li>使用实体名称，好处是名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。</li>
<li>不需要强制记忆所有的字符实体，只需要记忆常用的几个字符实体名称即可，其他可以通过手册进行查询。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Html</category>
      </categories>
  </entry>
  <entry>
    <title>Html基础（二）认识HTML</title>
    <url>/2021/07/ba66d0ff8ee2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="HTML概念"><a href="#HTML概念" class="headerlink" title="HTML概念"></a><code>HTML</code>概念</h3><ul>
<li><code>Hypertext Markup Language</code>：<strong>超文本标记语言</strong>。是用来制作网页的一种标记语言<ul>
<li><strong>超文本</strong>：是超级文本的缩写，简单来说超文本就是用于链接另一个文本或多媒体内容的文本，比如链接到图片、链接、音频、视频、程序等</li>
<li><strong>标记</strong>：又叫做标签（<code>HTML tag</code>），有特殊的书写规范，是写给浏览器的一种语法格式，结合普通的文字信息，实现特殊的语义或显示内容。在编辑器中可以编辑和查看，在浏览器中不显示</li>
</ul>
</li>
<li><strong>纯文本格式的文件</strong>，内部只能书写文字内容，不能添加图片、音频、视频等，但是在网页中给用户呈现的效果却包含了文字以外的内容，这种效果就是<code>HTML</code>语言区别于其他文件的不同之处</li>
<li><strong>功能</strong>：利用标记给普通的文本添加语义、描述超文本内容，搭建网页的基本结构</li>
<li><strong>语义化</strong><ul>
<li><code>HTML</code>文件中，如果没有使用特殊语义的标记，也可以实现网页显示效果，但是利用标记给普通的文字添加了不同的语义，能够让网站的结构划分更加清晰</li>
<li>优势<ul>
<li>方便代码的阅读和后期维护</li>
<li>便于浏览器或是网络爬虫更好地解析网站内容</li>
<li>使用语义化标签有利于<code>SEO</code>搜索引擎优化，提高网站的搜索排名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a><code>HTML</code>语法</h3><ul>
<li><p><code>HTML</code>规范版本</p>
<ul>
<li><p><code>W3C</code>：<code>world wide web consortium</code>，万维网联盟。专门发布和维护互联网的规范和标准</p>
</li>
<li><table>
<thead>
<tr>
<th>版本</th>
<th>发布时间</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>HTML1.0</code></td>
<td>1993.06</td>
<td>互联网工程小组（<code>IETF</code>）发布的工作草案</td>
</tr>
<tr>
<td><code>HTML2.0</code></td>
<td>1995.01</td>
<td>2000年6月发布之后被宣布已经过时</td>
</tr>
<tr>
<td><code>HTML3.2</code></td>
<td>1997.01.14</td>
<td><code>W3C</code>推荐标准</td>
</tr>
<tr>
<td><code>HTML4.0</code></td>
<td>1997.12.18</td>
<td><code>W3C</code>推荐标准，引入了样式表<code>CSS</code>，实现了结构和样式分离</td>
</tr>
<tr>
<td><code>HTML4.01</code></td>
<td>1999.12.24</td>
<td><code>W3C</code>推荐标准，修复了<code>HTML4.0</code>中的漏洞</td>
</tr>
<tr>
<td><code>XHTML1.0</code></td>
<td>2000.01.20</td>
<td>在<code>HTML4.01</code>基础上进行的升级拓展和严格化</td>
</tr>
<tr>
<td><code>HTML5</code></td>
<td>2008.01.22</td>
<td><code>HTML5</code>在2012年已形成稳定的版本</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><code>HTML</code>标签</p>
<ul>
<li><code>HTML</code>标记通常被成为<code>HTML</code>标签（<code>HTML tag</code>）。标签在书写和使用过程中，必须遵循特定的语法。</li>
<li><code>HTML</code>标签语法<ul>
<li>标签名必须书写在一堆尖括号&lt;&gt;内部</li>
<li>标签分为单标签和双标签，双标签必须成对出现</li>
<li>双标签包含开始标签和结束标签，结束标签必须书写关闭符号<code>/</code>，单标签也需要进行自封闭书写。在<code>HTML5</code>中，单标签可以不写关闭符号。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>HTML</code>元素</p>
<ul>
<li><code>HTML</code>元素指的是从开始标签到结束标签的所有内容，包含开始标签、元素内容、结束标签。</li>
<li>元素内容<ul>
<li>元素内容可以是纯文本，也可以是其他的<code>HTML</code>元素。这种元素内容包含其他<code>HTML</code>元素的情况，我们可以称为嵌套</li>
<li>一个<code>HTML</code>元素<code>div</code>的内容可能是多个其他元素组成</li>
<li>单标签是不能添加其他元素内容的，可以称为空元素</li>
</ul>
</li>
<li>标签级别<ul>
<li>根据标签内容可以存放的元素内容不同，可以将双标签划分为两个级别<ul>
<li>容器级：标签内部可以存放任意内容，包含容器级标签。比如<code>h1</code>，<code>div</code>等</li>
<li>文本级：标签内部只能存放文字或类似文字的内容，比如存放图片、表单元素等。比如<code>p</code>等</li>
</ul>
</li>
</ul>
</li>
<li><code>HTML</code>元素的特性<ul>
<li>元素间对空格、换行、缩进形成的空白不敏感，有无空白对在浏览器中加载的效果没有影响。浏览器识别的是元素的开始和结束以及相互之间的嵌套关系。</li>
<li>空白折叠现象：元素内容如果是文本，所有文字（类似文字内容）之间如果有空格、换行、缩进等空白字符，在浏览器中加载时，链接在一起的空白会折叠成一个空格显示，这就是空白折叠现象</li>
</ul>
</li>
</ul>
</li>
<li><p><code>HTML</code>属性</p>
<ul>
<li><code>HTML</code>标签可以添加属性，属性可以提供关于<code>HTML</code>元素的更多信息</li>
<li><code>HTML</code>属性规范<ul>
<li>书写位置：必须写在开始标签或者单标签之内，与标签名之间用空格进行分隔</li>
<li>属性包括：属性名（<code>key</code>）、属性值（<code>value</code>）。属性名与属性值之间的写法通常称作键值对写法，<code>HTML</code>标签属性的键值对写法是<code>k=&quot;v&quot;</code>，<code>XHTML</code>要求属性值必须在双引号内部</li>
<li>一个标签内可以设置多个不同的属性，属性与属性之间使用空格进行分隔，每个属性的键值对写法都是<code>k=&quot;v&quot;</code></li>
<li>部分标签属性<code>k</code>可以设置多个属性值<code>v</code>，所有属性值<code>v</code>都必须写在同一对双引号内，值与值之间需要使用空格分隔</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul>
<li>纯文本编辑器<ul>
<li>所有的纯文本编辑器都能编辑<code>HTML</code>文件。例如记事本、<code>Editplus</code>、<code>notepad</code>等</li>
<li>专门制作网页的软件有：<code>sublime</code>、<code>WebStorm</code>、<code>HBuilder</code>、<code>VSCode</code>等</li>
</ul>
</li>
</ul>
<h3 id="HTML基本结构"><a href="#HTML基本结构" class="headerlink" title="HTML基本结构"></a>HTML基本结构</h3><ul>
<li>基本骨架<ul>
<li>HTML文件最基本的四个标签，组成了网页的基本骨架，包括：<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;title&gt;</code>、<code>&lt;body&gt;</code>四组标签</li>
<li><code>&lt;html&gt;</code>标签<ul>
<li>作用：定义<code>HTML</code>文件的根元素，表示整个<code>HTML</code>文档，所有的标签都要书写在<code>&lt;html&gt;</code>标签内部</li>
</ul>
</li>
<li><code>&lt;head&gt;</code>标签<ul>
<li>作用：用于存放<code>&lt;title&gt;</code>，<code>&lt;meta&gt;</code>，<code>&lt;base&gt;</code>，<code>&lt;style&gt;</code>，<code>&lt;script&gt;</code>，<code>&lt;link&gt;</code>。内部用于对网页的设置，除了<code>&lt;title&gt;</code>内部的文字，其他标签都不显示在浏览器上。</li>
<li>注意在<code>&lt;head&gt;</code>标签中我们必须要设置的标签是<code>&lt;title&gt;</code></li>
</ul>
</li>
<li><code>&lt;title&gt;</code>标签<ul>
<li>让网页拥有一个属于自己的标题</li>
<li><code>title</code>中的关键字可以作为搜索引擎抓取时的关键字，提高<code>SEO</code>搜索引擎优化</li>
<li>内部的内容会显示在搜索结果的标题部分</li>
<li>作为浏览器收藏夹默认的网页标题</li>
<li>建议网页必须添加<code>title</code>标签内部内容，内容尽量精简，提取网页的关键字</li>
</ul>
</li>
<li><code>&lt;body&gt;</code>标签<ul>
<li>作用：定义网页的主题部分，用于存放所有的<code>HTML</code>显示内容的标签<code>&lt;p&gt;</code>，<code>&lt;h1&gt;</code>，<code>&lt;a&gt;</code>，<code>&lt;div&gt;</code>等</li>
<li><code>&lt;body&gt;</code>内部的元素内容会显示在浏览器的窗口中</li>
</ul>
</li>
</ul>
</li>
<li><code>DTD</code><ul>
<li>完整的HTML文件的第一行内容叫做文档定义类型，英文<code>DocType Definition</code>，简称<code>DTD</code>。也称作文档声明类型，<code>DocType Declaration</code></li>
<li>作用：告知浏览器该网页使用的是哪个版本的<code>HTML</code>规范，让浏览器按照对应版本的<code>HTML</code>语法进行解析页面</li>
</ul>
</li>
<li>命名空间<ul>
<li><code>&lt;html&gt;</code>元素表示整个网页文档，在开始标签上设置了命名空间<code>xmlns</code>属性</li>
<li>命名空间<code>xmlns</code><ul>
<li><code>xml</code>：可拓展标记语言，使用在传输过程中的规范。被设计用来传输和存储数据，是<code>html</code>的补充。</li>
<li><code>xmlns</code>：全称叫做<code>XML NameSpace</code>，<code>NameSpace</code>叫做命名空间，浏览器会将此命名空间用于该属性所在元素内的所有内容</li>
<li><code>&lt;html&gt;</code>元素的命名空间规定了在不同用户的浏览器中标签语义遵循的统一标准，避免出现标签名冲突，这个标准使用的就是一个固定的网址<code>http://www.w3.org/1999/xhtml</code>中的规范。</li>
</ul>
</li>
<li><code>xml:lang=&quot;en&quot;</code>和<code>lang=&quot;en&quot;</code>表示所有的标签元素内容的语言都是英文，对搜索引擎和浏览器是有帮助的，<code>lang=&quot;zh-cn&quot;</code>表示中文（中国）</li>
</ul>
</li>
<li>字符集<ul>
<li><code>&lt;head&gt;</code>标签内部的<code>&lt;meta&gt;</code>标签通过<code>http-equiv</code>属性定义了当i请安的网页所使用的字符编码。</li>
<li><code>char</code>：<code>character</code>，字符。<code>set</code>：集合。</li>
<li>常用字符集编码<ul>
<li>国际通用字库<ul>
<li><code>UTF-8</code>：以字节为单位对<code>Unicode</code>万国码进行编码，涵盖了所有人类的语言文字，一个汉字为三个字节大小</li>
</ul>
</li>
<li>中文国标字库<ul>
<li><code>gb2312</code>：共收入汉字6763个和包括拉丁字母、希腊字母、日文平假名级片假名字母、俄语西里尔字母在内的682个。</li>
<li><code>gbk</code>：是<code>gb2312</code>的扩展，增加了繁体字，共收入21886个汉字和图形符号，其中汉字（包括部首和构件）21003个，图形符号883个，一个汉字为2个字节大小。</li>
</ul>
</li>
</ul>
</li>
<li>字符集常见问题<ul>
<li>如果没有网页加载速度要求，或者制作的是外文网站，使用<code>utf-8</code></li>
<li>如果含有大量中文汉字的网站，并且要求网页加载速度快，使用<code>gbk</code></li>
<li>注意：<code>meta</code>标签声明的字库，必须和编辑器软件默认编译字库相同，否则会出现两个字库不匹配，浏览器加载时出现乱码</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Html</category>
      </categories>
  </entry>
  <entry>
    <title>Html基础（一）认识网页</title>
    <url>/2021/07/dc17d32a38af/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="认识前端开发"><a href="#认识前端开发" class="headerlink" title="认识前端开发"></a>认识前端开发</h3><ul>
<li><p>前端开发是创建<code>Web</code>页面或<code>app</code>等前端界面呈现给用户的过程</p>
</li>
<li><p>核心技术：<code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>以及衍生出的各种技术、框架等</p>
</li>
<li><p>前端开发带来的改变</p>
<ul>
<li>早期的互联网产品：功能少、速度慢、不美观</li>
<li>现在的互联网产品：内容丰富、功能强大、用户体验增强</li>
</ul>
</li>
<li><p>前端开发应用场景：<code>PC</code>、<code>移动App</code>、小程序、游戏、服务端</p>
</li>
</ul>
<h3 id="认识网页"><a href="#认识网页" class="headerlink" title="认识网页"></a>认识网页</h3><ul>
<li><code>HTML</code>就是用来制作网页文件的</li>
<li>浏览器查看的网页都是<code>.html</code>或<code>.htm</code>文件</li>
<li><code>HTML</code>叫做超文本标记语言（<code>Hypertext Markup Language</code>），用于搭建网页的结构</li>
</ul>
<h3 id="网页的组成"><a href="#网页的组成" class="headerlink" title="网页的组成"></a>网页的组成</h3><ul>
<li>前端三层：<code>HTML</code>（结构层）、<code>CSS</code>（样式层）、<code>JavaScript</code>（行为层）</li>
<li>其他多媒体内容：图片、视频、音频、超级链接等</li>
<li>所有的网页文件都是真实的、物理存在的文件</li>
</ul>
<h3 id="互联网运行过程"><a href="#互联网运行过程" class="headerlink" title="互联网运行过程"></a>互联网运行过程</h3><ul>
<li>开发人员将网页源文件上传到服务器进行存储，用户后期通过客户端（如浏览器软件）发送<code>HTTP</code>请求到服务器，服务器接收请求后进行响应，将存储的相关文件通过<code>HTTP</code>响应回传到用户本地客户端，最终通过客户端将网页文件进行渲染，显示出最终用户看到的网页效果</li>
</ul>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul>
<li>服务器（<code>server</code>），就是一种特殊的计算机，也包括处理器、硬盘、内存、系统总线等，但是由于需要提供更可靠的服务，因此在处理能力、稳定性、可靠性、安全性等方面要求较高</li>
<li>作用：对于<code>WEB</code>来讲，用于存储开发人员上传的网页数据，且需要响应服务请求，并进行处理</li>
<li>要求：对于网站服务器来说，为了让用户随时进行访问，必须24小时不间断工作</li>
</ul>
<h3 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h3><ul>
<li>目前绝大多数网站都采用的是云服务器（<code>Elastic Compute Service, ECS</code>)，云服务器是一种简单高效、安全可靠、处理能力可弹性伸缩的计算服务。其管理方式比物理服务器更简单高效。用户无需提前购买硬件，即可迅速创建或释放任意多台云服务器</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li>客户端（<code>Client</code>）也叫用户端，指的是普通用户使用的终端，客户端有多种形式，比如最常用的就是浏览器、<code>app</code>等，而<code>web</code>开发最主要的客户端形式还是浏览器</li>
<li>浏览器(<code>Browser</code>)，是一种用户上网搜索、查看信息资源的应用程序</li>
<li>功能：用于发送<code>HTTP</code>请求到服务器，接收服务器发回的<code>HTTP</code>响应，渲染<code>HTML</code>网页。</li>
</ul>
<h3 id="主流浏览器"><a href="#主流浏览器" class="headerlink" title="主流浏览器"></a>主流浏览器</h3><ul>
<li>主流的<code>Web</code>页面浏览器有：微软的<code>IE</code>和<code>Microsoft Edge</code>、<code>Mozilla</code>的<code>Firefox</code>、苹果公司的<code>Safari</code>、<code>Google</code>的<code>Chrome</code>及<code>Opera</code>软件公司的<code>Opera</code></li>
</ul>
<h3 id="主流浏览器内核"><a href="#主流浏览器内核" class="headerlink" title="主流浏览器内核"></a>主流浏览器内核</h3><ul>
<li>因为不同浏览器使用内核及所支持的HTML等网页语言标准不同，对网页的渲染效果会有差异</li>
</ul>
<table>
<thead>
<tr>
<th align="center">浏览器</th>
<th align="center">渲染引擎（内核）</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>IE/Edge</code></td>
<td align="center"><code>Trident</code></td>
<td align="center"><code>IE</code>内核</td>
</tr>
<tr>
<td align="center"><code>FireFox</code></td>
<td align="center"><code>Gecko</code></td>
<td align="center"><code>Firefox</code>内核</td>
</tr>
<tr>
<td align="center"><code>Safari</code></td>
<td align="center"><code>Webkit</code></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>Chrome</code></td>
<td align="center"><code>Webkit</code>→<code>Blink</code></td>
<td align="center">统称为<code>Chromium</code>内核或<code>Chrome</code>内核</td>
</tr>
<tr>
<td align="center"><code>Opera</code></td>
<td align="center"><code>Presto</code>→<code>Webkit</code>→<code>Blink</code></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>推荐：使用<code>Chrome</code>浏览器。（渲染效果好、市场占有率高、自带开发者调试工具）</li>
</ul>
<h3 id="浏览器功能"><a href="#浏览器功能" class="headerlink" title="浏览器功能"></a>浏览器功能</h3><ul>
<li>发送<code>HTTP</code>请求，发送的方式是在浏览器地址栏输入对应网址，或者点击超级链接</li>
<li>接收服务器发回的<code>HTTP</code>响应，服务器会发回一个<code>HTML</code>给浏览器</li>
<li>将接收到的<code>HTML</code>进行解析并显示</li>
</ul>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><code>HTTP</code>协议</h3><p><code>Hypertext Transfer Protocol</code>：超文本传输协议。是客户端浏览器或其他程序与<code>WEB</code>服务器之间的应用层通信协议</p>
<ul>
<li><code>HTTP</code>请求<ul>
<li><code>request</code>，浏览器根据网址向对应的服务器发送请求</li>
<li>发起请求的方法：在浏览器地址栏中输入网址，或者点击网址链接</li>
<li><code>HTML</code>页面解析过程中，会发出多个<code>http</code>请求，包含网页的图片、视频、音频等文件请求</li>
</ul>
</li>
<li><code>HTTP</code>响应<ul>
<li><code>response</code>，服务器根据请求响应一个<code>HTML</code>文件，将<code>HTML</code>传输给客户端，在浏览器中进行<code>HTML</code>网页的渲染</li>
</ul>
</li>
</ul>
<h3 id="纯文本格式"><a href="#纯文本格式" class="headerlink" title="纯文本格式"></a>纯文本格式</h3><ul>
<li>纯文本格式，就是没有任何文本修饰的，没有任何粗体，下划线，斜体，图形，符号或特殊字符及特殊打印格式的文本，只保存文本，不保存其格式设置</li>
<li>格式对比<ul>
<li>纯文本格式<ul>
<li>最常见的是<code>.txt</code>文件</li>
<li>只能保存文本，不保存其他的格式或非文本内容</li>
<li>文件小，有利于网络传输</li>
<li>可以通过直接更改扩展名的方式更改保存格式</li>
<li>可以使用任意的纯文本编辑器进行查看和编辑</li>
<li><code>html</code>、<code>css</code>、<code>js</code>文件都是纯文本格式文件</li>
</ul>
</li>
<li>富文本格式<ul>
<li>最常见的是<code>.rtf</code>文件，类似<code>.doc</code>文件</li>
<li>内部可以保存文本的样式、图片等</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>Html</category>
      </categories>
  </entry>
  <entry>
    <title>前端学习路线规划</title>
    <url>/2021/07/7316ff6469dc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li>计算机基本认识</li>
<li>应用的概念</li>
<li>前端和后端</li>
</ul>
<h3 id="入门阶段"><a href="#入门阶段" class="headerlink" title="入门阶段"></a>入门阶段</h3><ul>
<li><code>HTML</code><ul>
<li><code>HTML</code>语法</li>
<li><code>HTML</code>语义化</li>
<li><code>SEO</code>基础</li>
<li><code>HTML5</code></li>
</ul>
</li>
<li><code>CSS</code><ul>
<li><code>CSS</code>语法</li>
<li>页面布局</li>
<li>媒体查询</li>
<li><code>CSS3</code></li>
</ul>
</li>
</ul>
<h3 id="JavaScript进阶"><a href="#JavaScript进阶" class="headerlink" title="JavaScript进阶"></a><code>JavaScript</code>进阶</h3><ul>
<li><code>JavaScript</code>语法</li>
<li>基本的数据结构</li>
<li><code>Web APIs</code></li>
<li><code>ES6+</code></li>
<li>模块化</li>
<li><code>TypeScript</code></li>
</ul>
<h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><ul>
<li><code>npm</code></li>
<li><code>yarn</code></li>
</ul>
<h3 id="CSS进阶"><a href="#CSS进阶" class="headerlink" title="CSS进阶"></a><code>CSS</code>进阶</h3><ul>
<li><code>CSS</code>预处理器<ul>
<li><code>SAAA</code></li>
<li><code>LESS</code></li>
<li><code>PostCSS</code></li>
</ul>
</li>
<li><code>CSS</code>框架<ul>
<li><code>Bootstrap</code></li>
<li><code>tabler</code></li>
<li><code>Semantic UI</code></li>
<li><code>Materialize CSS</code></li>
</ul>
</li>
<li><code>CSS</code>架构规范<ul>
<li><code>OOCSS</code></li>
<li><code>BEM</code></li>
<li><code>SMACSS</code></li>
</ul>
</li>
</ul>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><ul>
<li>代码校验工具<ul>
<li><code>ESLint</code></li>
<li><code>StyleLint</code></li>
<li><code>MarkdownLint</code></li>
</ul>
</li>
<li>模块打包工具<ul>
<li><code>Webpack</code></li>
<li><code>Parcel</code></li>
<li><code>Rollup</code></li>
</ul>
</li>
<li>任务运行器<ul>
<li><code>npm scripts</code></li>
<li><code>Markfile</code></li>
<li><code>Gulp</code></li>
<li><code>Grunt</code></li>
<li><code>Broccoli</code></li>
</ul>
</li>
</ul>
<h3 id="流行的框架"><a href="#流行的框架" class="headerlink" title="流行的框架"></a>流行的框架</h3><ul>
<li><code>Vue.js</code><ul>
<li><code>VueX</code></li>
<li><code>Element UI</code></li>
</ul>
</li>
<li><code>React.js</code><ul>
<li><code>Redux</code></li>
<li><code>AntDesign</code></li>
<li><code>Mobx</code></li>
<li><code>CSS in JS</code></li>
</ul>
</li>
<li><code>Angular</code><ul>
<li><code>RxJS</code></li>
<li><code>ngrx</code></li>
</ul>
</li>
</ul>
<h3 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h3><ul>
<li><code>Node.js</code></li>
<li>渐进式Web应用</li>
<li>服务端渲染</li>
<li>静态站点生成器</li>
<li>桌面应用</li>
<li>移动应用</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>electron-builder常用配置</title>
    <url>/2021/07/ce120d766f28/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="attr">productName</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">//项目名 这也是生成的exe文件的前缀名</span></span><br><span class="line">    <span class="attr">appId</span>: <span class="string">&#x27;com.xxx.xxxxx&#x27;</span>, <span class="comment">//包名</span></span><br><span class="line">    <span class="attr">copyright</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">//版权信息</span></span><br><span class="line">    <span class="attr">directories</span>: &#123;</span><br><span class="line">        <span class="comment">//输出文件夹</span></span><br><span class="line">        <span class="attr">output</span>: <span class="string">&#x27;build&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">nsis</span>: &#123;</span><br><span class="line">        <span class="comment">//nsis相关配置，打包方式为nsis时生效</span></span><br><span class="line">        <span class="attr">oneClick</span>: <span class="literal">false</span>, <span class="comment">// 是否一键安装</span></span><br><span class="line">        <span class="attr">allowElevation</span>: <span class="literal">true</span>, <span class="comment">// 允许请求提升，如果为false，则用户必须使用提升的权限重新启动安装程序。</span></span><br><span class="line">        <span class="attr">allowToChangeInstallationDirectory</span>: <span class="literal">true</span>, <span class="comment">// 允许修改安装目录</span></span><br><span class="line">        <span class="attr">installerIcon</span>: <span class="string">&#x27;./build/icons/aaa.ico&#x27;</span>, <span class="comment">// 安装图标</span></span><br><span class="line">        <span class="attr">uninstallerIcon</span>: <span class="string">&#x27;./build/icons/bbb.ico&#x27;</span>, <span class="comment">//卸载图标</span></span><br><span class="line">        <span class="attr">installerHeaderIcon</span>: <span class="string">&#x27;./build/icons/aaa.ico&#x27;</span>, <span class="comment">// 安装时头部图标</span></span><br><span class="line">        <span class="attr">createDesktopShortcut</span>: <span class="literal">true</span>, <span class="comment">// 创建桌面图标</span></span><br><span class="line">        <span class="attr">createStartMenuShortcut</span>: <span class="literal">true</span>, <span class="comment">// 创建开始菜单图标</span></span><br><span class="line">        <span class="attr">shortcutName</span>: <span class="string">&#x27;xxxx&#x27;</span>, <span class="comment">// 图标名称</span></span><br><span class="line">        <span class="attr">include</span>: <span class="string">&#x27;build/script/installer.nsh&#x27;</span> <span class="comment">// 包含的自定义nsis脚本</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">publish</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">provider</span>: <span class="string">&#x27;generic&#x27;</span>, <span class="comment">// 服务器提供商，也可以是GitHub等等</span></span><br><span class="line">            <span class="attr">url</span>: <span class="string">&#x27;http://xxxxx/&#x27;</span> <span class="comment">// 服务器地址</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">win</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;build/icons/aims.ico&#x27;</span>,</span><br><span class="line">        <span class="attr">target</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&#x27;nsis&#x27;</span>, <span class="comment">//使用nsis打成安装包，&quot;portable&quot;打包成免安装版</span></span><br><span class="line">                <span class="attr">arch</span>: [</span><br><span class="line">                    <span class="string">&#x27;ia32&#x27;</span>, <span class="comment">//32位</span></span><br><span class="line">                    <span class="string">&#x27;x64&#x27;</span> <span class="comment">//64位</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mac</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;build/icons/icon.icns&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">linux</span>: &#123;</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;build/icons&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ul>
<li><a href="https://www.electron.build/configuration/configuration">Common Configuration - electron-builder</a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>electron</category>
      </categories>
  </entry>
  <entry>
    <title>electron安装失败</title>
    <url>/2021/07/4f963243790b/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在安装项目依赖时，出现报错<code>RequestError: read ECONNRESET</code>报错，如下图</p>
<p><img src="https://pic.imgdb.cn/item/60dedff25132923bf80193f3.png"></p>
<p>解决方法：安装<code>cross-env</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g cross-env</span><br></pre></td></tr></table></figure>

<p>然后到项目目录下安装依赖，使用<code>cross-env</code>，注意<code>electron</code>版本号，我当前的版本为<code>13.1.5</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cross-env npm_config_electron_mirror=&quot;https://npm.taobao.org/mirrors/electron/&quot; npm_config_electron_custom_dir=&quot;13.1.5&quot; npm i</span><br></pre></td></tr></table></figure>

<p>安装成功！</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>electron</category>
      </categories>
  </entry>
  <entry>
    <title>electron+vue项目添加vue-devTools</title>
    <url>/2021/06/c860e0e594a7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>首先需要下载vue-devtools离线crx文件，建议使用第三方谷歌商店镜像站</p>
<p><a href="https://chrome.pictureknow.com/">收藏猫插件-Chrome插件商店</a></p>
<p>在商店内找到vue-devtools，选择下载插件手动安装</p>
<p><img src="https://pic.imgdb.cn/item/60dc2e925132923bf8892361.png"></p>
<p>下载完成后解压缩，得到vue-devtools文件夹</p>
<p><img src="https://pic.imgdb.cn/item/60dc2e925132923bf8892376.png"></p>
<p>拿到vue-devtools文件夹路径，在win.loadURL()之前导入vue-devtools插件</p>
<p><img src="https://pic.imgdb.cn/item/60dc2e925132923bf889238e.png"></p>
<p>此时插件已经可以正常使用了</p>
<p><img src="https://pic.imgdb.cn/item/60dc2e975132923bf8893c5e.png"></p>
<p>但还存在一些小问题需要处理</p>
<p><img src="https://pic.imgdb.cn/item/60dc2e975132923bf8893c44.png"></p>
<p>我们回到vue-devtools插件文件夹下，找到manifest.json并打开</p>
<p><img src="https://pic.imgdb.cn/item/60dc2e975132923bf8893c73.png"></p>
<p>将刚才提示所对应的字段手动删除，重新启动electron</p>
<p><img src="https://pic.imgdb.cn/item/60dc2e975132923bf8893c9c.png"></p>
<p>大功告成！</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>electron</category>
      </categories>
  </entry>
  <entry>
    <title>Grunt</title>
    <url>/2021/05/1eecca2bf8cc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><ul>
<li>创建一个 <code>package.json</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn init --yes</span><br><span class="line">// --yes 跳过会话，直接通过默认值生成 package.json</span><br><span class="line">// yarn init --yes # 简写 -y</span><br></pre></td></tr></table></figure>

<ul>
<li>添加<code>Grunt</code>模块</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add grunt</span><br></pre></td></tr></table></figure>

<ul>
<li>添加<code>gruntfile</code>文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">code gruntfile.js</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Grunt的入口文件</span></span><br><span class="line"><span class="comment">// 用于定义一些需要Grunt自动执行的文件</span></span><br><span class="line"><span class="comment">// 需要导出一个函数</span></span><br><span class="line"><span class="comment">// 此函数接收一个grunt的形参，内部提供一些创建任务时可以用到的API</span></span><br><span class="line"><span class="comment">// registerTask注册任务</span></span><br><span class="line"><span class="comment">// 有两个参数，第一个参数可以指定任务名称，第二个参数指定任务函数（当任务发生时，自动执行的函数）</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">grunt</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 命令行执行 yarn grunt foo</span></span><br><span class="line">    grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;foo&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello grunt~&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;任务描述&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other task&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// default 是默认任务名称</span></span><br><span class="line">    <span class="comment">// 通过 grunt 执行时可以省略</span></span><br><span class="line">    <span class="comment">// grunt.registerTask(&#x27;default&#x27;, () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;default task&#x27;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// 第二个参数可以指定此任务的映射任务，</span></span><br><span class="line">    <span class="comment">// 这样执行 default 就相当于执行对应的任务</span></span><br><span class="line">    <span class="comment">// 这里映射的任务会按顺序依次执行，不会同步执行</span></span><br><span class="line">    grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line">    <span class="comment">// 也可以在任务函数中执行其他任务</span></span><br><span class="line">    grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;run-other&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// foo 和 bar 会在当前任务执行完成过后自动依次执行</span></span><br><span class="line">        grunt.<span class="property">task</span>.<span class="title function_">run</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;current task runing~&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 默认 grunt 采用同步模式编码</span></span><br><span class="line">    <span class="comment">// 如果需要异步可以使用 this.async() 方法创建回调函数</span></span><br><span class="line">    <span class="comment">// grunt.registerTask(&#x27;async-task&#x27;, () =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;async task working~&#x27;)</span></span><br><span class="line">    <span class="comment">//   &#125;, 1000)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// 由于函数体中需要使用 this，所以这里不能使用箭头函数</span></span><br><span class="line">    grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;async-task&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> done = <span class="variable language_">this</span>.<span class="title function_">async</span>()</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async task working~&#x27;</span>)</span><br><span class="line">            <span class="title function_">done</span>()</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="标记任务失败"><a href="#标记任务失败" class="headerlink" title="标记任务失败"></a>标记任务失败</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 任务函数执行过程中如果返回 false</span></span><br><span class="line">  <span class="comment">// 则意味着此任务执行失败</span></span><br><span class="line">  grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;bad&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bad working~&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;)</span><br><span class="line">  grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo working~&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar working~&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 如果一个任务列表中的某个任务执行失败</span></span><br><span class="line">  <span class="comment">// 则后续任务默认不会运行</span></span><br><span class="line">  <span class="comment">// 除非 grunt 运行时指定 --force 参数强制执行</span></span><br><span class="line">  grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bad&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line">  <span class="comment">// 异步函数中标记当前任务执行失败的方式是为回调函数指定一个 false 的实参</span></span><br><span class="line">  grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;bad-async&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> done = <span class="variable language_">this</span>.<span class="title function_">async</span>()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async task working~&#x27;</span>)</span><br><span class="line">      <span class="title function_">done</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// grunt.initConfig() 用于为任务添加一些配置选项</span></span><br><span class="line">  grunt.<span class="title function_">initConfig</span>(&#123;</span><br><span class="line">    <span class="comment">// 键一般对应任务的名称</span></span><br><span class="line">    <span class="comment">// 值可以是任意类型的数据</span></span><br><span class="line">    <span class="attr">foo</span>: &#123;</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 任务中可以使用 grunt.config() 获取配置</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(grunt.<span class="title function_">config</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line">    <span class="comment">// 如果属性值是对象的话，config 中可以使用点的方式定位对象中属性的值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(grunt.<span class="title function_">config</span>(<span class="string">&#x27;foo.bar&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多目标任务"><a href="#多目标任务" class="headerlink" title="多目标任务"></a>多目标任务</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 多目标模式，可以让任务根据配置形成多个子任务</span></span><br><span class="line">  <span class="comment">// grunt.initConfig(&#123;</span></span><br><span class="line">  <span class="comment">//   build: &#123;</span></span><br><span class="line">  <span class="comment">//     foo: 100,</span></span><br><span class="line">  <span class="comment">//     bar: &#x27;456&#x27;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  <span class="comment">// grunt.registerMultiTask(&#x27;build&#x27;, function () &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(`task: build, target: $&#123;this.target&#125;, data: $&#123;this.data&#125;`)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">  grunt.<span class="title function_">initConfig</span>(&#123;</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;task options&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">foo</span>: &#123;</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">msg</span>: <span class="string">&#x27;foo target options&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;456&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  grunt.<span class="title function_">registerMultiTask</span>(<span class="string">&#x27;build&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="title function_">options</span>())</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插件使用"><a href="#插件使用" class="headerlink" title="插件使用"></a>插件使用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.<span class="title function_">initConfig</span>(&#123;</span><br><span class="line">    <span class="attr">clean</span>: &#123;</span><br><span class="line">      <span class="attr">temp</span>: <span class="string">&#x27;temp/**&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  grunt.<span class="title function_">loadNpmTasks</span>(<span class="string">&#x27;grunt-contrib-clean&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&#x27;sass&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> loadGruntTasks = <span class="built_in">require</span>(<span class="string">&#x27;load-grunt-tasks&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">grunt</span> =&gt;</span> &#123;</span><br><span class="line">  grunt.<span class="title function_">initConfig</span>(&#123;</span><br><span class="line">    <span class="attr">sass</span>: &#123;</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">implementation</span>: sass</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">main</span>: &#123;</span><br><span class="line">        <span class="attr">files</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;dist/css/main.css&#x27;</span>: <span class="string">&#x27;src/scss/main.scss&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">babel</span>: &#123;</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">sourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">main</span>: &#123;</span><br><span class="line">        <span class="attr">files</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;dist/js/app.js&#x27;</span>: <span class="string">&#x27;src/js/app.js&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">      <span class="attr">js</span>: &#123;</span><br><span class="line">        <span class="attr">files</span>: [<span class="string">&#x27;src/js/*.js&#x27;</span>],</span><br><span class="line">        <span class="attr">tasks</span>: [<span class="string">&#x27;babel&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">css</span>: &#123;</span><br><span class="line">        <span class="attr">files</span>: [<span class="string">&#x27;src/scss/*.scss&#x27;</span>],</span><br><span class="line">        <span class="attr">tasks</span>: [<span class="string">&#x27;sass&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// grunt.loadNpmTasks(&#x27;grunt-sass&#x27;)</span></span><br><span class="line">  <span class="title function_">loadGruntTasks</span>(grunt) <span class="comment">// 自动加载所有的 grunt 插件中的任务</span></span><br><span class="line">  grunt.<span class="title function_">registerTask</span>(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;sass&#x27;</span>, <span class="string">&#x27;babel&#x27;</span>, <span class="string">&#x27;watch&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
  </entry>
  <entry>
    <title>自动化构建</title>
    <url>/2021/05/15c23d295a5f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><ul>
<li>自动化构建<ul>
<li>将源代码自动化构建成为生产代码，这样的转换的过程称为自动化构建工作流</li>
</ul>
</li>
<li>作用<ul>
<li>脱离运行环境兼容带来的问题</li>
<li>开发阶段使用提高效率的语法、规范和标准</li>
</ul>
</li>
<li>应用场景<ul>
<li><code>ECMAScript Next</code></li>
<li><code>Sass</code></li>
<li>模板引擎</li>
</ul>
</li>
<li>案例<ul>
<li>利用构建工具将<code>sass</code>文件自动构建为<code>css</code>文件，这样就可以在开发工程中使用<code>sass</code>语法进行代码开发，而不用担心打包后的文件<code>sass</code>文件处理的问题</li>
</ul>
</li>
</ul>
<h1 id="常用的自动化构建工具"><a href="#常用的自动化构建工具" class="headerlink" title="常用的自动化构建工具"></a>常用的自动化构建工具</h1><ul>
<li><p><code>Grunt</code></p>
<ul>
<li>最早的前端构建系统，插件生态非常完善，几乎可以完成任何想要做的事</li>
<li>工作过程是基于临时文件实现的，所以构建速度相对较慢</li>
</ul>
</li>
<li><p><code>Gulp</code></p>
<ul>
<li>很好的解决了<code>Grunt</code>当中构建速度慢的问题，基于内存实现的</li>
<li>支持同时执行多个任务</li>
<li>使用方式相对<code>Grunt</code>直观易懂，插件同样十分完善</li>
</ul>
</li>
<li><p><code>FIS</code></p>
<ul>
<li>捆绑套餐，集成了项目当中许多典型的需求，例如资源加载、模块开发、代码部署、性能优化</li>
<li>灵活性相对较低</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
  </entry>
  <entry>
    <title>脚手架的工作原理</title>
    <url>/2021/05/94aba96ecc2f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>脚手架工具实际上是一个<code>node cli</code>应用，创建脚手架工具实际上就是创建<code>cli</code>应用</p>
<ul>
<li>在项目目录下初始化<code>package.json</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure>

<ul>
<li><code>vscode</code>打开这个目录，在<code>package.json</code>中添加<code>bin</code>字段，用来指定入口文件</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sample-scaffolding&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cli.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MIT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在根目录下新建<code>cli.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">// Node CLI应用入口文件必须要有这样的文件头</span></span><br><span class="line"><span class="comment">// 如果是Linux或者是macOS系统下还需要修改此we年的读写权限为755</span></span><br><span class="line"><span class="comment">// 具体就是通过chmon755 cli.js实现修改</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cli working&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>在命令行通过<code>yarn link</code>的方式将这个模块<code>link</code>到全局</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn link</span><br></pre></td></tr></table></figure>

<ul>
<li>在命令行当中使用<code>sample-scaffolding</code>执行<code>cli.js</code>，如果命令行输出结果为<code>&quot;cli working&quot;</code>，说明执行成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sample-scaffolding</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>inquirer</code>进行命令行交互，安装<code>inquirer</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add inquirer</span><br></pre></td></tr></table></figure>

<ul>
<li>脚手架的工作过程</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、通过命令行交互询问用户问题</span></span><br><span class="line"><span class="comment">//2、根据用户回答的结果生成文件</span></span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>);</span><br><span class="line">inquirer.<span class="title function_">prompt</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span>:<span class="string">&#x27;Project name&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">answer</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(answer);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在命令行执行<code>sample-scaffolding</code>，能返回结果说明执行成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sample-scaffolding</span><br></pre></td></tr></table></figure>

<ul>
<li>新建模板目录`templates/index.html</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">        &lt;%= name %&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新建<code>templates/style.css</code>（第二个模板）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f8f9fb</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要用到通过模板引擎渲染文件，所以安装模板引擎</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 这里安装的是ejs模板引擎</span><br><span class="line">yarn add ejs</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个新的文件目录<code>demo</code></li>
</ul>
<ul>
<li>在新的文件目录命令行下执行sample-scaffolding，将会在demo目录下生成模板文件渲染出来的文件</li>
</ul>
<ul>
<li>完整编码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="comment">// Node CLI应用入口文件必须要有这样的文件头</span></span><br><span class="line"><span class="comment">// 如果是Linux或者是macOS系统下还需要修改此we年的读写权限为755</span></span><br><span class="line"><span class="comment">// 具体就是通过chmon755 cli.js实现修改</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;cli working&#x27;</span>)</span><br><span class="line"><span class="comment">//脚手架的工作过程：</span></span><br><span class="line"><span class="comment">//1、通过命令行交互询问用户问题</span></span><br><span class="line"><span class="comment">//2、根据用户回答的结果生成文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入模板引擎</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>);</span><br><span class="line">inquirer.<span class="title function_">prompt</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span>:<span class="string">&#x27;Project name&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">]).<span class="title function_">then</span>(<span class="function"><span class="params">answer</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(answer);</span></span><br><span class="line">    <span class="comment">// 根据用户回答的结果生成文件</span></span><br><span class="line">    <span class="comment">// 模板目录</span></span><br><span class="line">    <span class="keyword">const</span> tmplDir = path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;templates&#x27;</span>);</span><br><span class="line">    <span class="comment">// 目标目录</span></span><br><span class="line">    <span class="keyword">const</span> destDir = process.<span class="title function_">cwd</span>();</span><br><span class="line">    <span class="comment">//将模板下的文件全部转换到目标目录</span></span><br><span class="line">    fs.<span class="title function_">readdir</span>(tmplDir,<span class="function">(<span class="params">err,files</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="comment">// 遍历每一个文件</span></span><br><span class="line">        files.<span class="title function_">forEach</span>(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 通过模板引擎渲染文件</span></span><br><span class="line">            ejs.<span class="title function_">renderFile</span>(path.<span class="title function_">join</span>(tmplDir,file),answer,<span class="function">(<span class="params">err,result</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">                <span class="comment">// 将结果写入到目标文件目录fs.writeFileSync(path.join(destDir,file),result)</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
  </entry>
  <entry>
    <title>Plop</title>
    <url>/2021/05/7994ecbf42a5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul>
<li>将<code>plop</code>作为一个<code>npm</code>模块安装到开发依赖当中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add plop --dev</span><br></pre></td></tr></table></figure>

<ul>
<li>项目根目录下新建一个<code>plopfile.js</code>文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Plop入口文件,需要导出一个函数</span></span><br><span class="line"><span class="comment">// 此函数接收一个Plop对象，用于创建生成器任务</span></span><br><span class="line"><span class="comment">// setGenerator需要两个参数，第一个参数是项目名字，第二个参数是项目配置</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">plop</span> =&gt;</span> &#123;</span><br><span class="line">    plop.<span class="title function_">setGenerator</span>(<span class="string">&#x27;component&#x27;</span>,&#123;</span><br><span class="line">        <span class="attr">description</span>:<span class="string">&#x27;create a component&#x27;</span>,</span><br><span class="line">        <span class="attr">prompots</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">type</span>:<span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">                <span class="attr">name</span>:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">                <span class="attr">message</span>:<span class="string">&#x27;component name&#x27;</span>,</span><br><span class="line">                <span class="attr">default</span>:<span class="string">&#x27;MyCompontent&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">　　　　　<span class="comment">// 添加多个模板，就在actions中添加多个数组</span></span><br><span class="line">        <span class="attr">actions</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js&#x27;</span>,</span><br><span class="line">                <span class="attr">templateFile</span>:<span class="string">&#x27;plop-templates/component.hbs&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">                <span class="attr">path</span>:<span class="string">&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js&#x27;</span>,</span><br><span class="line">                <span class="attr">templateFile</span>:<span class="string">&#x27;plop-templates/component.test.hbs&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新建<code>plop-templates</code>文件夹，在此文件夹下新建<code>components.hbs</code>文件，写入模板</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;React&#x27;;</span><br><span class="line">export default() =&gt; (</span><br><span class="line">    &lt;div className=&quot;&#123;&#123;name&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;name&#125;&#125;Component&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>yarn</code>启动<code>plop</code>程序</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn plop component</span><br></pre></td></tr></table></figure>

<ul>
<li>总结<ul>
<li>将<code>plop</code>模块作为项目开发依赖安装</li>
<li>在项目根目录下创建一个<code>plopfile.js</code>文件</li>
<li>在<code>plopfile.js</code>文件中定义脚手架任务</li>
<li>编写用于生产特定类型文件的模板</li>
<li>通过<code>plop</code>提供的<code>CLI</code>运行脚手架任务</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
  </entry>
  <entry>
    <title>Yeoman</title>
    <url>/2021/05/bc60b4a212ef/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>用来创造现代化<code>Web</code>应用的工具</p>
<ul>
<li>在全局范围安装<code>yo</code><ul>
<li><code>npm install yo --global</code></li>
</ul>
</li>
<li><code>yeoman</code>需要搭配特定的<code>generator</code>来使用，例如使用<code>generator-node</code><ul>
<li>安装对应的<code>Generator</code><ul>
<li><code>npm install generator-node --global</code></li>
</ul>
</li>
<li>通过<code>Yo</code>运行<code>Generator</code><ul>
<li><code>cd path/to/porject-dir</code></li>
<li><code>mkdir my-module</code></li>
<li><code>yo node</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Sub-Generator"><a href="#Sub-Generator" class="headerlink" title="Sub Generator"></a><code>Sub Generator</code></h1><p>有时候我们并不需要创建完整的项目目录结构，只是需要在已有的项目基础之上创建一些特定类型的文件</p>
<ul>
<li><p>例如在<code>my-module</code>目录下使用<code>generator-node</code>所提供的子集生成器<code>cli</code>，使项目模块编程<code>cli</code>应用</p>
<ul>
<li>在目录下使用<code>yo node:cli</code></li>
<li>将本地模块<code>link</code>到全局，在目录下使用<code>npm link</code></li>
<li>此时就可以在全局使用项目命令<code>my-module --help</code></li>
</ul>
</li>
<li><p>并不是所有的<code>Generator</code>都会有子集生成器，所以需要自己去官方文档查看使用</p>
</li>
</ul>
<h1 id="Yeoman的使用"><a href="#Yeoman的使用" class="headerlink" title="Yeoman的使用"></a><code>Yeoman</code>的使用</h1><ul>
<li>明确需求</li>
<li>找到合适的<code>Generator</code></li>
<li>全局范围安装找到的<code>Generator</code></li>
<li>通过<code>Yo</code>运行对应的<code>Generator</code></li>
<li>通过命令行交互填写选项</li>
<li>生成所需要的项目结构</li>
</ul>
<h1 id="自定义Generator"><a href="#自定义Generator" class="headerlink" title="自定义Generator"></a>自定义<code>Generator</code></h1><p>虽然市面的<code>Generator</code>已经有很多了，也很成熟了，但是我们还是有创建自己<code>Generator</code>的必要，因为在实际开发中会出现一部分基础代码和业务代码也是重复性质的，这时我们就可以将这部分代码都放到脚手架中生成，让脚手架可以发挥更大的价值</p>
<h2 id="创建Generator模块"><a href="#创建Generator模块" class="headerlink" title="创建Generator模块"></a>创建<code>Generator</code>模块</h2><ul>
<li><code>mkdir generator-sample</code> 创建<code>Generator</code>目录</li>
<li><code>cd generator-sample</code> 进入目录</li>
<li><code>yarn init</code> 初始化<code>package.json</code></li>
<li><code>yarn add yeoman-generator</code> 安装<code>yeoman-generator</code>模块，该模块提供了生成器的基类，提供了一些工具函数，为创建生成器提供便捷</li>
<li>创建 <code>generators/app/index.js</code> <ul>
<li>此文件作为 <code>Generator</code> 的核心入口</li>
<li>需要导出一个继承自 <code>Yeoman Generator</code> 的类型</li>
<li><code>Yeoman Generator</code> 在工作时会自动调用我们在此类型中定义的一些生命周期方法</li>
<li>我们在这些方法中可以通过调用父类提供的一些工具方法实现一些功能，例如文件写入</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Generator</span> = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">// Yeoman 自动在生成文件阶段调用此方法</span></span><br><span class="line">    <span class="comment">// 我们这里尝试往项目目录中写入文件</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fs</span>.<span class="title function_">write</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">destinationPath</span>(<span class="string">&#x27;temp.txt&#x27;</span>),</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>()</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用 <code>yarn link</code> 链接到全局范围，使之成为全局模块包，此时<code>yeman</code>工作时就可以找到该模块包</li>
<li><code>yo sample</code>执行<code>Generator</code></li>
</ul>
<blockquote>
<ul>
<li><code>Generator</code>本质上就是一个<code>NPM</code>模块</li>
<li><code>Generator</code>的基本结构</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60d30889844ef46bb23d1281.png"></p>
<ul>
<li>名称格式必须为<code>generator-&lt;name&gt;</code></li>
</ul>
</blockquote>
<h2 id="根据模板创建文件"><a href="#根据模板创建文件" class="headerlink" title="根据模板创建文件"></a>根据模板创建文件</h2><ul>
<li>在<code>generators/app</code>目录下创建<code>templates</code>目录，存放模板文件，模板中完全支持<code>ejs</code>模板引擎，相对于手动创建每个文件，模板的方式可以大大提高效率，尤其是在文件多并且复杂的情况下</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= name %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&lt;%= name %&gt;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>index.js</code>导入模板文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Generator</span> = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">// 通过模板方式写入文件到目标目录</span></span><br><span class="line">    <span class="comment">// 模板文件路径</span></span><br><span class="line">    <span class="keyword">const</span> tmpl = <span class="variable language_">this</span>.<span class="title function_">templatePath</span>(<span class="string">&#x27;foo.txt&#x27;</span>)</span><br><span class="line">    <span class="comment">// 输出目标路径</span></span><br><span class="line">    <span class="keyword">const</span> output = <span class="variable language_">this</span>.<span class="title function_">destinationPath</span>(<span class="string">&#x27;foo.txt&#x27;</span>)</span><br><span class="line">    <span class="comment">// 模板数据上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = &#123; <span class="attr">title</span>: <span class="string">&#x27;Hello zce~&#x27;</span>, <span class="attr">success</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fs</span>.<span class="title function_">copyTpl</span>(tmpl, output, context)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>yo sample</code>运行<code>Generator</code></li>
</ul>
<h2 id="接受用户输入数据"><a href="#接受用户输入数据" class="headerlink" title="接受用户输入数据"></a>接受用户输入数据</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Generator</span> = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  prompting () &#123;</span><br><span class="line">    <span class="comment">// Yeoman 在询问用户环节会自动调用此方法</span></span><br><span class="line">    <span class="comment">// 在此方法中可以调用父类的 prompt() 方法发出对用户的命令行询问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">prompt</span>([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&#x27;Your project name&#x27;</span>,</span><br><span class="line">        <span class="attr">default</span>: <span class="variable language_">this</span>.<span class="property">appname</span> <span class="comment">// appname 为项目生成目录名称</span></span><br><span class="line">      &#125;</span><br><span class="line">    ])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// answers =&gt; &#123; name: &#x27;user input value&#x27; &#125;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">answers</span> = answers</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  writing () &#123;</span><br><span class="line">    <span class="comment">// 模板文件路径</span></span><br><span class="line">    <span class="keyword">const</span> tmpl = <span class="variable language_">this</span>.<span class="title function_">templatePath</span>(<span class="string">&#x27;bar.html&#x27;</span>)</span><br><span class="line">    <span class="comment">// 输出目标路径</span></span><br><span class="line">    <span class="keyword">const</span> output = <span class="variable language_">this</span>.<span class="title function_">destinationPath</span>(<span class="string">&#x27;bar.html&#x27;</span>)</span><br><span class="line">    <span class="comment">// 模板数据上下文</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>.<span class="property">answers</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fs</span>.<span class="title function_">copyTpl</span>(tmpl, output, context)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
  </entry>
  <entry>
    <title>脚手架工具</title>
    <url>/2021/05/0961306b307e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="脚手架的本质作用"><a href="#脚手架的本质作用" class="headerlink" title="脚手架的本质作用"></a>脚手架的本质作用</h1><p>创建项目基础解构、提供项目规范和约定</p>
<ul>
<li>相同的组织结构</li>
<li>相同的开发范式</li>
<li>相同的模块依赖</li>
<li>相同的工具配置</li>
<li>相同的基础代码</li>
</ul>
<h1 id="常用的脚手架工具"><a href="#常用的脚手架工具" class="headerlink" title="常用的脚手架工具"></a>常用的脚手架工具</h1><ul>
<li>为特定的项目类型服务的，根据信息创建对应的项目基础结构，一般只适用于自身所服务的框架项目<ul>
<li><code>React</code>:<code>create-react-app</code></li>
<li><code>Vue</code>:<code>vue-cli</code></li>
<li><code>Angular</code>:<code>angular-cli</code></li>
</ul>
</li>
<li>通用型项目脚手架工具，一般很灵活，很容易扩展<ul>
<li><code>Yeoman</code></li>
</ul>
</li>
<li>项目中创建特定类型的文件<ul>
<li><code>Plop</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
  </entry>
  <entry>
    <title>工程化概述</title>
    <url>/2021/05/6691ba82146f/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前端工程化是指遵循一定标准和规范，通过工具提高效率降低成本的一种手段。</p>
<h1 id="没有工程化时面临的问题"><a href="#没有工程化时面临的问题" class="headerlink" title="没有工程化时面临的问题"></a>没有工程化时面临的问题</h1><ul>
<li>传统语言或语法的弊端<ul>
<li>想要使用<code>ES6+</code>新特性，但是兼容有问题</li>
<li>想要使用<code>Less</code>/<code>Sass</code>/<code>PostCss</code>增强<code>css</code>的编程性，但是运行环境不能直接支持</li>
</ul>
</li>
<li>无法使用模块化<ul>
<li>想要使用模块化的方式提高项目的可维护性，但运行环境不能直接支持</li>
</ul>
</li>
<li>重复的机械式工作<ul>
<li>部署上线前需要手动压缩代码及资源文件</li>
<li>部署过程需要手动上传代码到服务器</li>
</ul>
</li>
<li>代码风格统一、质量保证<ul>
<li>多人协作开发，无法硬性统一大家的代码风格，从仓库中pull回来的代码质量无法保证</li>
</ul>
</li>
<li>依赖后端服务接口支持<ul>
<li>部分功能开发时需要等待后端服务接口提前完成</li>
</ul>
</li>
<li>整体依赖后端项目</li>
</ul>
<h1 id="工程化表现"><a href="#工程化表现" class="headerlink" title="工程化表现"></a>工程化表现</h1><p>一切以提高效率、降低成本、质量保证为目的的手段都属于工程化</p>
<ul>
<li>创建项目<ul>
<li>创建项目结构</li>
<li>创建特定类型文件</li>
</ul>
</li>
<li>编码<ul>
<li>格式化代码</li>
<li>校验代码风格</li>
<li>编译/构建/打包</li>
</ul>
</li>
<li>预览/测试<ul>
<li><code>Web Server</code> / <code>Mock</code></li>
<li><code>Live Reloading</code> / <code>HMR</code></li>
<li><code>Source Map</code></li>
</ul>
</li>
<li>提交<ul>
<li><code>Git Hooks</code></li>
<li><code>Lint-staged</code></li>
<li>持续集成</li>
</ul>
</li>
<li>部署<ul>
<li><code>CI</code> / <code>CD</code></li>
<li>自动发布</li>
</ul>
</li>
</ul>
<h1 id="工程化-≠-某个工具"><a href="#工程化-≠-某个工具" class="headerlink" title="工程化 ≠ 某个工具"></a>工程化 ≠ 某个工具</h1><p>项目工程化架构</p>
<p><img src="https://pic.imgdb.cn/item/60d30889844ef46bb23d1256.png"></p>
<p>一些成熟的工程化集成</p>
<ul>
<li><code>create-react-app</code></li>
<li><code>vue-cli</code></li>
<li><code>angular-cli</code></li>
<li><code>gatsby-cli</code></li>
</ul>
<h1 id="工程化与Node-js"><a href="#工程化与Node-js" class="headerlink" title="工程化与Node.js"></a>工程化与<code>Node.js</code></h1><p>前端工程化是由<code>node</code>强力驱动的</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>工程化</category>
      </categories>
  </entry>
  <entry>
    <title>JSDoc</title>
    <url>/2021/05/aa8a51edc8a7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是JSDoc"><a href="#什么是JSDoc" class="headerlink" title="什么是JSDoc"></a>什么是<code>JSDoc</code></h1><p><code>JSDoc</code> 是一个根据 <code>JavaScript</code> 文件中注释信息，生成 <code>JavaScript</code> 应用程序或模块的<code>API</code>文档的工具。你可以使用 <code>JSDoc</code> 标记如：<strong>命名空间</strong>，<strong>类</strong>，<strong>方法</strong>，<strong>方法参数</strong>等。从而使开发者能够轻易地阅读代码，掌握代码定义的类和其属性和方法，从而降低维护成本，和提高开发效率。</p>
<h1 id="JSDoc-注释规则"><a href="#JSDoc-注释规则" class="headerlink" title="JSDoc 注释规则"></a><code>JSDoc</code> 注释规则</h1><p><code>JSDoc</code>注释一般应该放置在方法或函数声明之前，它必须以<code>/**</code>开始，以便由<code>JSDoc</code>解析器识别。其他任何以<code>/*</code>、<code>/***</code>或者超过3个星号的注释，都将被<code>JSDoc</code>解析器忽略。</p>
<p>JavaScript 项目中如何有更好的类型提示：<code>JSDoc</code> + <a href="https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types"><code>import-types</code></a></p>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p><code>@ts-check</code></p>
<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><ul>
<li><code>@augments parent</code><ul>
<li>指明继承自哪个父类</li>
</ul>
</li>
<li><code>@author 作者名字</code> <ul>
<li>指明作者</li>
</ul>
</li>
<li><code>@callback fuc</code><ul>
<li>指明这是一个回调函数，可传递给其他函数</li>
</ul>
</li>
<li><code>@class</code><ul>
<li>指明需要使用<code>new</code>关键字调用，别名<code>@constructor</code></li>
</ul>
</li>
<li><code>@classdesc 类描述</code><ul>
<li>为类添加一大段描述</li>
</ul>
</li>
<li><code>@constant [ ]</code><ul>
<li>记录一个对象为一个常量</li>
</ul>
</li>
<li><code>@constructor</code><ul>
<li>指明函数为构造函数</li>
</ul>
</li>
<li><code>@copyright</code><ul>
<li>指明版权信息</li>
</ul>
</li>
<li><code>@default []</code><ul>
<li>记录默认值，使用该标签以后会自动添加到文档</li>
</ul>
</li>
<li><code>@description</code><ul>
<li>提供一般描述，如果在注释开始的地方添加描述，那么可省略该标签</li>
</ul>
</li>
<li><code>@enum []</code><ul>
<li>描述一个相关属性的集合</li>
</ul>
</li>
<li><code>@examples</code><ul>
<li>提供一个如何使用描述项的例子</li>
</ul>
</li>
<li><code>@exports moduleName</code><ul>
<li>标识一个模块</li>
</ul>
</li>
<li><code>@function name</code><ul>
<li>标记一个对象为一个函数</li>
</ul>
</li>
<li><code>@global</code><ul>
<li>指明一个全局对象</li>
</ul>
</li>
<li><code>@instance</code><ul>
<li>记录一个实例成员</li>
</ul>
</li>
<li><code>@license</code><ul>
<li>标识代码采用何种软件许可协议</li>
</ul>
</li>
<li><code>@member [] []</code><ul>
<li>记录一个成员</li>
</ul>
</li>
<li><code>@module</code><ul>
<li>记录一个<code>JavaScript</code>模块</li>
</ul>
</li>
<li><code>@namespace</code><ul>
<li>记录一个命名空间</li>
</ul>
</li>
<li><code>@override</code><ul>
<li>指明一个标识符覆盖其父类同名标识符</li>
</ul>
</li>
<li><code>@param</code><ul>
<li>记录函数参数，别名<code>arg</code>、<code>argument</code></li>
</ul>
</li>
<li><code>@param &#123;string&#125; name 描述</code> <ul>
<li>存在多种类型</li>
</ul>
</li>
<li><code>@param &#123;string | string[]&#125; name 描述</code><ul>
<li>重复使用的参数</li>
</ul>
</li>
<li><code>@param &#123;…number&#125; num</code><ul>
<li>可选参数，默认值</li>
</ul>
</li>
<li><code>@param &#123;string&#125; [name = 123]</code></li>
<li><code>@returns &#123;string&#125; 描述</code><ul>
<li>记录一个函数的返回值，别名<code>return</code></li>
</ul>
</li>
<li><code>@static</code><ul>
<li>记录一个静态成员</li>
</ul>
</li>
<li><code>@this</code><ul>
<li><code>this</code>关键字的指向</li>
</ul>
</li>
<li><code>@throws</code><ul>
<li>描述可能会被抛出什么样的错误</li>
</ul>
</li>
<li><code>@version</code><ul>
<li>描述版本信息</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>This</title>
    <url>/2021/05/d8371860c131/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于 <code>this</code> 的总结：</p>
<ul>
<li>沿着作用域向上找最近的一个 <code>function</code>（不是箭头函数），看这个 <code>function</code> 最终是怎样执行的；</li>
<li><strong><code>this</code> 的指向取决于所属 <code>function</code> 的调用方式，而不是定义；</strong></li>
<li><code>function</code> 调用一般分为以下几种情况：<ul>
<li>作为函数调用，即：<code>foo()</code><ul>
<li>指向全局对象（<code>globalThis</code>），注意严格模式问题，严格模式下是 <code>undefined</code></li>
</ul>
</li>
<li>作为方法调用，即：<code>foo.bar()</code> / <code>foo.bar.baz()</code> / <code>foo[&#39;bar&#39;]()</code> / <code>foo[0]()</code><ul>
<li>指向最终调用这个方法的对象</li>
</ul>
</li>
<li>作为构造函数调用，即：<code>new Foo()</code><ul>
<li>指向一个新对象 <code>Foo &#123;&#125;</code></li>
</ul>
</li>
<li>特殊调用，即：<code>foo.call()</code> / <code>foo.apply()</code> / <code>foo.bind()</code><ul>
<li>参数指定成员</li>
</ul>
</li>
</ul>
</li>
<li>找不到所属的 <code>function</code>，就是全局对象</li>
<li>箭头函数中的 <code>this</code> 指向其所在（即定义的位置）上下文的<code>this</code>值</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JSBench</title>
    <url>/2021/05/81e2a5b98f88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><a href="https://jsbench.me/"><code>JSBench</code></a>是一个可以在线测试<code>js</code>执行效率的网站</p>
<p><img src="https://pic.imgdb.cn/item/60ebe6ef5132923bf8de76f4.png"></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul>
<li>测试时尽量只开一个标签页，浏览器是多线程的，打开的标签页过多，会抢占执行资源，使得测试不准确</li>
<li>测试时尽可能页面停留在测试页面，避免页面被挂起造成测试不准确</li>
<li>不能执行完一遍代码就下定结论，应该使脚本多执行几次取概率高的测试结果</li>
<li>不要纠结于代码的执行时间，时间只是<code>js</code>执行效率众多指标中的其中之一，时间快不能说明代码健壮</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript性能优化（六）优化案例</title>
    <url>/2021/05/043a8592aa08/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="变量局部化"><a href="#变量局部化" class="headerlink" title="变量局部化"></a>变量局部化</h1><p>定义变量时尽可能将变量定义在局部作用域内，这样可以提高代码的执行效率（减少了数据访问时需要查找的路径）</p>
<p><img src="https://pic.imgdb.cn/item/60ebeb1e5132923bf8079504.png"></p>
<p>从<code>JSBench</code>测试结果中可以看到对比结果差距还是挺大的</p>
<p><img src="https://pic.imgdb.cn/item/60e7b1665132923bf813f288.png"></p>
<h1 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h1><p>对于需要多次使用的数据进行提前保存，后续进行使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;skip&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;skip&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 缓存数据：对于需要多次使用的数据进行提前保存，后续进行使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> oBox = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;skip&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 假设在当前的函数体当中需要对 className 的值进行多次使用，那么我们就可以将它提前缓存起来</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 非缓存</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">hasClassName</span>(<span class="params">ele, cls</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ele.<span class="property">className</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> ele.<span class="property">className</span> == cls</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasClassName</span>(oBox, <span class="string">&#x27;skip&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// 缓存</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">function</span> <span class="title function_">hasClassName</span>(<span class="params">ele, cls</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> clsName = ele.<span class="property">className</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(clsName)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> clsName == cls</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasClassName</span>(oBox, <span class="string">&#x27;skip&#x27;</span>))</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">/*</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    01 减少声明和语句数（词法 语法）</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">    02 缓存数据（作用域链查找变快）</span></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"><span class="language-xml">  */</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="减少层级访问"><a href="#减少层级访问" class="headerlink" title="减少层级访问"></a>减少层级访问</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接访问，速度快</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;zce&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">40</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">age</span>)</span><br><span class="line"><span class="comment">// 通过函数访问，速度慢</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;zce&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">40</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getAge</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">getAge</span>())</span><br></pre></td></tr></table></figure>

<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><h2 id="为什么需要防抖和节流"><a href="#为什么需要防抖和节流" class="headerlink" title="为什么需要防抖和节流"></a>为什么需要防抖和节流</h2><ul>
<li>在一些高频率事件触发的场景下我们不希望对应的事件处理函数多次执行</li>
<li>场景<ul>
<li>滚动事件</li>
<li>输入的模糊匹配</li>
<li>轮播图切换</li>
<li>点击操作</li>
<li>….</li>
</ul>
</li>
<li>浏览器默认情况下都会有自己的监听事件间隔（<code>4~6ms</code>)，如果检测到多次事件的监听执行，那么就会造成不必要的资源浪费</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>防抖：对于高频操作，我们只希望识别一次点击，可以人为是第一次或者是最后一次</li>
<li>节流：对于高频操作，我们可以自己来设置频率，让本来会执行很多次的事件触发，按着我们定义的频率减少触发的次数</li>
</ul>
<h2 id="防抖函数实现"><a href="#防抖函数实现" class="headerlink" title="防抖函数实现"></a>防抖函数实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">	* handle 最终需要执行的事件监听</span></span><br><span class="line"><span class="comment">	* wait 事件触发之后多久开始执行</span></span><br><span class="line"><span class="comment">	* immediate 控制执行第一次还是最后一次，false 执行最后一次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myDebounce</span>(<span class="params">handle, wait, immediate</span>) &#123;</span><br><span class="line">	<span class="comment">// 参数类型判断及默认值处理</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;handle must be an function&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> wait === <span class="string">&#x27;undefined&#x27;</span>) wait = <span class="number">300</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> wait === <span class="string">&#x27;boolean&#x27;</span>) &#123;</span><br><span class="line">		immediate = wait</span><br><span class="line">		wait = <span class="number">300</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> immediate !== <span class="string">&#x27;boolean&#x27;</span>) immediate = <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 所谓的防抖效果我们想要实现的就是有一个 ”人“ 可以管理 handle 的执行次数</span></span><br><span class="line">	<span class="comment">// 如果我们想要执行最后一次，那就意味着无论我们当前点击了多少次，前面的N-1次都无用</span></span><br><span class="line">	<span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> self = <span class="variable language_">this</span>,</span><br><span class="line">			init = immediate &amp;&amp; !timer</span><br><span class="line">		<span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">		timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			timer = <span class="literal">null</span></span><br><span class="line">			!immediate ? handle.<span class="title function_">call</span>(self, ...args) : <span class="literal">null</span></span><br><span class="line">		&#125;, wait)</span><br><span class="line">		<span class="comment">// 如果当前传递进来的是 true 就表示我们需要立即执行</span></span><br><span class="line">		<span class="comment">// 如果想要实现只在第一次执行，那么可以添加上 timer 为 null 做为判断</span></span><br><span class="line">		<span class="comment">// 因为只要 timer 为 Null 就意味着没有第二次....点击</span></span><br><span class="line">		init ? handle.<span class="title function_">call</span>(self, ...args) : <span class="literal">null</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流函数实现"><a href="#节流函数实现" class="headerlink" title="节流函数实现"></a>节流函数实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">	* handle 最终需要执行的事件监听</span></span><br><span class="line"><span class="comment">	* wait 执行频率</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myThrottle</span>(<span class="params">handle, wait</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> handle !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;handle must be an function&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> wait === <span class="string">&#x27;undefined&#x27;</span>) wait = <span class="number">400</span></span><br><span class="line">	<span class="keyword">let</span> previous = <span class="number">0</span>  <span class="comment">// 定义变量记录上一次执行时的时间 </span></span><br><span class="line">	<span class="keyword">let</span> timer = <span class="literal">null</span>  <span class="comment">// 用它来管理定时器</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">		<span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">// 定义变量记录当前次执行的时刻时间点</span></span><br><span class="line">		<span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">		<span class="keyword">let</span> interval = wait - (now - previous)</span><br><span class="line">		<span class="keyword">if</span> (interval &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 此时就说明是一个非高频次操作，可以执行 handle </span></span><br><span class="line">			<span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">			timer = <span class="literal">null</span></span><br><span class="line">			handle.<span class="title function_">call</span>(self, ...args)</span><br><span class="line">			previous = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">			<span class="comment">// 当我们发现当前系统中有一个定时器了，就意味着我们不需要再开启定时器</span></span><br><span class="line">			<span class="comment">// 此时就说明这次的操作发生在了我们定义的频次时间范围内，那就不应该执行 handle</span></span><br><span class="line">			<span class="comment">// 这个时候我们就可以自定义一个定时器，让 handle 在 interval 之后去执行 </span></span><br><span class="line">			timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">clearTimeout</span>(timer) <span class="comment">// 这个操作只是将系统中的定时器清除了，但是 timer 中的值还在</span></span><br><span class="line">				timer = <span class="literal">null</span></span><br><span class="line">				handle.<span class="title function_">call</span>(self, ...args)</span><br><span class="line">				previous = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">			&#125;, interval)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.imgdb.cn/item/60e7b1675132923bf813f6d1.png"></p>
<h1 id="减少判断层级"><a href="#减少判断层级" class="headerlink" title="减少判断层级"></a>减少判断层级</h1><p><img src="https://pic.imgdb.cn/item/60ed02595132923bf870954a.png"></p>
<h1 id="减少循环体活动"><a href="#减少循环体活动" class="headerlink" title="减少循环体活动"></a>减少循环体活动</h1><p><img src="https://pic.imgdb.cn/item/60ed05615132923bf883e3cf.png"></p>
<p><img src="https://pic.imgdb.cn/item/60ed05615132923bf883e3e7.png"></p>
<h1 id="字面量与构造式"><a href="#字面量与构造式" class="headerlink" title="字面量与构造式"></a>字面量与构造式</h1><p><img src="https://pic.imgdb.cn/item/60ed072d5132923bf88ed468.png"></p>
<p><img src="https://pic.imgdb.cn/item/60ed087f5132923bf89641f6.png"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript性能优化（五）堆栈操作</title>
    <url>/2021/05/d272b270da16/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="堆栈准备"><a href="#堆栈准备" class="headerlink" title="堆栈准备"></a>堆栈准备</h1><ul>
<li><code>JS</code>执行环境</li>
<li>执行环境栈（<code>ECStack</code>，<code>execution context stack</code>）</li>
<li>执行上下文</li>
<li><code>VO(G)</code>，全局变量对象</li>
</ul>
<h1 id="原始类型堆栈处理"><a href="#原始类型堆栈处理" class="headerlink" title="原始类型堆栈处理"></a>原始类型堆栈处理</h1><p><img src="https://pic.imgdb.cn/item/60e7b15f5132923bf813db95.png"></p>
<blockquote>
<ul>
<li>基本数据类型是按值进行操作</li>
<li> 基本数据类型值是存放在栈区的</li>
<li> 无论我们当前看到的栈内存，还是后续引用数据类型会使用的堆内存都属于计算机内存</li>
<li><code>GO</code>(全局对象)</li>
</ul>
</blockquote>
<h1 id="引用类型堆栈处理"><a href="#引用类型堆栈处理" class="headerlink" title="引用类型堆栈处理"></a>引用类型堆栈处理</h1><h2 id="对象堆栈执行"><a href="#对象堆栈执行" class="headerlink" title="对象堆栈执行"></a>对象堆栈执行</h2><p><img src="https://pic.imgdb.cn/item/60e7b1605132923bf813df9b.png"></p>
<h2 id="函数堆栈执行"><a href="#函数堆栈执行" class="headerlink" title="函数堆栈执行"></a>函数堆栈执行</h2><p><img src="https://pic.imgdb.cn/item/60e7b1615132923bf813e2c5.png"></p>
<blockquote>
<ul>
<li>函数创建<ul>
<li>可以将函数名称看做是变量，存放在 <code>VO</code> 当中 ，同时它的值就是当前函数对应的内存地址</li>
<li>函数本身也是一个对象，创建时会有一个内存地址，空间内存放的就是函数体代码（字符串形式的）</li>
</ul>
</li>
<li>函数执行<ul>
<li>函数执行时会形成一个全新私有上下文，它里面有一个<code>AO</code> 用于管理这个上下文当中的变量</li>
<li>步骤：<ul>
<li>作用域链 &lt;当前执行上下文， 上级作用域所在的执行上下文&gt;</li>
<li>确定 <code>this</code></li>
<li>初始化 <code>arguments</code> （对象）</li>
<li>形参赋值：它就相当于是变量声明，然后将声明的变量放置于 <code>AO</code></li>
<li>变量提升</li>
<li>代码执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="闭包堆栈执行"><a href="#闭包堆栈执行" class="headerlink" title="闭包堆栈执行"></a>闭包堆栈执行</h1><p><img src="https://pic.imgdb.cn/item/60e7b1625132923bf813e6f9.png"></p>
<blockquote>
<ul>
<li>闭包： 是一种机制：<ul>
<li>保护：当前上下文当中的变量与其它的上下文中变量互不干扰</li>
<li>保存：当前上下文中的数据（堆内存）被当前上下文以外的上下文中的变量所引用，这个数据就保存下来了</li>
</ul>
</li>
<li>闭包：<ul>
<li>函数调用形成了一个全新的私有上下文，在函数调用之后当前上下文不被释放就是闭包（临时不被释放）</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="闭包与垃圾回收"><a href="#闭包与垃圾回收" class="headerlink" title="闭包与垃圾回收"></a>闭包与垃圾回收</h1><p><img src="https://pic.imgdb.cn/item/60e7b1645132923bf813ed5c.png"></p>
<h1 id="循环添加事件"><a href="#循环添加事件" class="headerlink" title="循环添加事件"></a>循环添加事件</h1><p><img src="https://pic.imgdb.cn/item/60e7b1655132923bf813ef8c.png"></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript性能优化（四）performance工具</title>
    <url>/2021/04/c16d95e897f5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="为什么使用Performance"><a href="#为什么使用Performance" class="headerlink" title="为什么使用Performance"></a>为什么使用<code>Performance</code></h1><ul>
<li><code>GC</code>的目的是为了实现内存空间的良性循环</li>
<li>良性循环的基石是合理使用</li>
<li>时刻关注才能确定是否合理</li>
<li><code>Performance</code>提供多种监控方式</li>
</ul>
<h1 id="Performance使用步骤"><a href="#Performance使用步骤" class="headerlink" title="Performance使用步骤"></a><code>Performance</code>使用步骤</h1><ul>
<li>打开浏览器输入目标网址</li>
<li>进入开发人员工具面板，选择性能</li>
<li>开启录制功能，访问具体界面</li>
<li>执行用户行为，一段时间后停止录制</li>
<li>分析界面中记录的内存信息</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60e69d8c5132923bf8249b8e.png"></p>
<h1 id="内存问题的外在表现"><a href="#内存问题的外在表现" class="headerlink" title="内存问题的外在表现"></a>内存问题的外在表现</h1><ul>
<li>页面出现延迟加载活经常性暂停</li>
<li>页面持续性出现糟糕的性能</li>
<li>页面的性能随时间延长越来越差</li>
</ul>
<h1 id="界定内存问题的标准"><a href="#界定内存问题的标准" class="headerlink" title="界定内存问题的标准"></a>界定内存问题的标准</h1><ul>
<li>内存泄漏：内存使用持续升高</li>
<li>内存膨胀：在多数设备上都存在性能问题</li>
<li>频繁垃圾回收：通过内存变化图进行分析</li>
</ul>
<h1 id="监控内存的几种方式"><a href="#监控内存的几种方式" class="headerlink" title="监控内存的几种方式"></a>监控内存的几种方式</h1><ul>
<li>浏览器任务管理器<ul>
<li>内存一列指的是原生内存，当前界面<code>DOM</code>节点所占据的内存大小</li>
<li><code>JavaScript</code>内存一列指的是<code>JS</code>的堆，括号内的值指的是界面当中所有可达对象正在使用的内存大小</li>
<li>任务管理器只能帮助我们查看有没有问题，并不能定位问题原因</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60e6a0655132923bf83ac7f7.png"></p>
<ul>
<li><code>Timeline</code>时序图记录</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60e6a3de5132923bf8582c41.png"></p>
<ul>
<li>堆快照查找分离<code>DOM</code><ul>
<li>什么是分离<code>DOM</code><ul>
<li>界面元素存活再<code>DOM</code>树上</li>
<li>垃圾对象时的<code>DOM</code>节点</li>
<li>分离状态的<code>DOM</code>节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60e6a5be5132923bf866cbe7.png"></p>
<ul>
<li>判断是否存在频繁的垃圾回收<ul>
<li>为什么确定频繁垃圾回收<ul>
<li><code>GC</code>工作时应用程序是停止的</li>
<li>频繁且过长的<code>GC</code>会导致应用假死</li>
<li>用户使用中感知应用卡顿</li>
</ul>
</li>
<li>如何判断<ul>
<li><code>Timeline</code>中频繁的上升下降</li>
<li>任务管理器中的数据频繁的增大和减小</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript性能优化（三）V8引擎的垃圾回收</title>
    <url>/2021/04/205552df41f0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="认识V8"><a href="#认识V8" class="headerlink" title="认识V8"></a>认识<code>V8</code></h1><ul>
<li><code>V8</code>是一款主流的<code>JavaScript</code>执行引擎</li>
<li><code>V8</code>采用即时编译</li>
<li><code>V8</code>内存设置上限</li>
</ul>
<h1 id="V8引擎的工作流程"><a href="#V8引擎的工作流程" class="headerlink" title="V8引擎的工作流程"></a><code>V8</code>引擎的工作流程</h1><p><img src="https://pic.imgdb.cn/item/60e6a8345132923bf8796b27.png"></p>
<ul>
<li><code>Scanner</code>是<code>V8</code>提供的扫描器</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60e6a9405132923bf880fac4.png"></p>
<ul>
<li><code>Parser</code>是<code>V8</code>提供的解析器<ul>
<li><code>PreParser</code>预解析<ul>
<li>跳过未被使用的代码</li>
<li>不生成<code>AST</code>，创建无变量引用和声明的<code>scopes</code></li>
<li>依据规范抛出特定错误</li>
<li>解析速度更快</li>
</ul>
</li>
<li><code>Parser</code>全量解析<ul>
<li>解析被使用的代码</li>
<li>生成<code>AST</code></li>
<li>构建具体的<code>scopes</code>信息，变量引用、声明等</li>
<li>抛出所有语法错误</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明时未调用，因此会被认为时不被执行的代码，进行预解析</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明时未调用，因此会被认为时不被执行的代码，进行预解析</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 函数立即执行，只进行一次全量解析</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 执行 foo，那么需要重新对 foo 函数进行全量解析，此时 foo 函数被解析了两次</span></span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Ignition</code>是<code>V8</code>提供的解释器</li>
<li><code>TurboFan</code>是<code>V8</code>提供的编译器</li>
</ul>
<h1 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a><code>V8</code>垃圾回收策略</h1><ul>
<li><code>V8</code>基于分代回收的思想实现垃圾回收</li>
<li><code>V8</code>内存分为新生代、老年代</li>
<li><code>V8</code>针对不同对象采用不同算法</li>
</ul>
<h1 id="V8中常用的GC算法"><a href="#V8中常用的GC算法" class="headerlink" title="V8中常用的GC算法"></a><code>V8</code>中常用的<code>GC</code>算法</h1><ul>
<li>分代回收</li>
<li>空间复制</li>
<li>标记清除</li>
<li>标记整理</li>
<li>标记增量</li>
</ul>
<h1 id="V8内存分配"><a href="#V8内存分配" class="headerlink" title="V8内存分配"></a><code>V8</code>内存分配</h1><ul>
<li><code>V8</code>内存空间一份为二</li>
<li>小空间用于存储新生代对象（64位操作系统<code>32M</code>，32位操作系统<code>16M</code>），新生代指的是存活时间较短的对象</li>
<li>大空间用于存储老年代对象（64位操作系统<code>1.4G</code>，32位操作系统<code>700M</code>），老年代指的是存活时间较长的对象</li>
</ul>
<h1 id="新生代对象回收"><a href="#新生代对象回收" class="headerlink" title="新生代对象回收"></a>新生代对象回收</h1><ul>
<li>回收过程采用复制算法+标记整理</li>
<li>新生代内存区分为两个等大小的空间</li>
<li>使用空间为<code>From</code>，空闲空间为<code>To</code></li>
<li>活动对象存储于<code>From</code>空间</li>
<li>标记整理后将活动对象拷贝至<code>To</code></li>
<li><code>From</code>与<code>To</code>交换空间完成释放</li>
</ul>
<blockquote>
<p>细节说明</p>
<ul>
<li>拷贝过程中可能出现晋升</li>
<li>晋升就是将新生代对象移动到老年代</li>
<li>一轮<code>GC</code>之后还存活的新生代需要晋升</li>
<li><code>To</code>空间的使用率超过25%</li>
</ul>
</blockquote>
<h1 id="老年代对象回收"><a href="#老年代对象回收" class="headerlink" title="老年代对象回收"></a>老年代对象回收</h1><ul>
<li>主要采用标记清除、标记整理、增量标记算法</li>
<li>首先使用标记清除完成垃圾空间的回收</li>
<li>采用标记整理进行空间优化</li>
<li>采用增量标记进行效率优化</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60e695d15132923bf8e89ea0.png"></p>
<h1 id="新生代和老年代细节对比"><a href="#新生代和老年代细节对比" class="headerlink" title="新生代和老年代细节对比"></a>新生代和老年代细节对比</h1><ul>
<li>新生代区域垃圾回收使用空间换时间</li>
<li>老年代区域垃圾回收不适合复制算法</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript性能优化（二）垃圾回收与常见GC算法</title>
    <url>/2021/04/9164d4cab658/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JavaScript中的垃圾"><a href="#JavaScript中的垃圾" class="headerlink" title="JavaScript中的垃圾"></a><code>JavaScript</code>中的垃圾</h1><ul>
<li><code>JavaScript</code>中的内存管理是自动的</li>
<li>对象不在引用时是垃圾</li>
<li>对象不能存根上访问到时是垃圾</li>
</ul>
<h1 id="JavaScript中的可达对象"><a href="#JavaScript中的可达对象" class="headerlink" title="JavaScript中的可达对象"></a><code>JavaScript</code>中的可达对象</h1><ul>
<li>可以访问到的对象就是可达对象（引用、作用域链）</li>
<li>可达的标准就是从根出发是否能够被找到</li>
<li><code>JavaScript</code>中的根就可以理解为是全局变量对象</li>
</ul>
<h1 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a><code>GC</code>算法</h1><h2 id="GC定义与作用"><a href="#GC定义与作用" class="headerlink" title="GC定义与作用"></a><code>GC</code>定义与作用</h2><ul>
<li><p><code>GC</code>就是垃圾回收机制的简写</p>
</li>
<li><p><code>GC</code>可以找到内存中的垃圾、并释放和回收空间</p>
</li>
</ul>
<h2 id="GC里的垃圾是什么"><a href="#GC里的垃圾是什么" class="headerlink" title="GC里的垃圾是什么"></a><code>GC</code>里的垃圾是什么</h2><ul>
<li>程序中不再需要使用的对象</li>
<li>程序中不能再访问到的对象</li>
</ul>
<h2 id="GC算法是什么"><a href="#GC算法是什么" class="headerlink" title="GC算法是什么"></a><code>GC</code>算法是什么</h2><ul>
<li><code>GC</code>是一种机制，垃圾回收器完成具体的工作</li>
<li>工作的内容就是查找垃圾释放空间、回收空间</li>
<li>算法就是工作时查找和回收所遵循的规则</li>
</ul>
<h1 id="常见的GC算法"><a href="#常见的GC算法" class="headerlink" title="常见的GC算法"></a>常见的<code>GC</code>算法</h1><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><ul>
<li>核心思想：设置引用数，判断当前引用数是否为0</li>
<li>引用计数器</li>
<li>引用关系改变时修改引用数字</li>
<li>引用数字为0时立即回收</li>
</ul>
<blockquote>
<p>优点</p>
<ul>
<li>发现垃圾时立即回收</li>
<li>最大程度减少程序暂停</li>
</ul>
<p>缺点</p>
<ul>
<li>无法回收循环引用的对象</li>
<li>资源消耗较大，时间开销大</li>
</ul>
</blockquote>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><ul>
<li>核心思想：分标记和清除两个阶段完成</li>
<li>遍历所有对象找标记活动对象</li>
<li>遍历所有对象清除没有标记对象</li>
<li>回收相应的空间</li>
</ul>
<blockquote>
<p>优点</p>
<ul>
<li>可以回收循环引用的对象</li>
</ul>
<p>缺点</p>
<ul>
<li>回收后的空闲链表地址不连续，容易造成碎片化空间，浪费空间</li>
<li>不会立即回收垃圾对象</li>
</ul>
</blockquote>
<h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><ul>
<li>标记整理可以看做时标记清除的增强</li>
<li>标记阶段的操作和标记清除一致</li>
<li>清除阶段会先执行整理，移动对象位置</li>
</ul>
<blockquote>
<p>优点</p>
<ul>
<li>减少碎片化空间</li>
</ul>
<p>缺点</p>
<ul>
<li>不会立即回收垃圾对象</li>
<li>移动对象位置，回收效率慢</li>
</ul>
</blockquote>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><ul>
<li><code>V8</code>引擎垃圾回收机制</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript性能优化（一）内存管理</title>
    <url>/2021/04/dead12376500/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="内存为什么需要管理"><a href="#内存为什么需要管理" class="headerlink" title="内存为什么需要管理"></a>内存为什么需要管理</h1><p>我们在代码中经常会有意无意的造成内存泄漏如下图所示，该代码在语法上没有任何问题，但是通过性能检测工具对脚本内存进行检测可以发现，内存持续升高，并没有回落，当此类问题代码多次出现，就可能给程序带来许多意想不到的<code>bug</code>。所以我们有必要了解内存管理机制，从而避免编写出内存问题代码。</p>
<p><img src="https://pic.imgdb.cn/item/60e65fe45132923bf89e0180.png"></p>
<h1 id="什么是内存管理"><a href="#什么是内存管理" class="headerlink" title="什么是内存管理"></a>什么是内存管理</h1><ul>
<li>内存：由可读写单元组成，表示一篇可操作的空间</li>
<li>管理：人为的去操作一片空间的申请、使用和释放</li>
<li>内存管理：开发者主动申请空间、使用空间、释放空间</li>
<li>管理流程：申请—使用—释放</li>
</ul>
<h1 id="JavaScript中的内存管理"><a href="#JavaScript中的内存管理" class="headerlink" title="JavaScript中的内存管理"></a><code>JavaScript</code>中的内存管理</h1><ul>
<li>申请内存空间</li>
<li>使用内存空间</li>
<li>释放内存空间</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2021/04/4aaef74deb87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ul>
<li><code>TypeScript</code>可以编译出纯净、简洁的<code>JavaScript</code>代码，并且可以运行在任何浏览器上、<code>Node.js</code>环境中和任何支持<code>ECMAScript3</code>（或更高版本）的<code>JavaScript</code>引擎中</li>
<li>类型允许<code>JavaScript</code>开发者在开发<code>JavaScript</code>应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构</li>
<li><code>TypeScript</code>提供最新的和不断发展的<code>JavaScript</code>特性，包括那些来自2015年的<code>ECMAScript</code>和未来的提案中的特性</li>
</ul>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><code>ts</code> 可以安装到全局，也可以在项目中安装</p>
<h1 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h1><ul>
<li>首先运行 <code>npm install -g typescript</code> 全局安装<code>ts</code></li>
<li>然后编写 <code>.ts</code> 后缀名的文件</li>
<li>在终端运行 <code>tsc</code> 文件名<code>.ts</code> 就可以自动生成编译好的<code>js</code>文件</li>
</ul>
<h1 id="局部安装"><a href="#局部安装" class="headerlink" title="局部安装"></a>局部安装</h1><p>使用<code>yarn</code></p>
<ul>
<li><code>yarn init --yes</code> 创建项目</li>
<li><code>yarn add typescript --dev</code> 安装 <code>TypeScript</code> 模块</li>
<li><code>yarn tsc 文件名.ts</code> 运行编译</li>
<li>推荐使用<code>yarn</code> 运行<code>tsc</code>指令不需要修改<code>package.json</code></li>
</ul>
<p>使用<code>npm</code></p>
<ul>
<li>在项目目录运行 <code>npm i typescript -D</code></li>
<li>在<code>package.json</code>文件的<code>script</code>中添加命令设置 <code>&quot;tsc&quot;:&quot;tsc&quot;</code></li>
<li>编写<code>.ts</code>后缀名的文件 在终端运行 <code>npm run tsc 文件名.ts</code></li>
</ul>
<h1 id="ts配置文件"><a href="#ts配置文件" class="headerlink" title="ts配置文件"></a>ts配置文件</h1><p>运行 <code>yarn tsc --init</code> 创建<code>tsconfig.json</code> 配置文件。</p>
<p>我们来了解几个简单的配置项含义</p>
<ul>
<li><code>&quot;target&quot;: &quot;ES5&quot;</code> <code>ts</code>编译成<code>ECMAScript</code>对应版本的<code>js</code></li>
<li><code>&quot;module&quot;: &quot;commonjs&quot;</code> <code>ts</code>编译模块化导入的标准</li>
<li><code>&quot;outDir&quot;: &quot;dist&quot;</code> 编译好的<code>js</code>文件输出到<code>dist</code>目录</li>
<li><code>&quot;rootDir&quot;: &quot;src&quot;</code> 要编译的文件夹，会把文件夹内的<code>ts</code>文件都进行编译</li>
<li><code>&quot;sourceMap&quot;: true</code> 开启源代码映射，方便调试</li>
<li><code>&quot;strict&quot;: true</code> 严格检查模式</li>
</ul>
<h1 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h1><p><code>ts</code> 中的原始数据类型与<code>flow</code>类似 ，但是根据<code>strict</code>设置不同，也有一些差异。</p>
<p>这里我们需要解决一个标准库的问题，因为如果在编码中使用了非当前标准库的语法那么<code>ts</code>就会报错，我们可以通过修改<code>ts</code>配置文件中的<code>lib</code> 属性来添加标准库<br>标准库就是内置对象所对应的声明，我们在代码中使用内置对象就要使用对应的标准库，否则<code>typeScript</code>就找不到对应的类型，就会报错</p>
<h1 id="不同文件的变量重名问题"><a href="#不同文件的变量重名问题" class="headerlink" title="不同文件的变量重名问题"></a>不同文件的变量重名问题</h1><p>在同一目录下的不同<code>ts</code>文件中，如果声明的变量重名了，会报错重名。这是作用域的问题，因为这些变量都是声明在全局上的，所以会提示错误。</p>
<ul>
<li>方案一, 使用自调用函数提供封闭作用域</li>
<li>方案二, 在代码中提供 <code>export &#123;&#125;</code> 将其中所有成员作为模块成员</li>
</ul>
<h1 id="object-类型"><a href="#object-类型" class="headerlink" title="object 类型"></a><code>object</code> 类型</h1><p><code>object</code> 类型，并不是限制只能传入对象，而是指所有非原始数据类型之外的类型，可以是函数也可以使数组也可以是对象</p>
<h1 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h1><ul>
<li> <code>const arr1: Array&lt;number&gt; = [2,3,4]</code></li>
<li> <code>const arr2: number[] = [1, 2, 3]</code></li>
</ul>
<p>假设我们定义一个函数 接收不固定数量的参数，要求这些参数都是数字类型。如果是在<code>js</code>中我们可能需要添加参数类型的判断，而如果使用<code>ts</code> 就会简单很多</p>
<h1 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h1><p>元组就是明确元素数量以及每个元素类型的数组</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul>
<li>枚举可以给几个数值取上容易理解的名字</li>
<li>一个枚举中只会存在几个固定的值，不会出现超出范围的可能性</li>
<li><code>js</code>中可以使用对象去模拟枚举，而ts中有专门的<code>enum</code>类型    </li>
</ul>
<h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><ul>
<li>函数声明，设置可选参数可以使用 <code>a?</code> 或者 函数默认值 <code>b: number=10</code>，不确定数量的可以用<code>ES6</code>的<code>…args</code></li>
<li>函数表达式</li>
</ul>
<h1 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h1><p>使用 <code>any</code> 接收任意类型参数，依然是动态类型。不会有类型检查，依然有类型安全问题</p>
<h1 id="隐式类型推断"><a href="#隐式类型推断" class="headerlink" title="隐式类型推断"></a>隐式类型推断</h1><p>如果我们没有给一个变量添加类型注解，那么<code>ts</code>会根据这个变量的使用，去推断它的类型。建议还是给每一个都添加类型注解</p>
<h1 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h1><p>在某些情况下 <code>TS</code> 无法在编译过程中 知道一个运算的值是什么类型，从而导致后续的代码编译时报错<br>那么此时我们ts使用断言 <code>as</code> 来确定类型</p>
<h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 <code>interface</code></h1><p>接口可以用来约定一个对象的结构，我们使用一个接口，那么就要遵守这个接口全部的约定</p>
<ul>
<li>可选成员 给属性后面添加 <code>?</code> 表示该属性可选</li>
<li>只读成员 给属性名前面添加 <code>readonly</code> 该属性在初始化之后就不能再被修改了</li>
<li>动态属性</li>
</ul>
<h1 id="TypeScript-中类的基本使用"><a href="#TypeScript-中类的基本使用" class="headerlink" title="TypeScript 中类的基本使用"></a><code>TypeScript</code> 中类的基本使用</h1><p><code>ts</code> 中类的使用与<code>js</code>中<code>ES6</code>中新增的<code>class</code> 差不多，略有差异。 主要体现在类属性定义上，<code>ts</code>的<code>class</code>中的类属性在使用之前，必须要先声明。</p>
<h1 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h1><ul>
<li><code>public</code> 公开的，在属性或者方法前进行修饰，表示可以被外部访问，这也是默认的修饰符</li>
<li><code>private</code> 私有的，只能在类的内部访问，实例无法在外部调用</li>
<li><code>protected</code> 保护的，可以理解为受限的，只能在类内部或者子类中进行访问</li>
</ul>
<p>如果<code>constructor</code>添加了<code>private</code> 那么是不能直接在类外部<code>new</code>出实例的，可以在静态方法中来调用<code>new</code>创建实例，并<code>return</code><br>添加只读属性，<code>class</code>中添加只读属性跟接口中类似都是通过<code>readonly</code>来实现，具体语法就是给在属性修饰符之后属性名之前 添加<code>readonly</code> <code>public</code> <code>readonly</code> <code>name: string</code></p>
<h1 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h1><p><code>ts</code>中提到的接口，跟我们前端开发中经常提到的接口请求的接口，有一定差别。</p>
<p>很多只接触过<code>JavaScript</code>的朋友对于接口的理解，可能是我请求这个接口地址就能获得对应的数据 ，而我们<code>ts</code>这里提到的接口，是强类型语言中的一个概念，主要是用来实现多态。</p>
<p>而多态在<code>js</code>中并不需要特地去实现，因为<code>js</code>本身就是弱类型的，它天生就有多态的能力。</p>
<p><code>ts</code>中的接口是比类更加抽象的一种概念，可以理解为是多个类它们之间共性的一种约定，类实现(<code>implements</code>)了某个接口 那么它的内部就必须拥有这种接口的能力。</p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象类更像是接口跟父类的结合，既可以在其中定义具体的方法，也可以定义抽象方法交给子类去自由实现<br>抽象类是用来继承的，不能被实例化。抽象类里可以有成员变量，接口中没有。<br>定义一个抽象类，使用<code>abstract</code> <code>class</code>两关键字定义</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>不确定函数的参数类型或者返回值类型可以使用泛型。</p>
<p><code>T</code> 代表 <code>Type</code>，在定义泛型时通常用作第一个类型变量名称。但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p>
<p><code>K</code>（<code>Key</code>）：表示对象中的键类型；<br><code>V</code>（<code>Value</code>）：表示对象中的值类型；<br><code>E</code>（<code>Element</code>）：表示元素类型</p>
<h1 id="类型声明"><a href="#类型声明" class="headerlink" title="类型声明"></a>类型声明</h1><p>在开发过程中不可避免要引用其他第三方的 <code>JavaScript</code> 的库，虽然通过直接引用可以调用库的类和方法，但是却无法使用 <code>TypeScript</code> 诸如类型检查等特性功能。</p>
<p>一般的第三方<code>js</code>插件在<code>npm</code>上都有对应的声明文件，比如<code>lodash</code>的声明文件就可以在<code>npm</code>上下载 <code>npm i @types/lodash</code> 这样使用的时候导入.</p>
<p>以<code>.d.ts</code>结尾的就是声明文件，这样就不会再报找不到模块声明了</p>
<p>如果第三方插件没有对应的声明文件我们可以自己去为它的成员添加类型声明从而添加类型检查</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>Flow</title>
    <url>/2021/04/199ad6f4755e/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><code>Flow</code>是 <code>JavaScript</code> 的静态类型检查器，<code>Flow</code> 发布在 <code>GitHub</code> 上，在 <code>Facebook</code> 内部大量使用，并且是开源的。<br><code>Flow</code>使用类型注解，来给参数添加类型控制。在生产环境中可以通过编译工具，去掉类型注解，我们可以在自己需要的地方添加类型注解</p>
<h1 id="在项目中使用flow"><a href="#在项目中使用flow" class="headerlink" title="在项目中使用flow"></a>在项目中使用<code>flow</code></h1><ul>
<li>安装<code>flow-bin</code> <code>npm i flow-bin -D</code></li>
<li>在要被检查的文件顶部添加 <code>// @flow</code> 标记文件要被<code>flow</code>进行检查</li>
<li>在<code>package.json</code>中的<code>script</code>中添加命令 <code>&quot;flow&quot;: &quot;flow&quot;</code></li>
<li>运行<code>npm run flow init</code>，创建<code>flowconfig</code>文件</li>
<li>运行命令 <code>npm run flow</code></li>
</ul>
<h1 id="移除类型注解"><a href="#移除类型注解" class="headerlink" title="移除类型注解"></a>移除类型注解</h1><ul>
<li>方案一:自动移除类型注解，官方提供的模块：<ul>
<li>运行<code>npm i flow-remove-types --dev</code>安装<code>flow-remove-types</code>模块</li>
<li>在<code>package.json</code>的<code>script</code> 中添加命令 <code>&quot;flow-remove-types&quot;:&quot;flow-remove-types . -d dist&quot;</code></li>
<li>运行 <code>npm run flow-remove-types</code> 生成dist目录，其中的文件就是编译移除类型注解后的。</li>
</ul>
</li>
<li>方案二:<code>babel</code><ul>
<li>安装<code>babel</code> <code>npm i @babel/core @babel/cli @babel/preset-flow -D</code></li>
<li>创建<code>.babelrc</code>文件，添加 <code> &#123;&quot;presets&quot;:[&quot;@babel/preset-flow&quot;]&#125;</code></li>
<li>在<code>package.json</code>的<code>script</code> 中添加 <code>&quot;build&quot;:&quot;babel . -d dist&quot;</code></li>
<li>运行 <code>npm run build</code></li>
</ul>
</li>
</ul>
<p>可以安装<code>VSCode</code>插件<code>Flow Language Support</code>来实时监听类型错误，但是需要保存之后才能看到错误的波浪线</p>
<h1 id="Flow-基本使用"><a href="#Flow-基本使用" class="headerlink" title="Flow 基本使用"></a><code>Flow</code> 基本使用</h1><ul>
<li><code>flow</code> 可以为我们的代码，进行类型推断，如下图，函数参数没有添加注解但是flow可以根据运算符推断参数类型，并且给出错误提示，但是还是建议给参数都加上类型注解</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60e522515132923bf8cd8445.png"></p>
<ul>
<li><p>类型注解，类型注解不仅可以给函数参数标记类型还可以用来标记变量的类型和函数返回值的类型</p>
</li>
<li><p>原始类型 目前原始类型共有6种，<code>number</code>、<code>boolean</code>、<code>string</code>、<code>null</code>、<code>undefined</code>、<code>symbol</code>，这里主要的是 <code>undefined</code> 是需要用<code>void</code>进行表示</p>
</li>
<li><p>结构类型</p>
<ul>
<li>数组类型</li>
<li>对象类型</li>
<li>函数类型<ul>
<li>特殊类型<ul>
<li>字面量类型 <code>const a: &#39;foo&#39; = &#39;foo&#39;</code> <code>a</code>的值只能是<code>foo</code>字符串<ul>
<li>或类型 <code>const type: &#39;success&#39; | &#39;warning&#39; | &#39;danger&#39; = &#39;success&#39;</code> <code>type</code>的值只能是三者之一</li>
<li>声明类型, 通过<code>type</code>声明一个类型别名</li>
<li><code>Maybe</code>类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>Mixed</code>与<code>any</code><ul>
<li>两者都表示任意类型，但是<code>Mixed</code> 还是强类型，需要添加 <code>typeof</code> 判断类型</li>
<li>而<code>any</code> 就是随便使用类似于<code>js</code>原始的类型特性</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>类型系统基础概念</title>
    <url>/2021/04/b26bcb297384/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="强类型与弱类型"><a href="#强类型与弱类型" class="headerlink" title="强类型与弱类型"></a>强类型与弱类型</h1><p>从类型安全角度区分类型。</p>
<ul>
<li>强类型从语言层面限制函数的实参类型必须与形参相同</li>
<li>弱类型在语言层面不会限制实参的类型</li>
<li>强类型语言中不允许有任意的隐式类型转换</li>
<li>弱类型语言则允许任务的数据隐式类型转换</li>
<li>变量类型允许随时改变的特点，不是强弱类型的差异</li>
</ul>
<h1 id="静态类型与动态类型"><a href="#静态类型与动态类型" class="headerlink" title="静态类型与动态类型"></a>静态类型与动态类型</h1><p>从类型检查角度区分</p>
<ul>
<li>静态类型:一个变量声明时它的类型就是明确的，声明过后，类型就不能修改</li>
<li>动态类型:运行阶段才能够明确变量类型,而且变量的类型随时可以改变</li>
</ul>
<h1 id="JavaScript-自有类型系统问题"><a href="#JavaScript-自有类型系统问题" class="headerlink" title="JavaScript 自有类型系统问题"></a><code>JavaScript</code> 自有类型系统问题</h1><p><code>JavaScript</code> 既是弱类型又是动态类型，代码灵活多变，但同样也带了缺失类型可靠性的问题<br><code>JavaScript</code> 是脚本语言，没有编译环节直接执行，也就没有编译环节去检查类型，而静态语言要先经过编译再执行。<br>而在现如今 <code>JavaScript</code> 大规模使用，就会暴露一些弱类型，动态类型的问题</p>
<ul>
<li>异常需要等到运行时才能发现</li>
<li>函数功能可能发生改变</li>
<li>对象索引器的错误用法</li>
</ul>
<p>相比于弱类型语言，强类型语言有以下的优势：</p>
<ul>
<li>强类型代码错误更早暴露</li>
<li>强类型代码更智能，编码更准确（编辑器可以更准确的智能提示具体类型）</li>
<li>重构更方便（比如，在修改某些复用对象的属性名时，可以更清晰的提示所有需要修改的位置）</li>
<li>减少不必要的类型判断</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>ECMAScript新特性(二)ES6+</title>
    <url>/2021/04/f9d54b037621/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="ES2016"><a href="#ES2016" class="headerlink" title="ES2016"></a><code>ES2016</code></h1><h2 id="数组扩展方法"><a href="#数组扩展方法" class="headerlink" title="数组扩展方法"></a>数组扩展方法</h2><ul>
<li><code>includes()</code>判断数组是否包含某一个元素</li>
</ul>
<h2 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Math.pow(2, 10)</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">10</span> <span class="comment">// 2的10次方</span></span><br></pre></td></tr></table></figure>

<h1 id="ES2017"><a href="#ES2017" class="headerlink" title="ES2017"></a><code>ES2017</code></h1><h2 id="对象扩展方法"><a href="#对象扩展方法" class="headerlink" title="对象扩展方法"></a>对象扩展方法</h2><ul>
<li><p><code>Object.values()</code>对象中所有值组成的数组</p>
</li>
<li><p><code>Object.entries()</code>对象中所有键值对组成的数组</p>
</li>
<li><p><code>Object.getOwnPropertyDescriptors()</code>获取对象中属性的详细描述信息</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Lei&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Wang&#x27;</span>,</span><br><span class="line">  get fullName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(p1.fullName)</span></span><br><span class="line"><span class="comment">// const p2 = Object.assign(&#123;&#125;, p1)</span></span><br><span class="line"><span class="comment">// p2.firstName = &#x27;zce&#x27;</span></span><br><span class="line"><span class="comment">// console.log(p2)</span></span><br><span class="line"><span class="keyword">const</span> descriptors = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(p1)</span><br><span class="line"><span class="comment">// console.log(descriptors)</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, descriptors)</span><br><span class="line">p2.<span class="property">firstName</span> = <span class="string">&#x27;zce&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">fullName</span>)</span><br></pre></td></tr></table></figure>

<h2 id="字符串的扩展方法"><a href="#字符串的扩展方法" class="headerlink" title="字符串的扩展方法"></a>字符串的扩展方法</h2><ul>
<li><code>String.prototype.padStart()</code>用给定的字符串填充目标字符串的开始位置，直到该字符串达到指定长度</li>
<li><code>String.prototype.padEnd()</code>用给定的字符串填充目标字符串的结束位置，直到该字符串达到指定长度</li>
</ul>
<h2 id="在函数参数中添加尾逗号"><a href="#在函数参数中添加尾逗号" class="headerlink" title="在函数参数中添加尾逗号"></a>在函数参数中添加尾逗号</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (</span><br><span class="line">  bar,</span><br><span class="line">  baz,</span><br><span class="line">) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a><code>Async/Await</code></h2><ul>
<li><p><code>Async</code> 自动将常规函数转换成 <code>Promise</code>，返回值一个 <code>Promise</code> 对象</p>
</li>
<li><p><code>Await</code> 放置在 <code>Promise</code> 调用之前，强制后面的代码等待，直到 <code>Promise</code> 对象 <code>resolve</code>，得到 <code>resolve</code> 的值作为 <code>await</code> 表达式的运算结果</p>
</li>
</ul>
<h1 id="ES2018"><a href="#ES2018" class="headerlink" title="ES2018"></a><code>ES2018</code></h1><h2 id="Async-Await-异步迭代"><a href="#Async-Await-异步迭代" class="headerlink" title="Async/Await 异步迭代"></a><code>Async/Await</code> 异步迭代</h2><p><code>ES2018</code>引入异步迭代器（<code>asynchronous iterators</code>），使得<code>await</code>可以和<code>for…of</code>循环一起使用，以串行的方式运行异步操作</p>
<h2 id="Promise-finally"><a href="#Promise-finally" class="headerlink" title="Promise.finally()"></a><code>Promise.finally()</code></h2><p>不管 <code>Promise</code> 对象最后状态如何，都会执行的操作</p>
<h2 id="正则表达式s-dotAll-标记"><a href="#正则表达式s-dotAll-标记" class="headerlink" title="正则表达式s(dotAll)标记"></a>正则表达式<code>s(dotAll)</code>标记</h2><p>使得<code>.</code>可以匹配任意单个字符（除了换行符）</p>
<h1 id="ES2019"><a href="#ES2019" class="headerlink" title="ES2019"></a><code>ES2019</code></h1><h2 id="字符串的扩展方法-1"><a href="#字符串的扩展方法-1" class="headerlink" title="字符串的扩展方法"></a>字符串的扩展方法</h2><ul>
<li><code>String.prototype.trimStart()</code>去除给定的字符串开始位置的空格、换行符等</li>
<li><code>String.prototype.trimEnd()</code>去除给定的字符串结束位置的空格、换行符等</li>
</ul>
<h2 id="对象的扩展方法"><a href="#对象的扩展方法" class="headerlink" title="对象的扩展方法"></a>对象的扩展方法</h2><ul>
<li><code>Object.fromEntries()</code>把一个对象转为<code>[key, value]</code>键值对的形式</li>
</ul>
<h2 id="数组的扩展方法"><a href="#数组的扩展方法" class="headerlink" title="数组的扩展方法"></a>数组的扩展方法</h2><ul>
<li><code>Array.prototype.flat()</code>多维数组拍平</li>
<li><code>Array.prototype.flatMap()</code>相当于<code>flat</code>和<code>map</code>一起组合操作</li>
</ul>
<h2 id="catch的参数改为可选"><a href="#catch的参数改为可选" class="headerlink" title="catch的参数改为可选"></a><code>catch</code>的参数改为可选</h2><p>在进行<code>try...catch</code>错误处理过程中，可以省略catch绑定的参数和括号</p>
<h2 id="Symbol-description"><a href="#Symbol-description" class="headerlink" title="Symbol.description"></a><code>Symbol.description</code></h2><p>描述属性是只读的，可用于获取符号对象的描述，更好了解它的作用</p>
<h1 id="ES2020"><a href="#ES2020" class="headerlink" title="ES2020"></a><code>ES2020</code></h1><h2 id="可选链运算符"><a href="#可选链运算符" class="headerlink" title="可选链运算符?."></a>可选链运算符<code>?.</code></h2><p>允许读取位于连接对象链深处的属性值,而不必明确验证链中的每个引用是否有效</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nestedProp = obj.<span class="property">first</span> &amp;&amp; obj.<span class="property">first</span>.<span class="property">second</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> nestedProp = obj.<span class="property">first</span>?.<span class="property">second</span>;</span><br><span class="line"><span class="comment">// js会在尝试访问obj.first.second之前隐式的检查并确定obj.first既不是null也不是undefined。如果obj.first是null或者undefined,表达式将会短路计算直接返回undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符??"></a>空值合并运算符<code>??</code></h2><p>可以在使用可选链时设置一个默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (option) &#123;</span><br><span class="line">  <span class="comment">// 只有 size = null 或者 undefined</span></span><br><span class="line">  option.<span class="property">size</span> = option.<span class="property">size</span> ?? <span class="number">100</span></span><br><span class="line">  <span class="keyword">const</span> mode = option.<span class="property">mode</span> || <span class="string">&#x27;hash&#x27;</span> </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(option)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(&#123; <span class="attr">size</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="字符串的扩展方法-2"><a href="#字符串的扩展方法-2" class="headerlink" title="字符串的扩展方法"></a>字符串的扩展方法</h2><ul>
<li><code>String.prototype.matchAll()</code>返回一个正则表达式在当前字符串中所有的匹配</li>
</ul>
<h2 id="import"><a href="#import" class="headerlink" title="import()"></a><code>import()</code></h2><p>一种使用动态说明符异步导入模块的语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">import</span>(<span class="string">`./home.js`</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">&#123;export1, export2&#125;</span>)=&gt;</span> </span><br><span class="line">    <span class="comment">// 加载成功的回调</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 加载失败的回调</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a><code>BigInt</code></h2><p>一个用于处理任意精度整数的新数字基元</p>
<h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled()"></a><code>Promise.allSettled()</code></h2><p>接受一组 <code>Promise</code> 实例作为参数，包装成一个新的 <code>Promise</code> 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束，一旦结束，状态总是  <code>fulfilled</code>，不会变成<code>rejected</code>。状态变成<code>fulfilled</code>后，<code>Promise</code> 的监听函数接收到的参数是一个数组，每个成员对应一个传入<code>Promise.allSettled()</code>的 <code>Promise</code> 实例</p>
<h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a><code>globalThis</code></h2><p>一种在不同环境中获取顶层对象的通用方式</p>
<h2 id="import-meta"><a href="#import-meta" class="headerlink" title="import.meta"></a><code>import.meta</code></h2><p>给<code>JavaScript</code>模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的<code>URL</code></p>
<h1 id="ES2021"><a href="#ES2021" class="headerlink" title="ES2021"></a><code>ES2021</code></h1><h2 id="字符串的扩展方法-3"><a href="#字符串的扩展方法-3" class="headerlink" title="字符串的扩展方法"></a>字符串的扩展方法</h2><ul>
<li><code>String.prototype.replaceAll()</code>全部替换</li>
</ul>
<h2 id="Promise-any"><a href="#Promise-any" class="headerlink" title="Promise.any()"></a><code>Promise.any()</code></h2><p>只要其中的一个 <code>Promise</code> 成功，就返回那个已经成功的 <code>Promise</code>，如果可迭代对象中没有一个 <code>Promise</code> 成功（即所有的 <code>Promise</code> 都失败/拒绝），就返回一个失败的 <code>Promise</code>和 <code>AggregateError</code> 类型的实例，它是 <code>Error</code> 的一个子类，用于把单一的错误集合在一起</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>ECMAScript新特性(一)ES6</title>
    <url>/2021/04/ac4a54750366/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>大致可分为四类</p>
<ul>
<li>解决原有语法上的⼀些问题或者不足</li>
<li>对原有语法进⾏增强</li>
<li>全新的对象、全新的⽅法、全新的功能</li>
<li>全新的数据类型和数据结构</li>
</ul>
<h1 id="let与块级作用域"><a href="#let与块级作用域" class="headerlink" title="let与块级作用域"></a><code>let</code>与块级作用域</h1><ul>
<li><p>作用域: 指某个成员能够起作用的范围</p>
</li>
<li><p><code>ES2015</code>之前只有两种作用域：全局作用域和函数作用域，<code>ES2015</code>新增了块级作用域(代码中用一对花括号<code>&#123;&#125;</code>包裹起来的范围)，同时新增<code>let</code>关键字声明变量，在块级作用域内使用<code>let</code>声明的变量只会在当前的块级作用域内访问</p>
</li>
<li><p><code>let</code>存在暂时性死区(声明之前不可用)</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bar) <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> bar = <span class="string">&#x27;132&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo) <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;foo&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">let</span> foo = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo) <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo) <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<p><em><code>注：从以上这个例子可以看出</code></em></p>
<p><em><code>1.let声明的成员只会在所声明的块中生效，外部无法访问</code></em></p>
<p><em><code>2.let存在暂时性死区，声明之前不可用，会抛出异常，但是从异常信息中我们可以了解到此时并非是foo is not defined，说明let与var都存在变量提升，但var对变量进行了初始化undefined的操作，使得我们在var定义变量之前也能够访问该变量，而let并没有对变量进行初始化，所以导致访问变量时抛出异常信息</code></em></p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h1><ul>
<li>在<code>let</code>基础上多了只读的特性，与<code>let</code>用法基本一致，区别在于<code>const</code>定义的通常是常量，即声明过后的变量不允许重新赋值，声明时就必须赋值</li>
<li>如果使用<code>const</code>声明复杂类型的数据，如<code>object</code>，则只针对于<code>const</code>所声明的<code>object</code>的内存地址不可修改，对于<code>object</code>内部数据可以正常修改</li>
</ul>
<h1 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="keyword">const</span> [foo, bar, baz] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo, bar, baz) <span class="comment">// 100, 200, 300</span></span><br><span class="line"><span class="comment">// 获取指定位置的值</span></span><br><span class="line"><span class="keyword">const</span> [, , baz] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz) <span class="comment">// 300</span></span><br><span class="line"><span class="comment">// 利用剩余参数接受</span></span><br><span class="line"><span class="keyword">const</span> [foo, ...rest] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest) <span class="comment">// [200, 300]</span></span><br><span class="line"><span class="comment">// 根据下标没有匹配到对应值时返回undefined</span></span><br><span class="line"><span class="keyword">const</span> [foo, bar, baz, more] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(more) <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 添加默认值</span></span><br><span class="line"><span class="keyword">const</span> [foo, bar, baz = <span class="number">123</span>, more = <span class="string">&#x27;default value&#x27;</span>] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz, more) <span class="comment">// 300, &#x27;default value&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;zce&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// zce</span></span><br><span class="line"><span class="comment">// 对于命名存在冲突的解构时，可以重命名</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: objName &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objName)</span><br><span class="line"><span class="comment">// 添加默认值</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: objName = <span class="string">&#x27;jack&#x27;</span> &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objName)</span><br></pre></td></tr></table></figure>

<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><ul>
<li>使用反引号来创建模板字符串</li>
<li>直接使用跟普通字符串没有什么区别，但是它比普通字符串多了很多新功能<ul>
<li>支持换行，多行字符串</li>
<li>支持插入表达式</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`hello es2015, this is a string`</span></span><br><span class="line"><span class="comment">// 允许换行</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`hello es2015,</span></span><br><span class="line"><span class="string">this is a \`string\``</span> <span class="comment">// 如果字符串中需要使用`，可以使用\进行转义</span></span><br><span class="line"><span class="comment">// 可以通过 $&#123;&#125; 插入表达式，表达式的执行结果将会输出到对应位置</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> msg = <span class="string">`hey, <span class="subst">$&#123;name&#125;</span> --- <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span>&#125;</span> ---- <span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<ul>
<li>带标签的模板字符串<ul>
<li>模板字符串的标签就是一个特殊的函数</li>
<li>使用这个标签就是调用这个函数</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> gender = <span class="literal">false</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myTagFunc</span> (strings, name, gender) &#123;</span><br><span class="line">	<span class="comment">// 这里的strings 就是模板字符串中静态的字符串组成的数组</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(strings) <span class="comment">// [&#x27;hey&#x27;,&#x27; is a&#x27;]</span></span><br><span class="line">	<span class="keyword">const</span> sex = gender ? <span class="string">&#x27;man&#x27;</span> : <span class="string">&#x27;woman&#x27;</span></span><br><span class="line">	<span class="comment">// 标签函数的返回值就是模板字符串的返回值</span></span><br><span class="line">	<span class="keyword">return</span> strings[<span class="number">0</span>] + name + strings[<span class="number">1</span>] + sex + strings[<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = myTagFunc<span class="string">`hey,<span class="subst">$&#123;name&#125;</span> is a <span class="subst">$&#123;gender&#125;</span>`</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串扩展方法"><a href="#字符串扩展方法" class="headerlink" title="字符串扩展方法"></a>字符串扩展方法</h1><ul>
<li><code>startsWith()</code>判断字符串是否以参数开头</li>
<li><code>endsWith()</code>判断字符串是否以参数结尾</li>
<li><code>includes()</code>判断字符串中是否包含参数</li>
</ul>
<h1 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数默认值必须写在最后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (a, b, c = <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="操作运算符"><a href="#操作运算符" class="headerlink" title="...操作运算符"></a><code>...</code>操作运算符</h1><ul>
<li>剩余参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span> (first, ...rest) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(rest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>展开数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr)</span><br></pre></td></tr></table></figure>

<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ul>
<li>箭头函数不会改变 <code>this</code> 指向</li>
<li>没有<code>arguments</code></li>
<li>不能用作构造函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inc</span> (number) &#123;</span><br><span class="line">	<span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">inc</span> = n =&gt; n + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="对象字面量增强"><a href="#对象字面量增强" class="headerlink" title="对象字面量增强"></a>对象字面量增强</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="string">&#x27;345&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="comment">// bar: bar</span></span><br><span class="line">  <span class="comment">// 属性名与变量名相同，可以省略 : bar</span></span><br><span class="line">  bar,</span><br><span class="line">  <span class="comment">// method1: function () &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(&#x27;method111&#x27;)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 方法可以省略 : function</span></span><br><span class="line">  method1 () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;method111&#x27;</span>)</span><br><span class="line">    <span class="comment">// 这种方法就是普通的函数，同样影响 this 指向。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Math.random(): 123 // 不允许</span></span><br><span class="line">  <span class="comment">// 计算属性名，通过 [] 让表达式的结果作为属性名</span></span><br><span class="line">  [bar]: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a><code>Object.assign</code></h2><ul>
<li>可以将多个源对象中的属性复制到一个目标对象中，返回目标对象，如果存在相同属性，则会使用后边的源对象覆盖目标对象</li>
<li>浅拷贝</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span> (obj) &#123;</span><br><span class="line">  <span class="comment">// obj.name = &#x27;func obj&#x27;</span></span><br><span class="line">  <span class="comment">// console.log(obj)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> funcObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br><span class="line">  funcObj.<span class="property">name</span> = <span class="string">&#x27;func obj&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(funcObj)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;global obj&#x27;</span> &#125;</span><br><span class="line"><span class="title function_">func</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure>

<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a><code>Object.is</code></h2><ul>
<li>判断两个值是否为同一个值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0 == false              // =&gt; true</span></span><br><span class="line"><span class="comment">// 0 === false             // =&gt; false</span></span><br><span class="line"><span class="comment">// +0 === -0               // =&gt; true</span></span><br><span class="line"><span class="comment">// NaN === NaN             // =&gt; false</span></span><br><span class="line"><span class="comment">// Object.is(+0, -0)       // =&gt; false</span></span><br><span class="line"><span class="comment">// Object.is(NaN, NaN)     // =&gt; true</span></span><br></pre></td></tr></table></figure>

<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a><code>Proxy</code></h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zce&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new Proxy接受两个参数，第一个参数为需要代理的目标对象，第二个为代理的处理对象</span></span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="comment">// 监视属性读取</span></span><br><span class="line">  <span class="comment">// target 目标对象 这里指的就是person</span></span><br><span class="line">  <span class="comment">// property 要访问的目标对象的属性</span></span><br><span class="line">  get (target, property) &#123;</span><br><span class="line">    <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="string">&#x27;default&#x27;</span></span><br><span class="line">    <span class="comment">// console.log(target, property)</span></span><br><span class="line">    <span class="comment">// return 100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 监视属性设置</span></span><br><span class="line">  <span class="comment">// target 目标对象 这里指的就是person</span></span><br><span class="line">  <span class="comment">// property 要访问的目标对象的属性</span></span><br><span class="line">  <span class="comment">// value是新值</span></span><br><span class="line">  set (target, property, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not an int`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    target[property] = value</span><br><span class="line">    <span class="comment">// console.log(target, property, value)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">personProxy.<span class="property">age</span> = <span class="number">100</span></span><br><span class="line">personProxy.<span class="property">gender</span> = <span class="literal">true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personProxy.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>

<p>与<code>defineProperty</code>的区别</p>
<ul>
<li><code>Proxy</code> 可以监视读写以外的操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zce&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person, &#123;</span><br><span class="line">  deleteProperty (target, property) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;delete&#x27;</span>, property)</span><br><span class="line">    <span class="keyword">delete</span> target[property]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">delete</span> personProxy.<span class="property">age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Proxy</code> 可以很方便的监视数组操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="keyword">const</span> listProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(list, &#123;</span><br><span class="line">  set (target, property, value) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>, property, value)</span><br><span class="line">    target[property] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 表示设置成功</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">listProxy.<span class="title function_">push</span>(<span class="number">100</span>)</span><br><span class="line">listProxy.<span class="title function_">push</span>(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Proxy</code> 不需要侵入对象,方式更为合理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name 被访问&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> person.<span class="property">_name</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set (value) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name 被设置&#x27;</span>)</span><br><span class="line">    person.<span class="property">_name</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;age 被访问&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> person.<span class="property">_age</span></span><br><span class="line">  &#125;,</span><br><span class="line">  set (value) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;age 被设置&#x27;</span>)</span><br><span class="line">    person.<span class="property">_age</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>)</span><br><span class="line"><span class="comment">// Proxy 方式更为合理</span></span><br><span class="line"><span class="keyword">const</span> person2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zce&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person2, &#123;</span><br><span class="line">  get (target, property) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, property)</span><br><span class="line">    <span class="keyword">return</span> target[property]</span><br><span class="line">  &#125;,</span><br><span class="line">  set (target, property, value) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>, property, value)</span><br><span class="line">    target[property] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">personProxy.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personProxy.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a><code>Reflect</code></h1><p><code>Reflect</code> 是一个内置的对象，内部封装了一系列对对象的底层操作，属于静态类，不能被实例，<code>Reflect</code> 成员方法就是<code>Proxy</code>处理对象的默认实现</p>
<ul>
<li><strong><code>Reflect.apply(target, thisArgument, argumentsList)</code></strong> <ul>
<li>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 <code>Function.prototype.apply()</code> 功能类似。</li>
</ul>
</li>
<li><strong><code>Reflect.construct(target, argumentsList[, newTarget])</code></strong> <ul>
<li>对构造函数进行 new 操作，相当于执行 <code>new target(…args)</code>。</li>
</ul>
</li>
<li><strong><code>Reflect.defineProperty(target, propertyKey, attributes)</code></strong> <ul>
<li>和 <code>Object.defineProperty()</code> 类似，如果设置成功就会返回 <code>true</code></li>
</ul>
</li>
<li><strong><code>Reflect.deleteProperty(target, propertyKey)</code></strong> <ul>
<li>作为函数的<code>delete</code>操作符，相当于执行 <code>delete target[name]</code>。</li>
</ul>
</li>
<li><strong><code>Reflect.get(target, propertyKey[, receiver])</code></strong> <ul>
<li>获取对象身上某个属性的值，类似于 <code>target[name]</code>。</li>
</ul>
</li>
<li><strong><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code></strong> <ul>
<li>类似于 <code>Object.getOwnPropertyDescriptor()</code>，如果对象中存在该属性，则返回对应的属性描述符, 否则返回<code>undefined</code>.</li>
</ul>
</li>
<li><strong><code>Reflect.getPrototypeOf(target)</code></strong> <ul>
<li>类似于 <code>Object.getPrototypeOf()</code>。</li>
</ul>
</li>
<li><strong><code>Reflect.has(target, propertyKey)</code></strong> <ul>
<li>判断一个对象是否存在某个属性，和 <code>in</code> 运算符 的功能完全相同。</li>
</ul>
</li>
<li><strong><code>Reflect.isExtensible(target)</code></strong> <ul>
<li>类似于 <code>Object.isExtensible()</code>.</li>
</ul>
</li>
<li><strong><code>Reflect.ownKeys(target)</code></strong> <ul>
<li>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 <code>Object.keys()</code>, 但不会受<code>enumerable</code>影响).</li>
</ul>
</li>
<li><strong><code>Reflect.preventExtensions(target)</code></strong> <ul>
<li>类似于 <code>Object.preventExtensions()</code>。返回一个<code>Boolean</code>。</li>
</ul>
</li>
<li><strong><code>Reflect.set(target, propertyKey, value[, receiver])</code></strong> <ul>
<li>将值分配给属性的函数。返回一个<code>Boolean</code>，如果更新成功，则返回<code>true</code>。</li>
</ul>
</li>
<li><strong><code>Reflect.setPrototypeOf(target, prototype)</code></strong> <ul>
<li>设置对象原型的函数. 返回一个 <code>Boolean</code>， 如果更新成功，则返回<code>true</code>。</li>
</ul>
</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><code>Promise</code></h1><p><a href="https://wzx0905.gitee.io/JavaScript/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B#Promise">跳转至<code>Promise</code></a></p>
<h1 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a><code>class</code> 类</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 构造函数 </span></span><br><span class="line">  <span class="title function_">constructor</span> (name) &#123;</span><br><span class="line">  	<span class="comment">// 实例成员</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 原型方法</span></span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hi, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">p.<span class="title function_">say</span>()</span><br><span class="line"><span class="comment">// extends 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hi, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (name, number) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name) <span class="comment">// 调用父类构造函数，要在this之前使用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">number</span> = number</span><br><span class="line">  &#125;</span><br><span class="line">  hello () &#123;</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">say</span>() <span class="comment">// 调用父类成员</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`my school number is <span class="subst">$&#123;<span class="variable language_">this</span>.number&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;100&#x27;</span>)</span><br><span class="line">s.<span class="title function_">hello</span>()</span><br><span class="line"><span class="comment">// static 静态方法</span></span><br><span class="line"><span class="comment">// 只能通过类名访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hi, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> create (name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tom = <span class="title class_">Person</span>.<span class="title function_">create</span>(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line">tom.<span class="title function_">say</span>()</span><br></pre></td></tr></table></figure>

<h1 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h1><p>全新的数据结构，与数组非常类似，区别在于，<code>set</code> 中的值是不允许重复的，每个值在同一个<code>set</code>当中都是唯一的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set 数据结构</span></span><br><span class="line"><span class="comment">// 创建集合实例</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="comment">// 通过add方法新增成员，并且add返回集合实例本身，所以可以链式调用</span></span><br><span class="line">s.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">3</span>).<span class="title function_">add</span>(<span class="number">4</span>).<span class="title function_">add</span>(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 数组去重</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment">// const result = Array.from(new Set(arr))</span></span><br><span class="line"><span class="keyword">const</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// 循环遍历</span></span><br><span class="line">s.<span class="title function_">forEach</span>(<span class="function"><span class="params">i</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i))</span><br><span class="line"><span class="comment">// 也可以使用ES2015中的 for…of 来遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h1><p>全新的数据结构，与对象非常类似，区别在于，对象结构中的<code>key</code>只能是字符串类型，<code>map</code>可以接受任意类型的数据作为<code>key</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="literal">true</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">obj[<span class="number">123</span>] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line">obj[&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;] = <span class="string">&#x27;value&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj))  <span class="comment">// [&#x27;123&#x27;,&#x27;true&#x27;,&#x27;[object Object]&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;[object Object]&#x27;</span>]) <span class="comment">// value </span></span><br><span class="line"><span class="comment">// 可以将一个二维键值对数组转换成一个Map对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;uname&#x27;</span>:<span class="string">&#x27;zs&#x27;</span>],[<span class="string">&#x27;age&#x27;</span>:<span class="number">12</span>]]))</span><br></pre></td></tr></table></figure>

<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a><code>Symbol</code></h1><p>新的原始数据类型 <code>Symbol</code> ，表示独一无二的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s) <span class="comment">// Symbol()</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> s) <span class="comment">// symbol</span></span><br><span class="line"><span class="comment">// 两个 Symbol 永远不会相等</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title class_">Symbol</span>() === <span class="title class_">Symbol</span>() <span class="comment">// false</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 可以传入一个描述字符串用来区分Symbol</span></span><br><span class="line"><span class="comment">// Symbol 描述文本</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>))</span><br><span class="line"><span class="comment">// 获取添加了描述字符串的Symbol</span></span><br><span class="line"><span class="comment">// Symbol.for() </span></span><br><span class="line"><span class="comment">// 首先会在全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索，只接受string类型参数 如果传入的不是string会自动转为string</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1 === s2) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> yellow = <span class="title class_">Symbol</span>(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> yellow1 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;Yellow&quot;</span>);</span><br><span class="line">yellow === yellow1;      <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 对象可以开始使用symbol作为属性key</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="title class_">Symbol</span>()] = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">obj[<span class="title class_">Symbol</span>()] = <span class="string">&#x27;456&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj) <span class="comment">// &#123; [Symbol()]: &#x27;123&#x27;, [Symbol()]: &#x27;456&#x27; &#125;</span></span><br><span class="line"><span class="comment">// 可以使用Symbol为对象添加私有成员</span></span><br><span class="line"><span class="comment">// Symbol 模拟实现私有成员</span></span><br><span class="line"><span class="comment">// a.js ======================================</span></span><br><span class="line"><span class="keyword">const</span> static_name = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  [static_name]: <span class="string">&#x27;zce&#x27;</span>,</span><br><span class="line">  say () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>[static_name])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只对外暴露 person</span></span><br><span class="line"><span class="comment">// b.js =======================================</span></span><br><span class="line"><span class="comment">// 由于无法创建出一样的 Symbol 值，</span></span><br><span class="line"><span class="comment">// 所以无法直接访问到 person 中的「私有」成员</span></span><br><span class="line"><span class="comment">// person[Symbol()]</span></span><br><span class="line">person.<span class="title function_">say</span>()</span><br><span class="line"><span class="comment">// 对象中的Symbol属性名 无法被for…in、Object.key()、JSON.stringify 这些手段获取到如果要获取对象中的Symbol属性，可以使用 Object.getOwnPropertySymbols() 方法来获取</span></span><br></pre></td></tr></table></figure>

<h1 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a><code>for…of</code>循环</h1><p>可以作为遍历所有数据结构的统一方式，只要明白它的工作原理( 迭代器 )就可以使用它去遍历任何一种自定义的数据结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本使用</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>]</span><br><span class="line"><span class="comment">// item 是数组中的每一个成员</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for…of 循环可以替代 数组对象的 forEach 方法</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ==================================</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">  <span class="comment">// 使用for of 可以配合break终止循环</span></span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for…of 遍历Set 和 Map</span></span><br><span class="line"><span class="comment">// 遍历 Set 与遍历数组相同</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历 Map 可以配合数组结构语法，直接获取键值</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;345&#x27;</span>)</span><br><span class="line"><span class="comment">// 遍历 Map 得到的是[key, value]结构的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通对象不能被 for…of 遍历</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="number">456</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="可迭代接口"><a href="#可迭代接口" class="headerlink" title="可迭代接口"></a>可迭代接口</h1><p>只要数据结构实现了<code>Iterable</code>接口，就可以被 <code>for…of</code> 进行遍历</p>
<ul>
<li>所有能够被<code>for…of</code>遍历数据类型都要实现 <code>Iterable</code> 这个接口 (内部需要挂载一个<code>Iterable</code>方法) 即 <code>Symbol.Iterable</code></li>
<li>这个方法需要返回一个带有<code>next()</code> 方法的对象，不断调用<code>next</code>就可以实现对内部数据的遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>])</span><br><span class="line"><span class="keyword">const</span> iterator = set[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: &#x27;foo&#x27;, done: false &#125; </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: &#x27;bar&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: &#x27;baz&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>()) <span class="comment">//&#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// 迭代器设计模式</span></span><br><span class="line"><span class="keyword">const</span> todos = &#123;</span><br><span class="line">  <span class="attr">life</span>: [<span class="string">&#x27;吃饭&#x27;</span>, <span class="string">&#x27;睡觉&#x27;</span>, <span class="string">&#x27;打豆豆&#x27;</span>],</span><br><span class="line">  <span class="attr">learn</span>: [<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;外语&#x27;</span>],</span><br><span class="line">  <span class="attr">work</span>: [<span class="string">&#x27;喝茶&#x27;</span>],</span><br><span class="line">  <span class="comment">// 提供统一遍历访问接口</span></span><br><span class="line">  <span class="attr">each</span>: <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> all = [].<span class="title function_">concat</span>(<span class="variable language_">this</span>.<span class="property">life</span>, <span class="variable language_">this</span>.<span class="property">learn</span>, <span class="variable language_">this</span>.<span class="property">work</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> all) &#123;</span><br><span class="line">      <span class="title function_">callback</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 提供迭代器（ES2015 统一遍历访问接口）</span></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> all = [...<span class="variable language_">this</span>.<span class="property">life</span>, ...<span class="variable language_">this</span>.<span class="property">learn</span>, ...<span class="variable language_">this</span>.<span class="property">work</span>]</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: all[index],</span><br><span class="line">          <span class="attr">done</span>: index++ &gt;= all.<span class="property">length</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">todos.<span class="title function_">each</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------------------------------&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> todos) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul>
<li>生成器函数会返回一个生成器对象，</li>
<li>当我们调用这个生成器对象的<code>next</code>方法 才会开始直接函数体，</li>
<li>在执行的过程中一旦遇到了<code>yield</code>关键词 函数的执行就会被暂停下来，</li>
<li><code>yield</code> 后面的值会作为 <code>next</code>方法的返回值的结果 <code>&#123; value：yield后面的值, done：false/true &#125;</code>,</li>
<li>继续调用<code>next</code>就会从暂停的位置继续执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * foo () &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1111&#x27;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">100</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2222&#x27;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">200</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3333&#x27;</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">300</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = <span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">// 1111 &#123; value: 100, done: false &#125;  第一次调用，函数体开始执行，遇到第一个 yield 暂停</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">// 2222 &#123; value: 200, done: false &#125; 第二次调用，从暂停位置继续，直到遇到下一个 yield 再次暂停</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">// 3333 &#123; value: 300, done: false &#125; 第三次调用，从暂停位置继续，直到遇到下一个 yield 再次暂停</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(generator.<span class="title function_">next</span>()) <span class="comment">// &#123; value: undefined, done: true &#125; 第四次调用，已经没有需要执行的内容了，所以直接得到undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a><code>ES Modules</code></h1><p>语言层面的模块化标准</p>
<p><a href="https://wzx0905.gitee.io/%E5%B7%A5%E7%A8%8B%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E4%B8%8E%E8%A7%84%E8%8C%83%E5%8C%96%E6%A0%87%E5%87%86">跳转至模块化开发与规范化标准</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>手写Promise源码</title>
    <url>/2021/03/117ac517ba3d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. Promise 就是一个类 在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行</span></span><br><span class="line"><span class="comment">  2. Promise 中有三种状态 分别为 成功 fulfilled 失败 rejected 等待 pending</span></span><br><span class="line"><span class="comment">    pending -&gt; fulfilled</span></span><br><span class="line"><span class="comment">    pending -&gt; rejected</span></span><br><span class="line"><span class="comment">    一旦状态确定就不可更改</span></span><br><span class="line"><span class="comment">  3. resolve和reject函数是用来更改状态的</span></span><br><span class="line"><span class="comment">    resolve: fulfilled</span></span><br><span class="line"><span class="comment">    reject: rejected</span></span><br><span class="line"><span class="comment">  4. then方法内部做的事情就判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败回调函数 then方法是被定义在原型对象中的</span></span><br><span class="line"><span class="comment">  5. then成功回调有一个参数 表示成功之后的值 then失败回调有一个参数 表示失败后的原因</span></span><br><span class="line"><span class="comment">  6. 同一个promise对象下面的then方法是可以被调用多次的</span></span><br><span class="line"><span class="comment">  7. then方法是可以被链式调用的, 后面then方法的回调函数拿到值的是上一个then方法的回调函数的返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span>; <span class="comment">// 等待</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;fulfilled&#x27;</span>; <span class="comment">// 成功</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span>; <span class="comment">// 失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="comment">// 执行这个类的时候，传递一个执行器，执行器会立即执行</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>, <span class="variable language_">this</span>.<span class="property">reject</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">reject</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Promsie 状态 </span></span><br><span class="line">  status = <span class="variable constant_">PENDING</span>;</span><br><span class="line">  <span class="comment">// 成功之后的值</span></span><br><span class="line">  value = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 失败后的原因</span></span><br><span class="line">  reason = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 成功回调</span></span><br><span class="line">  successCallback = [];</span><br><span class="line">  <span class="comment">// 失败回调</span></span><br><span class="line">  failCallback = [];</span><br><span class="line">  <span class="comment">// 此处使用箭头函数是为了使函数内部的this指向为实例类</span></span><br><span class="line">  resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态不是等待，阻止程序向下执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将状态更改为成功</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span>;</span><br><span class="line">    <span class="comment">// 保存成功之后的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="comment">// 判断成功回调是否存在，如果存在就调用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">successCallback</span>.<span class="property">length</span>) <span class="variable language_">this</span>.<span class="property">successCallback</span>.<span class="title function_">shift</span>()()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用箭头函数是为了使函数内部的this指向为实例类</span></span><br><span class="line">  reject = <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态不是等待，阻止程序向下执行</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> !== <span class="variable constant_">PENDING</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将状态更改为失败</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span>;</span><br><span class="line">    <span class="comment">// 保存失败后的原因</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">    <span class="comment">// 判断失败回调是否存在，如果存在就调用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">failCallback</span>.<span class="property">length</span>) <span class="variable language_">this</span>.<span class="property">failCallback</span>.<span class="title function_">shift</span>()()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">then</span>(<span class="params">successCallback, failCallback</span>) &#123;</span><br><span class="line">    <span class="comment">// 参数可选</span></span><br><span class="line">    <span class="comment">// 判断传入的参数是否为函数，如果是则保留，否则初始化为value =&gt; value</span></span><br><span class="line">    successCallback = <span class="keyword">typeof</span> successCallback === <span class="string">&#x27;function&#x27;</span> ? successCallback : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    <span class="comment">// 参数可选</span></span><br><span class="line">    <span class="comment">// 判断传入的参数是否为函数，如果是则保留，否则初始化为reason =&gt; &#123; throw reason &#125;</span></span><br><span class="line">    failCallback = <span class="keyword">typeof</span> failCallback === <span class="string">&#x27;function&#x27;</span> ? failCallback : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;;</span><br><span class="line">    <span class="keyword">let</span> promsie = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123; <span class="comment">// 成功</span></span><br><span class="line">        <span class="comment">// 此处使用setTimeout的作用是为了能够拿到实例后的promsie</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将回调后的结果保存</span></span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">successCallback</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">            <span class="comment">// 判断x的值是普通值还是promise对象</span></span><br><span class="line">            <span class="comment">// 如果是普通值，直接调用resolve </span></span><br><span class="line">            <span class="comment">// 如果是promise对象，查看promsie对象返回的结果，再根据promise对象返回的结果，决定调用resolve，还是调用reject</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promsie, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123; <span class="comment">// 失败</span></span><br><span class="line">        <span class="comment">// 此处使用setTimeout的作用是为了能够拿到实例后的promsie</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将回调后的结果保存</span></span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">failCallback</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">            <span class="comment">// 判断x的值是普通值还是promise对象</span></span><br><span class="line">            <span class="comment">// 如果是普通值，直接调用resolve </span></span><br><span class="line">            <span class="comment">// 如果是promise对象，查看promsie对象返回的结果，再根据promise对象返回的结果，决定调用resolve，还是调用reject</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promsie, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 异步</span></span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="comment">// 将成功回调和失败回调存储起来</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">successCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 此处使用setTimeout的作用是为了能够拿到实例后的promsie</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 将回调后的结果保存</span></span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">successCallback</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">              <span class="comment">// 判断x的值是普通值还是promise对象</span></span><br><span class="line">              <span class="comment">// 如果是普通值，直接调用resolve </span></span><br><span class="line">              <span class="comment">// 如果是promise对象，查看promsie对象返回的结果，再根据promise对象返回的结果，决定调用resolve，还是调用reject</span></span><br><span class="line">              <span class="title function_">resolvePromise</span>(promsie, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">failCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 此处使用setTimeout的作用是为了能够拿到实例后的promsie</span></span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 将回调后的结果保存</span></span><br><span class="line">              <span class="keyword">let</span> x = <span class="title function_">failCallback</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">              <span class="comment">// 判断x的值是普通值还是promise对象</span></span><br><span class="line">              <span class="comment">// 如果是普通值，直接调用resolve </span></span><br><span class="line">              <span class="comment">// 如果是promise对象，查看promsie对象返回的结果，再根据promise对象返回的结果，决定调用resolve，还是调用reject</span></span><br><span class="line">              <span class="title function_">resolvePromise</span>(promsie, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 此处返回promise实现链式调用</span></span><br><span class="line">    <span class="keyword">return</span> promsie;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// catch方法 promise失败会被执行</span></span><br><span class="line">  <span class="keyword">catch</span>(failCallback) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">undefined</span>, failCallback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// finally方法 无论promise成功失败都会被执行</span></span><br><span class="line">  <span class="title function_">finally</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value);</span><br><span class="line">    &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// all方法 接收一个array，是一个promise集合，当所有promise执行成功后，才返回resolve，有一个失败则返回reject</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="comment">// 用来存储promise执行结果</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 记录promise完成数量</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当promise执行完成时向result添加执行结果</span></span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">addData</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        result[key] = value;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">// 当所有promise执行完毕后调用resolve并返回result</span></span><br><span class="line">        <span class="keyword">if</span> (index === array.<span class="property">length</span>) <span class="title function_">resolve</span>(result);</span><br><span class="line">      &#125;</span><br><span class="line">      array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">          <span class="comment">// promise 对象</span></span><br><span class="line">          item.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="title function_">addData</span>(key, value), reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 普通值</span></span><br><span class="line">          <span class="title function_">addData</span>(key, item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// allSettled方法 接收一个array，是一个promise集合，当所有promise执行完成(无论成功还是失败)后，返回resolve</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">allSettled</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="comment">// 用来存储promise执行结果</span></span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="comment">// 记录promise完成数量</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">function</span> <span class="title function_">addData</span>(<span class="params">key, value, status</span>) &#123;</span><br><span class="line">        <span class="comment">// 以对象的形式存储promise执行结果和状态</span></span><br><span class="line">        result[key] = &#123; status, value &#125;;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">// 当所有promise执行完毕后调用resolve并返回result</span></span><br><span class="line">        <span class="keyword">if</span> (index === array.<span class="property">length</span>) <span class="title function_">resolve</span>(result);</span><br><span class="line">      &#125;</span><br><span class="line">      array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">          <span class="comment">// promise 对象</span></span><br><span class="line">          <span class="comment">// 无论promsie成功还是失败，都将结果和状态存储到result中</span></span><br><span class="line">          item.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="title function_">addData</span>(key, value, <span class="variable constant_">FULFILLED</span>), <span class="function"><span class="params">reason</span> =&gt;</span> <span class="title function_">addData</span>(key, reason, <span class="variable constant_">REJECTED</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 普通值</span></span><br><span class="line">          <span class="title function_">addData</span>(key, item, <span class="variable constant_">FULFILLED</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// race方法 接收一个array，是一个promise集合，其中任意一个promise执行完毕之后，返回执行结果，无论成功失败</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">race</span>(<span class="params">array</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      array.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">          <span class="comment">// promise 对象</span></span><br><span class="line">          item.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 普通值</span></span><br><span class="line">          <span class="title function_">resolve</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// resolve方法 快速创建一个执行结果一定为成功的Promise</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reject方法 快速创建一个执行结果一定为失败的Promise</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(value));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promsie, x, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断then方法返回的promise和回调函数返回的结果x是否相等，相等则抛出异常，防止循环调用</span></span><br><span class="line">  <span class="keyword">if</span> (promsie === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">    <span class="comment">// promise 对象</span></span><br><span class="line">    <span class="comment">// x.then(value =&gt; resolve(value), reason =&gt; reject(reason));</span></span><br><span class="line">    x.<span class="title function_">then</span>(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 普通值</span></span><br><span class="line">    <span class="title function_">resolve</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyPromise</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript异步编程</title>
    <url>/2021/03/4fa87068843a/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h1><p>代码中的任务依次执行，排队执行</p>
<p><em><code>注：优点：代码自上而下执行，便于阅读，逻辑清晰；缺点：如果其中某一部分代码执行时间过长，会造成代码阻塞，页面卡顿，影响用户体验</code></em></p>
<h1 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h1><p>不会等待这个任务的结束才开始下一个任务，开启之后就立即往后执行下一个任务，后续逻辑一般会通过回调函数的方式定义</p>
<p><em><code>注：优点：不会造成页面阻塞；缺点：代码执行顺序混乱，不易于阅读理解</code></em></p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>所有异步编程方案的根基，由调用者定义，交给执行者执行的函数（把函数作为参数传递）</p>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a><code>Promise</code></h1><p>为异步编程提供一种更合理、更强大的统一解决方案</p>
<h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p><img src="https://pic.imgdb.cn/item/60d30889844ef46bb23d12af.png"></p>
<p><em><code>注：Promise的状态只会从Pending变为Fulfilled或Rejected，且一旦改变不可更改</code></em></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里用来“兑换”承诺</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="number">100</span>) <span class="comment">// 承诺达成</span></span><br><span class="line">    <span class="comment">// reject(new Error(&#x27;promise rejected&#x27;)) // 承诺失败</span></span><br><span class="line">&#125;)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功之后的回调并接受返回值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;resolved&#x27;</span>, value)</span><br><span class="line">&#125;, <span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功之后的回调并接受失败信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;rejected&#x27;</span>, error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用<code>promise</code>封装<code>ajax</code>案例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise 方式的 AJAX</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span> (url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">        xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">        xhr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">response</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">this</span>.<span class="property">statusText</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;/api/foo.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;, <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>常见误区（错误使用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 嵌套使用 Promise 是最常见的误区</span></span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;/api/urls.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">urls</span>) &#123;</span><br><span class="line">    <span class="title function_">ajax</span>(urls.<span class="property">users</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">users</span>) &#123;</span><br><span class="line">        <span class="title function_">ajax</span>(urls.<span class="property">users</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">users</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>链式调用（正确使用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用链式调用，避免嵌套</span></span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;/api/users.json&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/urls.json&#x27;</span>)</span><br><span class="line">    &#125;) <span class="comment">// =&gt; Promise</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/urls.json&#x27;</span>)</span><br><span class="line">    &#125;) <span class="comment">// =&gt; Promise</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/urls.json&#x27;</span>)</span><br><span class="line">    &#125;) <span class="comment">// =&gt; Promise</span></span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> <span class="title function_">onRejected</span> (error) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onRejected&#x27;</span>, error)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p><em><code>注：catch(onRejected) 实际上就相当于 then(undefined, onRejected)，Promise 链条上的任何一个异常都会被一直向后传递，直至被捕获，所以建议使用catch方法捕获异常，finally方法无论promise执行成功还是失败都会被调用</code></em></p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul>
<li><code>Promise.resolve()</code><ul>
<li>快速创建一个执行结果为<code>Fulfilled</code>的<code>Promise</code>对象</li>
<li>如果传入的是一个值，作为<code>resolve</code>的参数返回</li>
<li>如果传入的是一个 <code>Promise</code> 对象，<code>Promise.resolve</code> 方法原样返回</li>
<li>如果传入的是带有一个跟 <code>Promise</code> 一样的 then 方法的对象， <code>Promise.resolve</code> 会将这个对象作为 <code>Promise</code> 执行</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.resolve(&#x27;foo&#x27;)</span><br><span class="line">    .then(function (value) &#123;</span><br><span class="line">    	console.log(value)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Promise.reject()</code><ul>
<li>快速创建一个执行结果为<code>Rejected</code>的<code>Promise</code>对象</li>
<li>传入任何值，都会作为这个 <code>Promise</code> 失败的理由</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;rejected&#x27;</span>))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Promise.all()</code><ul>
<li>将多个<code>Promise</code>合并为一个<code>Promise</code></li>
<li>当所有组合<code>Promise</code>执行成功后，才会成功，任何一个<code>Promise</code>执行失败都会失败</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;/api/users.json&#x27;</span>)</span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;/api/posts.json&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> promise = <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;/api/users.json&#x27;</span>),</span><br><span class="line">    <span class="title function_">ajax</span>(<span class="string">&#x27;/api/posts.json&#x27;</span>)</span><br><span class="line">])</span><br><span class="line">promise</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">values</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(values)</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="title function_">ajax</span>(<span class="string">&#x27;/api/urls.json&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> urls = <span class="title class_">Object</span>.<span class="title function_">values</span>(value)</span><br><span class="line">        <span class="keyword">const</span> tasks = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> <span class="title function_">ajax</span>(url))</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(tasks)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(values)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Promise.race()</code><ul>
<li>将多个<code>Promise</code>合并为一个<code>Promise</code></li>
<li>只要有一个组合的<code>Promise</code>执行成功，就会成功，执行结果以第一个完成的<code>Promise</code>为准</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise.race 实现超时控制</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="title function_">ajax</span>(<span class="string">&#x27;/api/posts.json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;timeout&#x27;</span>)), <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">    request,</span><br><span class="line">    timeout</span><br><span class="line">])</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="执行时序"><a href="#执行时序" class="headerlink" title="执行时序"></a>执行时序</h1><ul>
<li>宏任务：回调队列中的任务，宏任务执行过程中可以临时加上一些额外的需求，可以选择作为一个新的宏任务进到队列中排队，也可以作为当前任务的微任务<ul>
<li>script中的代码块</li>
<li><code>setTimeout()</code></li>
<li><code>setInterval()</code></li>
<li><code>setImmediate()</code>（非标准，<code>IE</code>和<code>Node.js</code>中支持）</li>
<li>注册事件</li>
</ul>
</li>
<li>微任务：直接在当前任务结束过后立即执行<ul>
<li><code>Promise</code></li>
<li><code>MutationObserver</code></li>
<li><code>queueMicrotask()</code></li>
<li><code>process.nextTick(Nodejs)</code></li>
</ul>
</li>
</ul>
<h1 id="Generator异步方案"><a href="#Generator异步方案" class="headerlink" title="Generator异步方案"></a><code>Generator</code>异步方案</h1><p>使得异步调用变得扁平化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generator 配合 Promise 的异步方案</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ajax</span> (url) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line">        xhr.<span class="property">responseType</span> = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">        xhr.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(xhr.<span class="property">response</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(xhr.<span class="property">statusText</span>))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.<span class="title function_">send</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> * main () &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> users = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/users.json&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(users)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> posts = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/posts.json&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(posts)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> urls = <span class="keyword">yield</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/urls11.json&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(urls)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">co</span> (generator) &#123;</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">generator</span>()</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleResult</span> (result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="property">done</span>) <span class="keyword">return</span> <span class="comment">// 生成器函数结束</span></span><br><span class="line">        result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">handleResult</span>(g.<span class="title function_">next</span>(data))</span><br><span class="line">        &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            g.<span class="keyword">throw</span>(error)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">handleResult</span>(g.<span class="title function_">next</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">co</span>(main)</span><br></pre></td></tr></table></figure>

<h1 id="Async-Await语法糖"><a href="#Async-Await语法糖" class="headerlink" title="Async/Await语法糖"></a><code>Async/Await</code>语法糖</h1><p>语言层面的异步编程标准</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span> () &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> users = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/users.json&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(users)</span><br><span class="line">        <span class="keyword">const</span> posts = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/posts.json&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(posts)</span><br><span class="line">        <span class="keyword">const</span> urls = <span class="keyword">await</span> <span class="title function_">ajax</span>(<span class="string">&#x27;/api/urls.json&#x27;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(urls)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main ()</span><br></pre></td></tr></table></figure>

<p><em><code>注：async返回是一个Promsie对象，await目前只能async内部使用</code></em></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程范式（四）函子</title>
    <url>/2021/03/70cae5676ffe/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="为什么要学函子"><a href="#为什么要学函子" class="headerlink" title="为什么要学函子"></a>为什么要学函子</h1><p>到目前为止已经已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用 控制在可控的范围内、异常处理、异步操作等。</p>
<h1 id="什么是-Functor"><a href="#什么是-Functor" class="headerlink" title="什么是 Functor"></a>什么是 <code>Functor</code></h1><ul>
<li>容器：包含值和值的变形关系(这个变形关系就是函数)</li>
<li>函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 <code>map</code> 方法，<code>map</code> 方法可以运 行一个函数对值进行处理(变形关系)</li>
</ul>
<h1 id="Functor-函子"><a href="#Functor-函子" class="headerlink" title="Functor 函子"></a><code>Functor</code> 函子</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个容器，包裹一个值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="comment">// of 静态方法，可以省略 new 关键字创建对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Container</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (value) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">_value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// map 方法，传入变形关系，将容器里的每一个值映射到另一个容器</span></span><br><span class="line">    map (fn) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">3</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>总结</p>
<ul>
<li>函数式编程的运算不直接操作值，而是由函子完成</li>
<li>函子就是一个实现了 <code>map</code> 契约的对象</li>
<li>我们可以把函子想象成一个盒子，这个盒子里封装了一个值</li>
<li>想要处理盒子中的值，我们需要给盒子的 <code>map</code> 方法传递一个处理值的函数（纯函数），由这 个函数来对值进行处理</li>
<li>最终 <code>map</code> 方法返回一个包含新值的盒子（函子）</li>
</ul>
</li>
<li><p>在 <code>Functor</code> 中如果我们传入 <code>null</code> 或 <code>undefined</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 值如果不小心传入了空值(副作用)</span><br><span class="line">Container.of(null)</span><br><span class="line">	.map(x =&gt; x.toUpperCase())</span><br><span class="line">// TypeError: Cannot read property &#x27;toUpperCase&#x27; of null</span><br></pre></td></tr></table></figure>

<p><em><code>注：此处Container如果传入空值将会导致程序报错</code></em></p>
<h1 id="MayBe-函子"><a href="#MayBe-函子" class="headerlink" title="MayBe 函子"></a><code>MayBe</code> 函子</h1><ul>
<li>我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理</li>
<li><code>MayBe</code> 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MayBe</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MayBe</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (value) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果对空值变形的话直接返回 值为 null 的函子</span></span><br><span class="line">    map (fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">isNothing</span>() ? <span class="title class_">MayBe</span>.<span class="title function_">of</span>(<span class="literal">null</span>) : <span class="title class_">MayBe</span>.<span class="title function_">of</span>(<span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    isNothing () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span> === <span class="literal">null</span> || <span class="variable language_">this</span>.<span class="property">_value</span> === <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入具体值</span></span><br><span class="line"><span class="title class_">MayBe</span>.<span class="title function_">of</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">	.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">toUpperCase</span>())</span><br><span class="line"><span class="comment">// 传入 null 的情况</span></span><br><span class="line"><span class="title class_">MayBe</span>.<span class="title function_">of</span>(<span class="literal">null</span>)</span><br><span class="line">	.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">toUpperCase</span>())</span><br><span class="line"><span class="comment">// =&gt; MayBe &#123; _value: null &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>MayBe</code> 函子中，我们很难确认是哪一步产生的空值问题，如下例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MayBe</span>.<span class="title function_">of</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">toUpperCase</span>())</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">null</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="comment">// =&gt; MayBe &#123; _value: null &#125;</span></span><br></pre></td></tr></table></figure>

<p><em><code>注：MayBe函子解决了空值问题，当出现空值时返回value为null的函子，但无法确定具体哪一步出现了空值</code></em></p>
<h1 id="Either-函子"><a href="#Either-函子" class="headerlink" title="Either 函子"></a><code>Either</code> 函子</h1><ul>
<li><code>Either</code> 两者中的任何一个，类似于 <code>if...else...</code>的处理</li>
<li>异常会让函数变的不纯，<code>Either</code> 函子可以用来做异常处理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Left</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Left</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (value) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">_value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    map (fn) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Right</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Right</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (value) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">_value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">map</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Right</span>.<span class="title function_">of</span>(<span class="title function_">fn</span>(<span class="variable language_">this</span>.<span class="property">_value</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Either</code> 用来处理异常</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseJSON</span>(<span class="params">json</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Right</span>.<span class="title function_">of</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(json));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Left</span>.<span class="title function_">of</span>(&#123; <span class="attr">error</span>: e.<span class="property">message</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">parseJSON</span>(<span class="string">&#x27;&#123; &quot;name&quot;: &quot;zs&quot; &#125;&#x27;</span>)</span><br><span class="line">		.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="property">name</span>.<span class="title function_">toUpperCase</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br></pre></td></tr></table></figure>

<p><em><code>注：Either解决的了MayBe函子中的无法确认异常步骤的问题</code></em></p>
<h1 id="IO-函子"><a href="#IO-函子" class="headerlink" title="IO 函子"></a><code>IO</code> 函子</h1><ul>
<li><code>IO</code> 函子中的 <code>_value</code> 是一个函数，这里是把函数作为值来处理</li>
<li><code>IO</code> 函子可以把不纯的动作存储到 <code>_value</code> 中，延迟执行这个不纯的操作(惰性执行)，包装当前的操作</li>
<li>把不纯的操作交给调用者来处理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IO</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">IO</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> x</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (fn) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">_value</span> = fn</span><br><span class="line">    &#125;</span><br><span class="line">    map (fn) &#123;</span><br><span class="line">        <span class="comment">// 把当前的 value 和 传入的 fn 组合成一个新的函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">IO</span>(fp.<span class="title function_">flowRight</span>(fn, <span class="variable language_">this</span>.<span class="property">_value</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">let</span> io = <span class="variable constant_">IO</span>.<span class="title function_">of</span>(process).<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">execPath</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(io.<span class="title function_">_value</span>())</span><br></pre></td></tr></table></figure>

<h1 id="Task-异步执行"><a href="#Task-异步执行" class="headerlink" title="Task 异步执行"></a><code>Task</code> 异步执行</h1><ul>
<li>异步任务的实现过于复杂，我们使用 <code>folktale</code> 中的 <code>Task</code> 来演示</li>
<li><code>folktale</code> 一个标准的函数式编程库<ul>
<li>和 <code>lodash</code>、<code>ramda</code> 不同的是，他没有提供很多功能函数</li>
<li>只提供了一些函数式处理的操作，例如：<code>compose</code>、<code>curry</code> 等，一些函子 <code>Task</code>、<code>Either</code>、 <code>MayBe</code> 等</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; compose, curry &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/core/lambda&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; toUpper, first &#125; = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="comment">// 第一个参数是传入函数的参数个数</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">curry</span>(<span class="number">2</span>, <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(x + y)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">f</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="title function_">f</span>(<span class="number">3</span>)(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 函数组合</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">compose</span>(toUpper, first)</span><br><span class="line"><span class="title function_">f</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Task</code> 异步执行<ul>
<li><code>folktale</code>(2.3.2) 2.x 中的 <code>Task</code> 和 1.0 中的 <code>Task</code> 区别很大，1.0 中的用法更接近我们现在演示的函子</li>
<li>这里以 2.3.2 来演示</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; task &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/concurrency/task&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readFile</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">task</span>(<span class="function"><span class="params">resolver</span> =&gt;</span> &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(filename, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) resolver.<span class="title function_">reject</span>(err)</span><br><span class="line">            resolver.<span class="title function_">resolve</span>(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 run 执行</span></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="title function_">split</span>(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    .<span class="title function_">map</span>(<span class="title function_">find</span>(<span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">includes</span>(<span class="string">&#x27;version&#x27;</span>)))</span><br><span class="line">    .<span class="title function_">run</span>().<span class="title function_">listen</span>(&#123;</span><br><span class="line">        <span class="attr">onRejected</span>: <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        	<span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onResolved</span>: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        	<span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Pointed-函子"><a href="#Pointed-函子" class="headerlink" title="Pointed 函子"></a><code>Pointed</code> 函子</h1><ul>
<li><code>Pointed</code> 函子是实现了 <code>of</code> 静态方法的函子</li>
<li><code>of</code> 方法是为了避免使用 <code>new</code> 来创建对象，更深层的含义是 <code>of</code> 方法用来把值放到上下文 <code>Context</code>（把值放到容器中，使用 <code>map</code> 来处理值）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Container</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Contanier</span>.<span class="title function_">of</span>(<span class="number">2</span>)</span><br><span class="line">	.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Monad（单子）"><a href="#Monad（单子）" class="headerlink" title="Monad（单子）"></a><code>Monad</code>（单子）</h1><p>在使用 <code>IO</code> 函子的时候，如果我们写出如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> readFile = <span class="keyword">function</span> (<span class="params">filename</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">IO</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> fs.<span class="title function_">readFileSync</span>(filename, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> print = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">IO</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IO(IO(x))</span></span><br><span class="line"><span class="keyword">let</span> cat = fp.<span class="title function_">flowRight</span>(print, readFile)</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">cat</span>(<span class="string">&#x27;package.json&#x27;</span>).<span class="title function_">_value</span>().<span class="title function_">_value</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Monad</code> 函子是可以变扁的 <code>Pointed</code> 函子，<code>IO(IO(x))</code></li>
<li>一个函子如果具有 <code>join</code> 和 <code>of</code> 两个方法并遵守一些定律就是一个 <code>Monad</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="comment">// IO Monad</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IO</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">of</span> (x) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">IO</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> x</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">constructor</span> (fn) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">_value</span> = fn</span><br><span class="line">    &#125;</span><br><span class="line">    map (fn) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">IO</span>(fp.<span class="title function_">flowRight</span>(fn, <span class="variable language_">this</span>.<span class="property">_value</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    join () &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_value</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    flatMap (fn) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">map</span>(fn).<span class="title function_">join</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">readFile</span>(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">        .<span class="title function_">map</span>(fp.<span class="property">toUpper</span>)</span><br><span class="line">        .<span class="title function_">flatMap</span>(print)</span><br><span class="line">        .<span class="title function_">join</span>()</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html">函数式编程指北</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html"><code>Pointfree</code> 编程风格指南</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/monad.html">图解 <code>Monad</code></a></li>
<li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html"><code>Functors, Applicatives, And Monads In Pictures</code></a></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程范式（三）函数式编程基础</title>
    <url>/2021/03/77d4da014ad4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="lodash"><a href="#lodash" class="headerlink" title="lodash"></a><code>lodash</code></h1><p>一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法</p>
<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><ul>
<li><strong>相同的输入永远会得到相同的输出</strong>，而且没有任何可观察的副作用<ul>
<li>纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，<code>y = f(x)</code></li>
</ul>
</li>
<li>数组的 <code>slice</code> 和 <code>splice</code> 分别是：纯函数和不纯的函数<ul>
<li><code>slice</code> 返回数组中的指定部分，不会改变原数组</li>
<li><code>splice</code> 对数组进行操作返回该数组，会改变原数组</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// 纯函数</span></span><br><span class="line">numbers.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">numbers.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">numbers.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line"><span class="comment">// 不纯的函数</span></span><br><span class="line">numbers.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">numbers.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; [4, 5]</span></span><br><span class="line">numbers.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// =&gt; []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）</li>
<li>我们可以把一个函数的执行结果交给另一个函数去处理</li>
</ul>
<p>纯函数的好处</p>
<ul>
<li>可缓存<ul>
<li>因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span> (r) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * r * r</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getAreaWithMemory = _.<span class="title function_">memoize</span>(getArea)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getAreaWithMemory</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p><em><code>注：当第一次输入getAreaWithMemory(4)时，会执行函数并将结果进行缓存，当再次输入相同值时会直接从缓存中读取该数据</code></em></p>
<ul>
<li>自己模拟一个 <code>memoize</code> 函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memoize</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span> (f) &#123;</span><br><span class="line">	<span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> arg_str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">        cache[arg_str] = cache[arg_str] || f.<span class="title function_">apply</span>(f, <span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> cache[arg_str]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><code>注：以函数f的参数作为cache的键，以其对应的运行结果作为值进行缓存，当下次输入相同参数时会直接从缓存中取值</code></em></p>
<ul>
<li>可测试<ul>
<li>纯函数让测试更方便</li>
</ul>
</li>
<li>并行处理<ul>
<li>在多线程环境下并行操作共享的内存数据很可能会出现意外情况</li>
<li>纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数 (Web Worker)</li>
</ul>
</li>
</ul>
<p>副作用</p>
<ul>
<li>纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不纯的</span></span><br><span class="line"><span class="keyword">let</span> mini = <span class="number">18</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAge</span> (age) &#123;</span><br><span class="line">    <span class="keyword">return</span> age &gt;= mini</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 纯的(有硬编码，可以通过柯里化解决)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAge</span> (age) &#123;</span><br><span class="line">    <span class="keyword">let</span> mini = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> age &gt;= mini</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><code>注：对函数外部的变量有引用导致函数不纯</code></em></p>
<p>副作用让一个函数变的不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部 的状态就无法保证输出相同，就会带来副作用。</p>
<p>副作用来源：</p>
<ul>
<li>配置文件</li>
<li>数据库</li>
<li>获取用户的输入</li>
</ul>
<p>所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。</p>
<h1 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h1><p><code>Haskell Brooks Curry</code></p>
<p>可以使用柯里化解决上一个案例中硬编码的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkAge</span> (age) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> age &gt;= min</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 普通纯函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAge</span> (min, age) &#123;</span><br><span class="line">	<span class="keyword">return</span> age &gt;= min</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkAge</span>(<span class="number">18</span>, <span class="number">24</span>)</span><br><span class="line"><span class="title function_">checkAge</span>(<span class="number">18</span>, <span class="number">20</span>)</span><br><span class="line"><span class="title function_">checkAge</span>(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkAge</span> (min) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">age</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> age &gt;= min</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6 写法</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">checkAge</span> = min =&gt; (<span class="function"><span class="params">age</span> =&gt;</span> age &gt;= min)</span><br><span class="line"><span class="keyword">let</span> checkAge18 = <span class="title function_">checkAge</span>(<span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> checkAge20 = <span class="title function_">checkAge</span>(<span class="number">20</span>)</span><br><span class="line"><span class="title function_">checkAge18</span>(<span class="number">24</span>)</span><br><span class="line"><span class="title function_">checkAge18</span>(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p><em><code>注：此处通过函数的柯里化，先传递部分参数（例：min=18），返回新的函数checkAge(18)，新生成的函数不需要传入min，只需要传入剩余参数age即可得到对应结果</code></em></p>
<ul>
<li>柯里化 (<code>Currying</code>)<ul>
<li>当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）</li>
<li>然后返回一个新的函数接收剩余的参数，返回结果</li>
</ul>
</li>
<li><code>lodash</code> 中的柯里化函数<ul>
<li><code>_.curry(func)</code><ul>
<li>功能：创建一个函数，该函数接收一个或多个 <code>func</code> 的参数，如果 <code>func</code> 所需要的参数都被提 供则执行 <code>func</code> 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。</li>
<li>参数：需要柯里化的函数</li>
<li>返回值：柯里化后的函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="comment">// 要柯里化的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span> (a, b, c) &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 柯里化后的函数</span></span><br><span class="line"><span class="keyword">let</span> curried = _.<span class="title function_">curry</span>(getSum)</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="title function_">curried</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="title function_">curried</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="title function_">curried</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>案例</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> match = _.<span class="title function_">curry</span>(<span class="keyword">function</span> (<span class="params">reg, str</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> str.<span class="title function_">match</span>(reg)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> haveSpace = <span class="title function_">match</span>(<span class="regexp">/\s+/g</span>)</span><br><span class="line"><span class="keyword">const</span> haveNumber = <span class="title function_">match</span>(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">haveSpace</span>(<span class="string">&#x27;hello world&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">haveNumber</span>(<span class="string">&#x27;25$&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> filter = _.<span class="title function_">curry</span>(<span class="keyword">function</span> (<span class="params">func, array</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> array.<span class="title function_">filter</span>(func)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">filter</span>(haveSpace, [<span class="string">&#x27;John Connor&#x27;</span>, <span class="string">&#x27;John_Donne&#x27;</span>]))</span><br><span class="line"><span class="keyword">const</span> findSpace = <span class="title function_">filter</span>(haveSpace)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">findSpace</span>([<span class="string">&#x27;John Connor&#x27;</span>, <span class="string">&#x27;John_Donne&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<ul>
<li>模拟 <code>_.curry()</code> 的实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span> (func) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curriedFn</span> (...args) &#123;</span><br><span class="line">    	<span class="comment">// 判断实参和形参的个数</span></span><br><span class="line">        <span class="keyword">if</span> (args.<span class="property">length</span> &lt; func.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">curriedFn</span>(...args.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实参和形参个数相同，调用 func，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">func</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>总结<ul>
<li>柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数</li>
<li>这是一种对函数参数的’缓存’</li>
<li>让函数变的更灵活，让函数的粒度更小</li>
<li>可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能</li>
</ul>
</li>
</ul>
<h1 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h1><ul>
<li>纯函数和柯里化很容易写出洋葱代码 <code>h(g(f(x)))</code><ul>
<li>例：获取数组的最后一个元素再转换成大写字母 <code>_.toUpper(_.first(_.reverse(array)))</code></li>
</ul>
</li>
</ul>
<p><em><code>注：洋葱代码可读性差，且不易于调试代码，要避免出现洋葱代码</code></em></p>
<ul>
<li><p>函数组合可以让我们把细粒度的函数重新组合生成一个新的函数</p>
</li>
<li><p>管道</p>
<ul>
<li>下面这张图表示程序中使用函数处理数据的过程，给 <code>fn</code> 函数输入参数 <code>a</code>，返回结果 <code>b</code>。可以想想 <code>a</code> 数据 通过一个管道得到了 <code>b</code> 数据。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60d30877844ef46bb23cc1a0.png"></p>
<ul>
<li>当 <code>fn</code> 函数比较复杂的时候，我们可以把函数 <code>fn</code> 拆分成多个小函数，此时多了中间运算过程产生的 <code>m</code> 和 <code>n</code>。</li>
<li>下面这张图中可以想象成把 <code>fn</code> 这个管道拆分成了3个管道 <code>f1</code>, <code>f2</code>, <code>f3</code>，数据 <code>a</code> 通过管道 <code>f3</code> 得到结果 <code>m</code>，<code>m</code> 再通过管道 <code>f2</code> 得到结果 <code>n</code>，<code>n</code> 通过管道 <code>f1</code> 得到最终结果 <code>b</code></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/60d30889844ef46bb23d12a0.png"></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn = <span class="title function_">compose</span>(f1, f2, f3)</span><br><span class="line">b = <span class="title function_">fn</span>(a)</span><br></pre></td></tr></table></figure>

<ul>
<li>函数组合 (<code>compose</code>)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间 过程的函数合并成一个函数<ul>
<li>函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终 结果</li>
<li><strong>函数组合默认是从右到左执行</strong></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组合函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span> (f, g) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title function_">f</span>(<span class="title function_">g</span>(x))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">first</span> (arr) &#123;</span><br><span class="line">	<span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span> (arr) &#123;</span><br><span class="line">	<span class="keyword">return</span> arr.<span class="title function_">reverse</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从右到左运行</span></span><br><span class="line"><span class="keyword">let</span> last = <span class="title function_">compose</span>(first, reverse)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">last</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lodash</code> 中组合函数 <code>flow()</code> 或者 <code>flowRight()</code>，他们都可以组合多个函数<ul>
<li><code>flow()</code> 是从左到右运行</li>
<li><code>flowRight()</code> 是从右到左运行</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">toUpper</span> = s =&gt; s.<span class="title function_">toUpperCase</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reverse</span> = arr =&gt; arr.<span class="title function_">reverse</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">first</span> = arr =&gt; arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> f = _.<span class="title function_">flowRight</span>(toUpper, first, reverse)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<ul>
<li>模拟实现 <code>lodash</code> 的 <code>flowRight</code> 方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多函数组合</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span> (...fns) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fns.<span class="title function_">reverse</span>().<span class="title function_">reduce</span>(<span class="keyword">function</span> (<span class="params">acc, fn</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="title function_">fn</span>(acc)</span><br><span class="line">        &#125;, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">compose</span> = (<span class="params">...fns</span>) =&gt; <span class="function"><span class="params">value</span> =&gt;</span> fns.<span class="title function_">reverse</span>().<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, fn</span>) =&gt;</span> <span class="title function_">fn</span>(acc), value)</span><br></pre></td></tr></table></figure>

<ul>
<li>函数的组合要满足<strong>结合律</strong> (<code>associativity</code>)：<ul>
<li>我们既可以把 <code>g</code> 和 <code>h</code> 组合，还可以把 <code>f</code> 和 <code>g</code> 组合，结果都是一样的</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结合律（associativity）</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="title function_">compose</span>(f, g, h)</span><br><span class="line"><span class="keyword">let</span> associative = <span class="title function_">compose</span>(<span class="title function_">compose</span>(f, g), h) == <span class="title function_">compose</span>(f, <span class="title function_">compose</span>(g, h))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以代码还可以像下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="comment">// const f = _.flowRight(_.toUpper, _.first, _.reverse)</span></span><br><span class="line"><span class="comment">// const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse)</span></span><br><span class="line"><span class="keyword">const</span> f = _.<span class="title function_">flowRight</span>(_.<span class="property">toUpper</span>, _.<span class="title function_">flowRight</span>(_.<span class="property">first</span>, _.<span class="property">reverse</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]))</span><br><span class="line"><span class="comment">// =&gt; THREE</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如何调试组合函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = _.<span class="title function_">flowRight</span>(_.<span class="property">toUpper</span>, _.<span class="property">first</span>, _.<span class="property">reverse</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>]))</span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> trace = _.<span class="title function_">curry</span>(<span class="function">(<span class="params">tag, v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(tag, v)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> split = _.<span class="title function_">curry</span>(<span class="function">(<span class="params">sep, str</span>) =&gt;</span> _.<span class="title function_">split</span>(str, sep))</span><br><span class="line"><span class="keyword">const</span> join = _.<span class="title function_">curry</span>(<span class="function">(<span class="params">sep, array</span>) =&gt;</span> _.<span class="title function_">join</span>(array, sep))</span><br><span class="line"><span class="keyword">const</span> map = _.<span class="title function_">curry</span>(<span class="function">(<span class="params">fn, array</span>) =&gt;</span> _.<span class="title function_">map</span>(array, fn))</span><br><span class="line"><span class="keyword">const</span> f = _.<span class="title function_">flowRight</span>(<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>), <span class="title function_">trace</span>(<span class="string">&#x27;map 之后&#x27;</span>), <span class="title function_">map</span>(_.<span class="property">toLower</span>), <span class="title function_">trace</span>(<span class="string">&#x27;split 之后&#x27;</span>), <span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>(<span class="string">&#x27;NEVER SAY DIE&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lodash/fp</code><ul>
<li><code>lodash</code> 的 <code>fp</code> 模块提供了实用的对<strong>函数式编程友好</strong>的方法</li>
<li>提供了不可变 <strong><code>auto-curried iteratee-first data-last</code></strong> 的方法</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lodash 模块</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line">_.<span class="title function_">map</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], _.<span class="property">toUpper</span>)</span><br><span class="line"><span class="comment">// =&gt; [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">_.<span class="title function_">map</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="comment">// =&gt; [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">_.<span class="title function_">split</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="comment">// lodash/fp 模块</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line">fp.<span class="title function_">map</span>(fp.<span class="property">toUpper</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">fp.<span class="title function_">map</span>(fp.<span class="property">toUpper</span>)([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line">fp.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">fp.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line"><span class="comment">// NEVER SAY DIE =&gt; never-say-die</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> f = fp.<span class="title function_">flowRight</span>(fp.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>), fp.<span class="title function_">map</span>(_.<span class="property">toLower</span>), fp.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>(<span class="string">&#x27;NEVER SAY DIE&#x27;</span>)) <span class="comment">// never-say-die</span></span><br></pre></td></tr></table></figure>

<p><em><code>注：lodash/fp中的方法都是函数优先，数据置后</code></em></p>
<h1 id="Point-Free"><a href="#Point-Free" class="headerlink" title="Point Free"></a><code>Point Free</code></h1><p>我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参 数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。</p>
<ul>
<li>不需要指明处理的数据</li>
<li><strong>只需要合成运算过程</strong></li>
<li>需要定义一些辅助的基本运算函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = fp.<span class="title function_">flowRight</span>(fp.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>), fp.<span class="title function_">map</span>(_.<span class="property">toLower</span>), fp.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>案例演示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hello World =&gt; hello_world</span></span><br><span class="line"><span class="comment">// 非 Point Free 模式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span> (word) &#123;</span><br><span class="line">	<span class="keyword">return</span> word.<span class="title function_">toLowerCase</span>().<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Point Free</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> f = fp.<span class="title function_">flowRight</span>(fp.<span class="title function_">replace</span>(<span class="regexp">/\s+/g</span>, <span class="string">&#x27;_&#x27;</span>), fp.<span class="property">toLower</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>(<span class="string">&#x27;Hello World&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Point Free 的模式，把单词中的首字母提取并转换成大写</span></span><br><span class="line"><span class="keyword">const</span> fp = <span class="built_in">require</span>(<span class="string">&#x27;lodash/fp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> firstLetterToUpper = fp.<span class="title function_">flowRight</span>(<span class="title function_">join</span>(<span class="string">&#x27;. &#x27;</span>),</span><br><span class="line">fp.<span class="title function_">map</span>(fp.<span class="title function_">flowRight</span>(fp.<span class="property">first</span>, fp.<span class="property">toUpper</span>)), <span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">firstLetterToUpper</span>(<span class="string">&#x27;world wild web&#x27;</span>))</span><br><span class="line"><span class="comment">// =&gt; W. W. W</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程范式（二）函数相关内容</title>
    <url>/2021/03/05c17dbec362/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function"><code>First-class Function</code></a></p>
<p>在 <code>JavaScript</code> 中<strong>函数就是一个普通的对象</strong> (可以通过 <code>new Function()</code> )，我们可以把函数存储到变量/ 数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过 <code>new Function(&#39;alert(1)&#39;)</code> 来构造一个新的函数。</p>
<ul>
<li><strong>函数存储在变量中</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把函数赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello First-class Function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个示例</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BlogController</span> = &#123;</span><br><span class="line">    index (posts) &#123; <span class="keyword">return</span> <span class="title class_">Views</span>.<span class="title function_">index</span>(posts) &#125;,</span><br><span class="line">    show (post) &#123; <span class="keyword">return</span> <span class="title class_">Views</span>.<span class="title function_">show</span>(post) &#125;,</span><br><span class="line">    create (attrs) &#123; <span class="keyword">return</span> <span class="title class_">Db</span>.<span class="title function_">create</span>(attrs) &#125;,</span><br><span class="line">    update (post, attrs) &#123; <span class="keyword">return</span> <span class="title class_">Db</span>.<span class="title function_">update</span>(post, attrs) &#125;,</span><br><span class="line">    destroy (post) &#123; <span class="keyword">return</span> <span class="title class_">Db</span>.<span class="title function_">destroy</span>(post) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BlogController</span> = &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="title class_">Views</span>.<span class="property">index</span>,</span><br><span class="line">    <span class="attr">show</span>: <span class="title class_">Views</span>.<span class="property">show</span>,</span><br><span class="line">    <span class="attr">create</span>: <span class="title class_">Db</span>.<span class="property">create</span>,</span><br><span class="line">    <span class="attr">update</span>: <span class="title class_">Db</span>.<span class="property">update</span>,</span><br><span class="line">    <span class="attr">destroy</span>: <span class="title class_">Db</span>.<span class="property">destroy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><code>注：此处优化后将一个函数（方法）直接赋值给另一个函数（方法），可以明显优化代码，提高可读性</code></em></p>
<ul>
<li><strong>函数作为参数（高阶函数）</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEach</span> (array, fn) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="title function_">fn</span>(array[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span> (array, fn) &#123;</span><br><span class="line">	<span class="keyword">let</span> results = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="title function_">fn</span>(array[i])) &#123;</span><br><span class="line">			results.<span class="title function_">push</span>(array[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>函数作为返回值（高阶函数）</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// once</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">once</span> (fn) &#123;</span><br><span class="line">	<span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!done) &#123;</span><br><span class="line">			done = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>什么是高阶函数</p>
<ul>
<li>高阶函数 (<code>Higher-order function</code>)<ul>
<li>可以把函数作为参数传递给另一个函数</li>
<li>可以把函数作为另一个函数的返回结果</li>
</ul>
</li>
<li>函数作为参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEach</span> (array, fn) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="title function_">fn</span>(array[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span> (array, fn) &#123;</span><br><span class="line">	<span class="keyword">let</span> results = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="title function_">fn</span>(array[i])) &#123;</span><br><span class="line">			results.<span class="title function_">push</span>(array[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数作为返回值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeFn</span> () &#123;</span><br><span class="line">    <span class="keyword">let</span> msg = <span class="string">&#x27;Hello function&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="title function_">makeFn</span>()</span><br><span class="line"><span class="title function_">fn</span>() <span class="comment">// Hello function</span></span><br><span class="line"><span class="comment">// once</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">once</span> (fn) &#123;</span><br><span class="line">	<span class="keyword">let</span> done = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!done) &#123;</span><br><span class="line">			done = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次支付</span></span><br><span class="line"><span class="keyword">let</span> pay = <span class="title function_">once</span>(<span class="keyword">function</span> (<span class="params">money</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`支付：<span class="subst">$&#123;money&#125;</span> RMB`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 只会支付一次</span></span><br><span class="line"><span class="title function_">pay</span>(<span class="number">5</span>) <span class="comment">// 支付：5 RMB</span></span><br><span class="line"><span class="title function_">pay</span>(<span class="number">5</span>)</span><br><span class="line"><span class="title function_">pay</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>使用高阶函数的意义</p>
<ul>
<li>抽象可以帮我们屏蔽细节，只需要关注于我们的目标</li>
<li>高阶函数是用来抽象通用的问题</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面向过程的方式</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 高阶函数方式</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="title function_">forEach</span>(array, <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">filter</span>(array, <span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> item % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>常用的高阶函数</p>
<ul>
<li><code>forEach</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">forEach</span> = (<span class="params">array, fn</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="title function_">fn</span>(array[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>map</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">map</span> = (<span class="params">array, fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> results = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">    	results.<span class="title function_">push</span>(<span class="title function_">fn</span>(value))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>filter</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">filter</span> = (<span class="params">array, fn</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> results = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="title function_">fn</span>(array[i])) &#123;</span><br><span class="line">			results.<span class="title function_">push</span>(array[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>every</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">every</span> = (<span class="params">array, fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">        result = <span class="title function_">fn</span>(value)</span><br><span class="line">    	<span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        	<span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>some</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">some</span> = (<span class="params">array, fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> array) &#123;</span><br><span class="line">        result = <span class="title function_">fn</span>(value)</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        	<span class="keyword">break</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>find</code>/<code>findIndex</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">find</span> = (<span class="params">array, fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="title function_">fn</span>(array[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> array[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">findIndex</span> = (<span class="params">array, fn</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.<span class="property">length</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="title function_">fn</span>(array[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>reduce</code></p>
</li>
<li><p><code>sort</code></p>
</li>
<li><p>……</p>
</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ul>
<li><p>闭包 (<code>Closure</code>)：函数和其周围的状态(词法环境)的引用捆绑在一起形成闭包。</p>
<ul>
<li>可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员</li>
</ul>
</li>
<li><p>闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，<strong>但是堆上的作用域成员因为被外部引用不能释放</strong>，因此内部函数依然可以访问外部函数的成员</p>
</li>
<li><p>案例</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成计算数字的多少次幂的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makePower</span> (power) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(x, power)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> power2 = <span class="title function_">makePower</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> power3 = <span class="title function_">makePower</span>(<span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">power2</span>(<span class="number">4</span>)) <span class="comment">// 16</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">power3</span>(<span class="number">4</span>)) <span class="comment">// 64</span></span><br><span class="line"><span class="comment">// 第一个数是基本工资，第二个数是绩效工资</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeSalary</span> (x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">y</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> salaryLevel1 = <span class="title function_">makeSalary</span>(<span class="number">1500</span>)</span><br><span class="line"><span class="keyword">let</span> salaryLevel2 = <span class="title function_">makeSalary</span>(<span class="number">2500</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">salaryLevel1</span>(<span class="number">2000</span>)) <span class="comment">// 3500</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">salaryLevel2</span>(<span class="number">3000</span>)) <span class="comment">// 5500</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程范式（一）认识函数式编程</title>
    <url>/2021/03/e47193adce2d/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="函数式编程的好处"><a href="#函数式编程的好处" class="headerlink" title="函数式编程的好处"></a>函数式编程的好处</h1><p>函数式编程是非常古老的一个概念，早于第一台计算机的诞生，<a href="https://zhuanlan.zhihu.com/p/24648375?refer=marisa">函数式编程的历史</a>。 为什么现在还要学函数式编程？</p>
<ul>
<li><p>函数式编程是随着 <code>React</code> 的流行受到越来越多的关注</p>
</li>
<li><p><code>Vue3</code>也开始拥抱函数式编程</p>
</li>
<li><p>函数式编程可以抛弃<code>this</code></p>
</li>
<li><p>打包过程中可以更好的利用 <code>tree shaking</code> 过滤无用代码</p>
</li>
<li><p>方便测试、方便并行处理</p>
</li>
<li><p>函数式编程开发库：<code>lodash</code>、<code>underscore</code>、<code>ramda</code></p>
</li>
</ul>
<h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><p>函数式编程(<code>Functional Programming</code>, <code>FP</code>)，<code>FP</code> 是编程范式(思想+实现的方式)之一，编程范式还有面向过程编程、面向对象编程。</p>
<ul>
<li>面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系</li>
<li>函数式编程的思维方式：把现实世界的事物和事物之间的<strong>联系</strong>抽象到程序世界（对运算过程进行抽象）<ul>
<li>程序的本质：根据输入通过某种运算获得相应的输出</li>
<li><code>x -&gt; f(联系、映射) -&gt; y</code>，<code>y=f(x)</code></li>
<li>函数式编程中的函数指的不是程序中的函数(方法)，而是数学中的函数即映射关系，例如：<code>y = sin(x)</code>，<code>x</code>和<code>y</code>的关系</li>
<li><strong>相同的输入始终要得到相同的输出</strong>(纯函数)</li>
<li>函数式编程用来描述数据(函数)之间的映射</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非函数式</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> sum = num1 + num2</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (n1, n2) &#123;</span><br><span class="line">	<span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum)</span><br></pre></td></tr></table></figure>

<p><em><code>注：函数式编程只需要考虑输入输出，不需要考虑执行过程,如上案例所示，只需要考虑传入的参数n1和n2即可拿到结果，不需要考虑函数内部是如何实现的</code></em></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2021/03/d68cc2550020/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="e477ade3bc25a25a70fa64fd3f28c27b08c29be254307b9efdd03505250b864f">a699756f642203f714ca82f1e29f1c2c269163cab1d0ee04f9b8daa49c1dbbc14b40c2d835ecdfde7389da12e73e832203a5e09cbda9a65079170df7db8493afc711c68a9b246a731208b5fa8dfa5af8abf26e14f1c3e0211904ad82b47f3d1442ecd8e9cd74eae5b20345d6ae8e5aee0e791c954998157c22e25412b2881188bc64eebe1078175b47b48a2b98653e384344372398adf0aac47e03b105d89302c3f3cce8f024a1c25401456be007057de3189b487228bedd0e6cedcae53452f3ff9c64d1c73d3ec224e8836102c27f44d8822615fc370531e67e4b87392ee908baef2e188e6145257abdef918f11e83133f29c62c0a408588573ed7526a9827f30e93047ffb266cb1dc176284b7d0e916e16394d7fcb5ef729c15553ec339600391250f8dded4cbaf2195ea815210bc1bfec5f2387dfe76542d53973df1dcf7e54171635df09a7f4df0540fd6f445d41d6578cb8810a42cfca2318373a3ea47b92e16182ff84345296c3b3ddeb92bb9048fe442218827593f1637bf40903e034f62cce3417a3c10c1817270ce6412fe68f31522c91fee53bfa8660c3a771b6bebe466eb945971d88e4c71e9b3a6e6d89d1c1123a591e36ce9b007287ce89cbcc69ecbf20380c2fb234e8589ddedbd4ac28ec6f32d82ccc31779af9ee9c48a1d286806d2f9154d871c03f6c9b874ba6cc6c8c3728226306f5b7cf0c951caf32cb2dfd901c484fd8b33741a840f70ffd5982268b16f6c629acf7afeb7114c17e3832281a4712e96ae4a48afe17fc4163c4c223181bd159be82c36f79511d707a644b9cf60f5b27a38f4b09929de9dadf97d0b61939bba8841229be894c261eadab7987de2dd9e76ce704eef3794c46890050e070bc315a1ff71538b2d8281e67b2b98950903d455d1eabd7313432e2c2bae47979eea61bb51dcd98ffa39fe1551aef926f7cd15f88fa6adfd6c377073f71a63ea23f6cdd8cef305c5b45c6ec85fdd04e1b83cbbdd45bd0534a7966d6a7b8dad76a5b0cbd65fda31399b20e327f61a38ffc73b2d805cf38e8247ad35e7724f439dacab4aa150011daf25f515f788abaca5940e9e7a8e48cfbd08f9d0aca6a045c17fc6c19bfb67539a45dfd452bc8cb7de8610c657097954ccc0e94ff56952e5ec508ef0320781c7b820fd85ac22a67fdba65602784f296331a29456416ce858e7b3b48241cac74bfbc52bc142eb5491a8a27ce06150420ba3cc81f687fe5f7c036bcf69cca6f094f71b491fc9cd7bad80997fd3e4929588082477b993555f98cad3ec82844940ff0112ddab6073ad2bdd334e84a37cab0f442d5877afffa7c696517c0e93cc99488afa5140ac64e60cd19b22660a948d1ae8aed2f15278784c8aafa1646db5f26378646ec34ba9aa6683edefbcb28d2a88d6eb243d0d305ef0d276ab89cbab5beea09180ce801f64f5b20e73be2561dec3e06ee437c70ac79f817adc037bd6ce068d5045af58f6495b51f5a42933f3e8d62889a5141511f08ca5a5f43a8a2d17153b73745ab13a4f5319ecc647723be7652151b88d1ccbde7a22780642af3738eaeef01b2d1e23d44284ed039c724efdf07a0a630f530129d46427adb89981a492d8a760221b1974dda71f5eb27cbd7bdf0d1bb46754100497062a48de368e8a8401ed3b77803e590ca1aa2432ef9e6949837a223e7a86c0a0b8df16b2591f6b62e821a940e7a9a48b21376974a4c56216d72e73b033254bc1bf9957d535ad91dde0132b9d0f17cb32c5cabf268d74bac09be699e8ac0fcdb740913e05c33cf644378380c25f88318802a545986e6200027825b6bc1d03a3ac333825a6e4a27e24ad2fd228013bfff670c55f0bcd868df07a43bd8ba7432392f1216a93362640331418737f7e58c61c3b98f3dd455a997873b1ff16f6a0490fd54429d279e91af6194c794ade321ddf9b6fab75e551e4744c96b2b1337b7c75cb3cb54ea4ccf00ff7cfa3444865d911d5088e683306d3890ffbef5709f230fc006bc79cc4cdf4231f7a2f27ea7e0ed3239933c1d786a75719a7ce25c0e7068afcba735951071d1771c4580bec20dc959683f6cd6a8bab87291899da6d187728d241f546ce48bbfd108599438e9a02119fa3cf275af1aa1ed222c8ca6660aeaca513815e5360c4c771ee7ef9810d809b89018f3428d9851c585c1bb787df20c5f3556686c913a33cafef3e730c17dce5ca2f579ae100c5a2920cf4b8f8052257454fca24b04c9c850e5962266c67af501dbe8484f75cac3e6beb3eebcdb9b334e54ddfcf8e9666653f0d76ab0bd23d353a24ba26b5a7155b33797c3b03a3c8e56630b12e6d7e35a913c13b19aa9e04a76f9adc43bb79df0a251e731835b9fc1742f3acfeaff160c97ab645543e1c143f7ab72fca60ea56ab70fcac832f3b528397929e1dd56955a79d69f6cccd6708c3bea1ce72a48b7029d517faf7966c2acda128c5771c04a5be9a72203af436a35ab3aee22a02216c726428837576ba2ed14f8bcb3aebdd1dd03be253c54aad5a1def8901090f92f3770c33a8a9e274cf0902cb53b4e9286629d90d41461d9cd8091648ee866313e2103b98f3f6e04c061fa85fbb5f072bc3d3817a4ddca4ba6bc1c58e722946d470663ff71d82f33a1611a96f7939d6a086f910ff65f41b94829317800357a5e5684f253a18f8886813d60d578ce07a1e62dd8da417571a3920151914a855f8839eaa789f4c9862b6d8c09d4ca99dedfd648365425c21b2287a23272ed39e1600b14ae0b3d64bc8433d31596e3faddc5fef0286ec740f446289000f6337a46b55ba319d75c735555f2f78be46b83d86883268123daaea4b32f87376a8a44c5282a8980185ceecb94b1adce130b69d0f20166d2b92aef0e4703f78b1cc28cdd70dd216b0471023a378f95dad3ed777f17eb7e67ee3860c2654d530fa423a27de268fc7f7f98e6fde0fd2cf5da793f5d77034916e5daf12c4ab9e475d876472e6e3285b7a0835d4629511835738ca034b56b0f1259a14c0f329ff1711083d8df5000b83d89c3ec38594974482360ee564d2a32859e654d618758feb30f6ef3a895ca8712b3c89920c35b12b3fd80e88a4ca2e5f786e46ac0901489f7c6d1036b8089c0e984df8fb72ed7f7c18dd8cbea3601e0b927e824a0943d4aad6430a5719fc4fc1cdb7ffe399f685e80d3f47d3f027d91722dbfe05a21937d524219dba72f2e30cb7ca6ddc50e25ebc795d767baedad1aab9ce84d7226fbf1b67fdc498bef0edade0a93aa0b84cc4f666e565a9d35af149489d3045e469ecfc64f8663896e2574c86719dc8f15d27fec8df8c966019b345abece61c74ceb08b382869f4f34a615f1ed3bea4c484c14c5087f736f3b5892cdd474a61a4f459c90ae02e58747daddd13aa711becfbb7363b8195781d64b4f88f796b776582385e038dfa2e10aaac67b190777f859845359753966d587bf59bb62e9e675e9cf7781743440a2c53668786c4f103db7b0f6a1eb7a9a1af21bce6d3587dc4c838c0354ae6e4c098cc252d16bf1f93aaac50e0d9f9b62fa9963807f28986bbb5ac1a3dee8717202953d28129f41577f2aae64a2bb9749650d2feff74010d565da4d86bb68fdb7ca5d5e9fb48250304b2bd1f1203e160d9831d8ffefcbab9c5fb6f5780bf1c62f8ffe5fd71550512d3e2bdaa073469bc33a918432ca3a1808c146c43bf00f36a7b0418f7fe41c62f3dcad35e2411a6c0797beb20ddaaf4d153c22697e0daf2f47d07e576c8ceae419dde5ef9313c0abb6af7b9635c29eb8e92b0a359a24fbdb0bc50f8c6e53412157873afca111fe2ef540f2e3ffa73ad63384ab027e1b6f6b015e176a7f39ddba2d3bcf113e65daa31850c10b1619b496954b5bdc4f553c2c6dc311a0c114cd716d281ac5a504ebc3b6b23606fcbde7ff5993127e6a4e1d9ed2bf2ed4c58e8492eeb36c19de514e4eb91fbf2c2f16ceb37a8dc04e0493c757cd1a0ac28c9754a8e471e2b7776f6ab8d6a9c21ba17727ad2f6364ff85abda2583bff5dc7c4afa3edd716110ad6566a797e43386818e2e7acf3e3fa04d358850c37558c3620912202a94e9ae89b9109945e0278e7208af9de7c0bfa75476b5c79302a623b27db27036033c73ac4eed0585bd96a7fcf8a4c774d7d1ecec05b4e0049a5201615008a614a1fcc4b33ecb76afcfbe14701620a635afc66978ca42623f52f0db47a82e0b2cecb6842cfebeeaa62aaa6f8e70d8c7340ea902d8cdfeff59f8e93e3cf8e9a38e341cde8d68ef748928bba31c7165c30e449405a6e113217c4640392e3dd29e7ce4745a049f28ce59179072f9f266352f370299049338775b3d73f505d39cd17058688fb56e1b8fa36abe3d2c8ab064fcc7ae2c36a5ff42b0c2373d2853ffb250f70775a8f6d6696e2b0186700ec649fa74307486ddaa7ccaa25e0e8c0d8833405bc7e5a69b26fdc0da28ffc2c86e9c23bbd25740933a04df41b80191eb28d6dcd920ef576edccdfd530b63c25dd4aed2d40ba7ebf95440a34fff9bbdcf6a596f7571ef05f3b360356f8f392fcd04e1a69b15dcfa7e3c34779dc30622ced153e84202271d5fbfa1faacfc9951aeeff619f8d04f1579ecc326a6d42e78f4eafa14c2618f247d340114eb0482e2a7d629b8be14364c3f0de9ce53edf31626f1c47e43d1938721ce60c265468a2b1f757ab9b12c8c0bae3deaf8efec554d95e59cc126ae06fe4f8c2ceda8298d711b909f47d773d25e0879c8bb2af277bfa316a1f1119d05adea7522af3715ba8ffb08d0c339d1b83c4f1a050830502f7bf6ea234aa10dceba61e60edd4bc2c4533067d16ec931bb400a6462cac8da783312a2d494de0dc99b7d37e4160710dca2e26868f34cd7705796653b4f6073558e4f9d63a74184d25a399b399c656c364fb9de50d1f59424756e2e67eb63be28cd60c589d9d42fc20876db3914105be0f66e54718f17139491b75e8ae179c992e16aaf6bf95f5924d75c8008587e6881c3d644a3c476efa000120eae69f3122bbd34c1ff2eeb251cb7bdc083c9d15dc4ad6b52847b0782a819201ca467c9084f09170991942ad0f7a9c88fd15f9176cdcc4e0558310d81df67c00f1a445b29d5e060432aef07d2978db2a65821ae8f72d2bcda3d07c3e23ec03d9945e8361bec156eb59f2ed6c28b9553cba62995fa9cdf0ad9fab968d2f7242bb747f66a97d1a5ac39fbee93beca468c503e7b617a5c0341ebb73b6ff9391955aae6fd9550649f53097481d52cba6734c89b631e021809141e671fbe47e54484fe2b4e01e401f328315d68a5bfc59824455278f228e7f47fb54f992f3ce188b8e20ab84e8587c6f0f0bdcf8931c60a2c5a2aa006415f4319b96cca4b4eee648f63f12f185a20e0173f896cae817a2e829e12df54b902cfdae44023a549e654eea2d9f35ec66d983c9616a33f8475a9732b04b15573fbdef9583faee5d74181c6fb594e5f2d44376cd0dbec3f3f4237f268e40831adc380a09f0fc7a9ff5503ca311ad0b680cdd65f216f32fdf70664059be35bb6a32926a3322c4d04df47576c730abfa384ceb42a53daa836397780d5eb3272c8f5789a735924aef7d38275cc9fa90aa7e6b495422824cc532802c52dfd3ce97384f2ead1c312bf08147584b44dfa82cb40bdf3b841cbe8b5704cf287d622c72e6ac3fdd5217714168799065394ced61483500fbc4d2af67d2ae08f8713b0e06a374021d202e4fd20d724ed58713d2ab4b08dc170c8dab6f2d94d428096a063f072cadc3f0c9ad6d0b6097cc41810af7df6c97e3c5460622f4f55f2a68f0c4170b36f74dd9bbf668db2cdd5569da85cecec5a09364632f61daf9d32b085885a532d6c43095acfded3940ba0c6ebf784848e87d22ccfcf887918db102441f3e4f0424484c4f6e60dbf4235be57a811cdecd3213d5cef3569ed7b5e18d9ddb6fba6321849f36a41d53e5024eb6893f3c2cf76d5d38ab6d6770670e0a08b0f98978f8a1fbac2fd23d19f5dc781f38c510128158fd1ad3077e5275356330b4c0fe43898ca3ea245876736e35099e41293bb9071e14185f622bed32b8a1876da4d84b8d79ee2e039eb22d90d6aff49d731f442bdfa43abd49d48be9a13ea5bbee9db4a610efedfc79be9874d42722bc469e5d58980ad450ba06f49343cbb65102d017a120d0adec1cdb2629c41eda53b4a8dc7183f016661b200d000f17702b2057ab4ddd8ca9dd07d8ba5091607584bff85cdec13f54c6958e2296dde3b0d9379889636409d9266e8c2e5ac85ca7f0a283dbf157dffcec67f8ab16df613e5b838c7aaf2fb42d719ce2486b0ed72248a2dd88b37000b42a5d9024f512e6f319c09d36474b8404fd98ed59f90b449cc0a0baa74b2e9c59fb263da01bc64050e8219f2c864995319868b719c299971b0cd23bdd21d7cf0e773410334b72c0aeba1bc7021529388cbba5ce22b9862fb0c0f23465458831a37aef71bf7d5a847a2f79e4ddd975dabb692d8a8010dbaf1ce1e159c9045495dcb8fa2bea5366ca1711a7027060562fa1b3f76e3c458e051fca69f9b499e4bb949155c247f3072d0f6055d50414893771fb42d6941c48f2b24403f4ba0aee2439d5d594db7aea8edb8b3f87a6fd3b3e59465d5be858f8eeea3c979d76c89af1bb61c2d8b5e2533e3e87d1cdb900c0cd17bba0135f7d408cdc145986185dce4a6531a7b12eaa53f3a94eeacb0f016b561cb3521479dca0c866610edda8cccfaab9c8694ebdc12c336cd33929b1654e81080204f964341b68866272e28417f21fa0632648cc58123976ee678583355b2b9b858a76cff62d2d7d5104069de20d343a867babaf5dbf99c2b29838dc4a7b0dcaec6a449211f599f3b6053c67b7b82ffe3028b9c5b7108e5e518296de917d9ee7aff09c417360f7a1ab0fe2ed934aba69c9ed12f704d12c01b0790f359af23b4d78f3d17d6c441c5cf8eadce757f8a7d2cedf9c8c4f04e369fe2fc18653e14466ae15a69f312df69e0e25cce9226a8f6c2df5f76368a1c5df58145f3c1c7c45e9dfe824006be18370cfda660c42005819af522608c061369080e5487fcc231b0e58f8b8057dafc3494c00b0abdd2236d0203148bcb1a4dd77362b095837036443a2ebe4cf8eeda2313b19044faade581353d14c43067c34d21f9f331f8cea7dcfec5a76e75dedf51ae4a8e0bdb295a51b99d4f6815e999f8763feadf10fd459b62fb066e876249ba8686c93299b43f6b01821e1ae39c429b9d8ae1ed6a1ad5d381f790e74843012a19f746a33c13f8982cfcaef5856a5e4cf8fdc97efb53ea2623e75ad88eab7d438607619079e8cb6d267a959a0108cfbe3673aa58ac9cd779e4dc22b9f25aaa685d2e061b01c17466b49a9b1f6511c2c69e448d8034ad9c4daea3c18108888328893fcabd3dfc391d1a1d87b7aaf2826389a6b6419c0c0b33e2d64469225eb9f589985cadfa96bf07dda75748c1a9f1359079d0f64db01158f63c82aaa08a6daef2d01b2a65cbeac6b23377c1481923b96c2c73de1d9c67fcb31ad6fb877a98b78f257a81b19978ccb48ea08a24042dbb059553e62cf2a7a129b668c39239c26c5fdf6880a2c841acd08c81ddcefb1571b480e984b7c1c70234a3d213398024ded7a7ad1b404c1456b7d5afa8235ef307dd3205b9051fbf899d2220fa6766318d0b6a1d17ce09afa6809bc4b5a91a172133157e99052c308c83d31a304fb11421474dfc6ef543bf949f0453ecb3e277b36b1138b697e0ea730188cd420e2f6f59899e12b459c1d3edf491344f3de159aa9ef5bbc9babacf1737186671d63003a3e9d0790d4ad63f62c93c0d476257d1433fab40709d19fbd4c289b89bcf9e2b596afe71a3e3e4c8386b534399f30d51f000c6887a6219786bec0f6e71b8072168a3970db8d96404a9205b93a498d9b43e85005a8ed6f255c37e0d314af3ce575a688fbb02c80a1a25863db76d770f7a83b234e0e7054fe3ce1a2b2b9f2785ea78999f64cc973d2eae28776e042e4b75447c3235846bfeb4e520face68bad197e31ca5645a1758173695cfcc235bb137bbdeabc5b013755ba9c0953e30e15d04cd52102e6715b094e83a2f698ec9c50e29097147f294ab66c8de27fb258b987a3fd81076bfd87f48f37162205bca7ecd1000bdf078c5bf0281821bf8a807a3c7f73f91ba7bb6afe2880321993c1aa6896b8af4942cd667c2d6a753505bfacd5d43ca0006e28d602c60b85a68421c35d937e2f72e9f4a18ec56ef83614c02226b9126a1215dea7bb5ae42d6927e32ac95d480fe3c22712398551674e2a365593d261657722f8b92f9b0b4abc5fdaadb34725882072558ff80a6462bd12f05f373e5e63cf8ed0702b6876b193b62b4d631f2721da43d834b867d1bef3162efb15911743718e1b9cc921189a1f55a6ca0cf3ed4199655083b99cb6612177bbc229e1f7a5b36744830e19c3352808f9e686a10c3968853ab3716d198261b2dc77d538d6ae5a7388c38271e8e1470900618b44e6cf1e6f5b4b3f89cfefee09d436bbd55218ee667203b6979c707d38631f1d51cc9895d63d26dca973ac693099c29d09b2b5f86e5b15dff47097aaf320326628b68a8aaa4765060ad1e331bdc531240333763a65d6fb36669168aff3dc908a8ea58a9f2fc4c55aae47927125bf42ec3dc7b410a31a1aa3529a100e7d5875d2e15a622ac8fdadb18892b19a7875d6e78c8b9b8aeb485e3129fb5d45430b101854a490f5e5486d80a4359ba8838e9ec4616bb90e36249a613fce8bef22c3bf40a77a43ef820da0a03ff19a90ec9c2740dd03f647e38afac0e551bbded3c371a95ab0c9d7bf28d1eb42fa4a204b053e08fdfbd94fc7d6318c416fa34ded5bf8a5d262297dc49e196f32572ea6b0804f44a786b37fe15607a5b6df11481c3b9a82cdb485e05502e4f33b14f64852a17e195dc278799fed4151edb3481edb2132bbf94becf70a89d1e27b23816eaaac434420cdb504b30eb582b39c028b636b2f3d14eda638241de93109b68f1860e8e7e4a440cee001b91b8bef3be05ade843d966949fe46eb74c2f30ef1ce218c0f836f9d4321fe1787f59e7a102065243bc604ffa80a3dbdec37cd2694d1757e947f63121cae1d13ce172b719618ffecd0ff3487fee31d8e15c368c0af7c9d1a6a930cc9ab3f0bbf9d003b50bec0a2e3b5fa617325dd1a827867eb2d1b2851cb044e61c894f4ab28c652f8b7d6f11eff8e3f58bbf62a43b03261ec1983473552dda3c31576bd7ff9f531a6babd822fa53c1a445a3f9b18777a265dfd801700423ebb725d266143495afaea3130d7439bd510f3ed7ca8b6f8e381c66f14f20ae368d914e190736fd943e02ff7e314616ac4fc4c1d12349fc305ccc701c2a78c6fde1568a4b39ad6e3b8b0098e6615169e65836f3fed0a9d506aac2f9614da0af8e792611de102097e28d2e5016eeeef1ebcfd0a6b217573bfdd10b1662fe84cd9547537c014494943db570516909fb7fb79162fc7efead51f1cd22299911846420f110e5fa013571d79f4e47bd689944202398f1a4c82fad164ce67d6153e9bf3a060be85458c90756e6f9b6901de779c2b1d2e0606826c4736bece6d5578224b997cb4d7c8f89aa65019854037e122c97a06f3d20739473863b7a16fec623bebd439d270411f26a646b01933b27ddb387c3bb9dd57192eb8a12928f4bf55d1ea756f3fef330a1555341a9f6ec6b9a4146bd3b749a6aaa27fb2bc3599fb9f8bda6ff8d90e7114b24dfa331a37bb2643944c47eac40d0aab8b0b7b07d6fbbd22ed2cff029008f9a9f03271f07bc87e90ef088ba27efe2705d5feca28aa5808b1f4811bd6f68f2ebb9946359eead329068cb109aeef22431f066f527469722cb846f9bb37746dad207371f67376737ecb01a22bd1f4050b37372d4db7139457b3263224e70630d3dcdae5264f1cba47ce6edb3af1e702e2cf01f5eef00ab1e88973bbdb6a26fdc3385e9f8447d72421d9f8c79583f2836225d345c4c17bd4acebdeff445a8d6c5a200bda3375bafe21349b283d195f652db5d51750107d755ccc642ffa5d2335f2e06b104ad2b3d95f00e7a2a7600e220a54da39c50dc561906311a12216688dea69ffe28cb9dbe56c26a25d87aa15449c8ee2e6354d668abd25e5bd314fc01646e6746af3a257879a9f4e82ce5613bcecbcaed60e0d4073af5a880396bd8b0899cfd6a5b0ddffc38f58017564e3a0d2e5ad7031a24a4e29e32f1e90cb787b847ee9764257904ca95aa4b86f55bccd87325d6141853df1bccbb02dc6a73215704e064367901e68f6685fd612edfd10bb9d0a4b2780e5a9a491235f37cebc15ff69747329110b527931db89a746dacab851c035f88a35d6fb74c844e7f6ad5179e5d90a46f0502606b15506c9c5659d10f00b57cfc45a19bc81745b1913c54723e6538bb2ca4fee25710e9728b36f3b712fda763cb26b42aa24939a27a2530a036ad0ed08c778614ab8c774b38a766357cfa3a1c7d43e83e5400e63ace45969afb1e2d5e440b6bee0c02f859487ea4da60fe86928152adfd9446ef7095f6e77ce76963407c93f910dd171a45cbaa5b511ab43eababdd4c4b6605554dd03cd578b0be3dc90414afd5a047ac61760495020679d927e617a749752a99e2aa6efb038e4d19d676548974f175e7e991e8665d557364a915255d397187b45fa2adae022b0c8def920c77d0fb361cd9e91466f0b62084cedbe1ee734f53a4a45105d29b60e692a479f331815f4608d040f28fb883b96d6591647687a451b6b60260aed077223e64cd458e161b08d1d91e577f2eccb8c2dc42474a4fb8a379b71755b1c69f5f3047b7158af7393fa46d226da182381afac35f10a75df00add23dbeba7e5d33ed0c8a1422fc811dab7d5dea6bfcc315cd7f13f6048737fc31a73644c438203028a783106078c1b1ff52a330cbfd9f20521d0aa76719dd34d20a35f5711704ae5e2c3343fb00774723404e963830637c46adefcbaa4dfec4a494463ab90e8c7600b873ee088fba69ce19d9cbd5c8b4935fa995376b543f5c96022c5d6e38233f81b9cbdc4a5d20db8114605b380c3e37eb0c32869397ee23903bf9508b0e808fd92d14adb6b5c00fda65f52d955b358fe5418b0d3270b0ad3369ac0219d42ed82de20eebba054802e494e5721a27f451ce79b7f3c91285fee42a8b5553637faa8d1fc99a005ff5e3f6a64324107c047dd17503ebd979983e9dc2a3140d1b1b2571c187ea448ff42101913396cedbdef2f755537fa334a92ae6498efadc719c3afa758db7f020ba9e69a5314a2058136b70d854a1e369fabd1c82dcd26103c8878724538a5e6b8074845d8416e92653f4c109f4513f9cbc77d9351e9341fae86b4c103932591f594be34529dcbcb4f9dad45eea364b613a8853b3b5ec0a334ccf9ee1fe0264d33ddb740900e4c6bd8479f66fbbe930f5ff8f4666c94bd4e389319aa70069b8b335c685bbd478a759aaf11a82806cf278beac5e3fde64f9d174c51c3c416baaccb238ff18f549c7182c980dbcdc2c6c0acfb55f5de5701d614d25882e32303e9e1cbb30cf78e96fb1f855d1d7cef1b9ab9c98ce8d5107db96327bec31857948b164596a7b1592c3476e77eb1e0e9291be938d422ec1f4879ee2b85517b81997e50d499c8487c46b1eb9308c71bcd37ce660b4623d136bd9afb72768a5dcaed0430eb6664f3e8c97d37cbc8c1e33381bd1c03f9de5359a747d5964d3f82db803dc78dde70338d017e83a9b12242d2f781ebbe5a48ed7c8c094ea22471bbe176f9f42a38563715e4fb28e5dc08747f963741d55397e13ecc2d8a7a09d49ec0b3f81355d3893be519a9dec4e0acc0da235877342811eff1d47102226da6c4d734078f9a081d1866c41516d82e3607203c50de6c0ab10cad916ddf6639c7534b0969fe248652c8ccb6b325173ccc30446717f210f7088a2ec1a4ec5a5f507cdd650bb06e80038454a9dacc9ab460cf19261d499fd26ba228b8682af57b4f6fee717506eecd610a2e7685a16c6f58a5a4147f55034681bcde346da41f63f784dd03cf137f534a3bdb61fbb23ecd2a03883174a8495d4ec6e51ba7761dbffdc6be71f476ac16a1b0b184f83ae43adb8b101a5fbb8f662724d2b2e3f18fa4d02eda2995068a4f5f51c27de83ed98e0ee5b216807a16b16c9727a00cfab66500084d3cdaa051e350f562f19576980bc62aabc419e1acbfec50b8d33a78acc1b650526cd958feef6f9739aef4c26be633d9832cd7e9734a4dab4e80fd0c095b5dcb8185a0e3b20eea87274eea458d43460e14e2fa98cf99103226513b5c5c3e8c5369dbc514836b36eb7873cd9f688327ba1e380a89311d63e8e3eb88cbbc7e33c63f079de8b083951b6296776a61762f55cc369eeeadba337e188e3c5cf215a0a8190730f3b1289769504de154a172f0dc583a2f84c81c1cf9fca25c9a4873f17f7e013327ff9bc89714851a13f6722e28d510e0cd321c4829e9031ec1a60684f082e1e3d17fae3d50a2b01acb8159a12789f2b749b168cc83e93d9f7e4f6a328004839d5be44cf97d81089e89112aa1b24197b46ae18ccf5c1116eee5ff1206dad1b0f0cc9b9388a14ff34e9bc03d7e54fa03984b03088339b62e9ef6fa89b052a5d40d814d689c202c4fc7578e37e3effcf1b059b5b920d92a675f35b4992bf9c27287b0f1ea5185f8abe11277cd5e0286989c38f40d07289d541cbfd5a98bebbf5bb2e02ae8be96df7cee04c723dbaca909af4be28cb41a0f6d2a54be990b81b3815a4f86242141e9093e5f63772a7a7556caea271afbb8efa5e42fc4d28aa00252f2427358c769be98cf63fc6dadc17e9661ffe9c449d5ecd93c9e9bd23b7fe0922f6036e1768492513e90c10158bc135632b690fc3cbeacf0032f4db193953a228aaaf43e4946dac198cff556bbecda222c805a1e2f531292ebf4c25cdaeca24d0d58ae7caaba0b58a4ded35f64fe2cfa30ec7aafba17dd720beeb3b6c42ac1864797a63b7df8bfca598ea7e81b40e6161edb6caeceebba12289d4f80ef3611a704c1a63613ad387debf785eff8417f1cb3d867050f60c62e5a1b0aa6c735b3b751f3cfd47d874d9ed86ce5faa1a6b43d4c8138a4c7817cd460d595c3b4ed6b06e1826b8528ebafab345bcba90fe5f0d8ba771986b63ed2f13e729bbcef5fd2ead964b72de13c1ee43b4f49fab63ec427cbd040497e7a90560681b4c6480d8eaa7ac211a1cd243741b2520af358c5340cee0977ade369241ddea6f255bc24213e36790ca3ce0719c9f03181206371e7a543cbe12c2be7b48e14eb38fec2ef9baa357a0f75c2b54a6eefe8c51b0ceb2057b60b97cab7de787fda3822752b491bc695288c5c168c66257e83f9fcf125d483488df946098b14af7c08324bccf5b406380bb1db89ea809fb6dca0571689fe62d5413052cc96e8795ac918f107209b8e4b0a40ef909cb32091cf436ed1d50bbde6fc836468bf406118b49836d4302db4a6f06d1ce12923aea4b6c7614d52de82b6d013757b0782a989b3069f3f3eb3cff3eaeef58f492106d1d9b950f47fcdf00d70288ea68974020b7bc5317c92e397690b99b2bab00514db41f7ee12b4693e7ae17b10189a07c59e13b02f91e86339e89af1f6538c785c842f5e47f25b2ad6d0adfede4bbbd104c0adc0b03c86a58bcdd8fda5b45beaf42e7ed25d10ea7816bb55c4fca570873ae5b590f03344c72fedfc0f432dace41681b28f35ebdc9be468c2ea86c093e971d874fa852b77939a9f4f8d591b39e9d904fa439800198c3cc6e517e450ad6c1a6ed3e1d6c05aa543e09abe58ce7294a3ad58ff0de22079991b9ccc19701127664c46e3d0bc1016891f45132414aac395ee850f9815b942eb2a7d1ff13e232e4a897dd83115a1388480be66a89312228251a36a0d87f9ac28e7e28655af4348f594e64e8ffc0141868e2b1bc0dabe7ef29e968add7551dbb506d71220b9f1ea5b647d07a14b53516d68f5d10e290ab19246d30d1a9bf8081654b9013531cc54db0225a57a720f68b165d219b4b75ee4443d1b9fc630aa682c735f779ff6c2370ef4bb51cfb28da77e7250b0185ab8002532124998fcd476f26f27150f5c0b07a2ccb9eb5371aa66405a163fa748f673eebf6092d1eeced20c44df4fdb31feb681106f6ae2df699eb459ba8427843af1895cd38931fcc59a72b9e2a9233e9c326c25050082449ee8419f9b997c6fb1857064e59fa76020a341ddac162052382e41a2fc39aaacc96071cde2a06fed6235088a3119439f5a6feeaa10daeb3a1dad423302577b03d11b676ceda8c6beb689946bf62295e4b14e624199e65a23ab2d771bf2371e6333a2ff924fa3ee5fc8844cccfdf71f8a7c85b15c0c326fe885aa677f3f6771617af156fd7e2122a3fdfa35298170068cc7ca23cefeaa5f86b1202c7e3e5c02289071334e0b1c48f0fb26fd125e05a04588cb082b071aecaedea176a922b19b00ba5532da36ce126b8641f4fcf95695506cafa03e1cce35f07cfe7c8672f4cdedbf5adb7e7d13e48c6242d928ed22a750b9b49744bb9b0b486b7071f119d09840c314e267da12bec196dd2971264e03bba834a90f00a0f3f8016c4d6617be480d634a84d4f18b316a5fcfb76673a62abb2d6f08ccf15fc150350df235c5e744c90a65a9e78885091bddba2c0d825180d95c9958c5779fe54ad99a8f949610c13ef73658a74f2d7f8d0037e6f639d4a602de0d145a7d7318248f81b188d99bf16e4322a71b8c98938f8b6532d4e3912cbe661481e5375fa0e4bf1be61a16d373f41a0ba9cce8bf1cf26dd111d228732ee18b38570f4c3f21ca8b2bb5a025e13d5b4c4eaed46d09a7c5b5aeca980704286f69cfe7fdc09734d871a083a4eabaa47078900fdbbdf6b026983bc38d65c2f0b69fe0e27ff5b26f92f29980b9d413696c6614d251c49d4909d18a39d402bc010fbb95c6d566a0beb22d94a22eb223b60e81fac683a64470e4d87a4c6fa2f33faf3af47060da972b05f50871445459dd86707496386f1e9f82d1f350eef599f8606c46ba83bf8346a0ef96c3ce8b936d8e4c615adddfa676f22775fb781d66c7cf86333380f8435ccb59427378dc4ab4a856a0f92a4c9188c142325a61f7a00217fa2f399aa5b1201eac9d59973189cfbb87865e214bf5433c6e460abf7de5ee2d35f90d12654f10f6add5c3e29d876523a7ed1fea7a8b62998b8acbef8bec668bb585ab54c07613f0426e57618be4084849ace782b7aff521d275cfd509fa1e8d30d331df95d122799197e73e46c4b7e12c9566499122c0541532d227391e5c6219c45a47ab2d45cc71e91be16813b7d9a6551456dee5e0e084af4da685fd9b2610e2dda4120201599104a8f5180b2f70c971246c1e8916a6955bca42d8a4cdf799308b4e9dd7ccfaa5777cd7cb20e99897fcd33d7cd3b2719dc9be350817f667b4b67b3c05fb5d44ecb875e02391646fdd42b3a706447582505ff1b2cea51fd78e13545b88523d10f8bb0ab33aadac8deddf532212bafb965683e44bd408bafe1dd3b94f8edd0dfba0ca477febe05bc3b826d0bc7c6bd57d1f6bd23c884c712b42ee6d5a41d7a8ee8988c95db8259621e55f2ef54269b6cc3f20d06cab66e8da154a27487b101a9d275c094b2f5268caa2d986005916c449468fc59ed8cade54a8c5584f5fdfbf91cc4b6b1d71d69f96391cf0ee6f08d5e88ff13224c3b20da12313d4fbf57e36b4fd2a6d2d67c3a2657f7a2db7f1b1e5176db783820d5df315375208b9d64e0e340e7d4765</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>前端</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>encrypt</tag>
      </tags>
  </entry>
</search>
